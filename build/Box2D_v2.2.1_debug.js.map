{"version":3,"file":"build/Box2D_v2.2.1_debug.js","sources":["./box2d_glue.cpp","Box2D_v2.2.1/Box2D/Dynamics/Joints/b2DistanceJoint.h","Box2D_v2.2.1/Box2D/Dynamics/Joints/b2Joint.h","Box2D_v2.2.1/Box2D/Common/b2Math.h","Box2D_v2.2.1/Box2D/Dynamics/b2Fixture.h","/Applications/emscripten/system/include/libcxx/cmath","Box2D_v2.2.1/Box2D/Dynamics/b2Body.h","Box2D_v2.2.1/Box2D/Collision/b2Collision.h","Box2D_v2.2.1/Box2D/Dynamics/Joints/b2FrictionJoint.h","Box2D_v2.2.1/Box2D/Dynamics/Joints/b2PrismaticJoint.h","Box2D_v2.2.1/Box2D/Dynamics/b2World.h","Box2D_v2.2.1/Box2D/Dynamics/Joints/b2WheelJoint.h","Box2D_v2.2.1/Box2D/Collision/Shapes/b2CircleShape.h","Box2D_v2.2.1/Box2D/Collision/Shapes/b2Shape.h","Box2D_v2.2.1/Box2D/Dynamics/Joints/b2WeldJoint.h","Box2D_v2.2.1/Box2D/Dynamics/Joints/b2GearJoint.h","Box2D_v2.2.1/Box2D/Dynamics/Joints/b2PulleyJoint.h","Box2D_v2.2.1/Box2D/Collision/Shapes/b2ChainShape.h","Box2D_v2.2.1/Box2D/Common/b2Draw.h","Box2D_v2.2.1/Box2D/Dynamics/Joints/b2RopeJoint.h","Box2D_v2.2.1/Box2D/Collision/Shapes/b2PolygonShape.h","Box2D_v2.2.1/Box2D/Collision/Shapes/b2EdgeShape.h","Box2D_v2.2.1/Box2D/Dynamics/Joints/b2RevoluteJoint.h","Box2D_v2.2.1/Box2D/Dynamics/Joints/b2MouseJoint.h","Box2D_v2.2.1/Box2D/Dynamics/Contacts/b2Contact.h","Box2D_v2.2.1/Box2D/Dynamics/b2WorldCallbacks.h","glue_stub.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4LA;AAAA;AAAA;AAAA;;;;;;;;;AAzLA;AAAA;;;;;;;;;;AA6LA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AC1IA;AAAA;;;;;;;;AD8IA;AAAA;AAAA;;;;;;;;;AC3IA;AAAA;;;;;;;;;;AD+IA;AAAA;AAAA;AACA;;;;;;;;;;;ACzFA;AAAA;AAAA;AACA;;;;;;;;AD2FA;AAAA;AAAA;;;;;;;;;ACvFA;AAAA;AAAA;;;;;;;;;;AD2FA;AAAA;AAAA;AACA;;;;;;;;;;;ACvFA;AAAA;AAAA;AACA;;;;;;;;ADyFA;AAAA;AAAA;;;;;;;;;ACrFA;AAAA;AAAA;;;;;;;;;;ADyFA;AAAA;AAAA;AACA;;;;;;;;;;;ACrFA;AAAA;AAAA;AACA;;;;;;;;ADuFA;AAAA;AAAA;;;;;;;;;ACnFA;AAAA;AAAA;;;;;;;;ADuFA;AAAA;AAAA;;;;;;;;;AErEA;AAAA;AAAA;;;;;;;;AFyEA;AAAA;AAAA;;;;;;;;;AEpEA;AAAA;AAAA;;;;;;;;AFwEA;AAAA;AAAA;;;;;;;;;AEnEA;AAAA;AAAA;;;;;;;;;AFuEA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AGvMA;AAAA;;;;;;;;;AH2MA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AErFA;AAAA;AAAA;;;;;;;;AFyFA;AAAA;AAAA;;;;;;;;;AE/EA;AAAA;AAAA;;;;;;;;;;AFmFA;AAAA;AAAA;AACA;;;;;;;;;;;AE/EA;AAAA;AAAA;AACA;;;;;;;;AFiFA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AEjFA;AAAA;AAAA;AAAA;;;;;;;;AFqFA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AGvCA;AAAA;;;;;;;;;;;;AH2CA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AGnCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AHuCA;AAAA;AACA;;;;;;;;;AGnCA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AHmCA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AGrKA;AAAA;;;;;;;;;;;AHyKA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AIlIA;AAAA;AAAA;AAAA;;;;;;;;AJsIA;AAAA;AAAA;;;;;;;;;AIjIA;AAAA;AAAA;;;;;;;;;;;AJqIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AI/HA;AAAA;AAAA;AAAA;;;;;;;;;;AJmIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AIlIA;AAAA;;;;;;;;AJsIA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AI3HA;AAAA;AAAA;;;;;;;;AJ+HA;AAAA;AAAA;;;;;;;;;AIrHA;AAAA;AAAA;;;;;;;;AJyHA;AAAA;AAAA;;;;;;;;;AI7IA;AAAA;AAAA;;;;;;;;;;AJiJA;AAAA;AAAA;AACA;;;;;;;;;;;AI7IA;AAAA;AAAA;AACA;;;;;;;;;;AJ+IA;AAAA;AAAA;AAAA;;;;;;;;;;;AIxFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AJ4FA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AIvFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AJ2FA;AAAA;AAAA;AACA;;;;;;;;;;;AIvFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AJyFA;AAAA;AAAA;AACA;;;;;;;;;;;AIpIA;AAAA;;AAAA;AAAA;;AACA;AAAA;AACA;;;AAFA;AAAA;;;;;;;;AJuIA;AAAA;AAAA;;;;;;;;;AIjIA;AAAA;;;;;;;;AJqIA;AAAA;AAAA;;;;;;;;;AIhIA;AAAA;AAAA;;;;;;;;;;AJoIA;AAAA;AAAA;AACA;;;;;;;;;;;AIhIA;AAAA;AAAA;AACA;;;;;;;;AJkIA;AAAA;AAAA;;;;;;;;;AI9HA;AAAA;AAAA;;;;;;;;;;AJkIA;AAAA;AAAA;AACA;;;;;;;;;;;AI9HA;AAAA;AAAA;AACA;;;;;;;;;;AJgIA;AAAA;AAAA;AAAA;;;;;;;;;;;AI7GA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;;;;;;;;;;;;AJiHA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AIzaA;AAAA;;;;;;;;AJ6aA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;AArdA;AAAA;;;;;;;;;;AAydA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAKA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AGjSA;AAAA;;;;;;;;AHqSA;AAAA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AG7RA;AAAA;AAAA;;;;;;;;;;AHiSA;AAAA;AAAA;AACA;;;;;;;;;;;AG5RA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;AH6RA;AAAA;AACA;;;;;;;;;AGzRA;AACA;AAAA;AACA;;;;;;;;AH0RA;AAAA;AAAA;;;;;;;;;AGrRA;AAAA;AAAA;;;AEgYA;AAAA;AAAA;AFhYA;;;;;;;;;AHyRA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;AGpRA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AHwRA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;AGnRA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AHuRA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AMnpBA;AAAA;;;;;;;;ANupBA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;AApyBA;AAAA;;;;;;;;;;;;;;;;AAwyBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAIA;AAAA;AAAA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AGr0BA;AAAA;AAAA;AAAA;;;;;;;;AHy0BA;AAAA;AACA;;;;;;;;;AGv0BA;AAAA;AAAA;AAAA;;;;;;;;;;;;AH00BA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AGx0BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AH20BA;AAAA;AAAA;AACA;;;;;;;;;;;AGxzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AH0zBA;AAAA;AAAA;AACA;;;;;;;;;;;AGtzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AHwzBA;AAAA;AAAA;AACA;;;;;;;;;;;AGpzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AHszBA;AAAA;AAAA;;;;;;;;;AGjzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AE63BA;AAAA;AF73BA;;;;;;;;AHqzBA;AAAA;AAAA;;;;;;;;;AG9yBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AHkzBA;AAAA;AAAA;;;;;;;;;;AG5yBA;AAAA;AACA;AAAA;;AAEA;AAOA;AAAA;;AALA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;;;;;;;;;;AHsyBA;AAAA;AAAA;;;;;;;;;AGjyBA;AAAA;;;AACA;;AADA;AAAA;AAAA;;AACA;;;;;;;;;AHoyBA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;AGhyBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AHoyBA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AGjzBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AHqzBA;AAAA;AACA;;;;;;;;;AGnzBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AHszBA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AGpzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AHuzBA;AAAA;AAAA;AACA;;;;;;;;;;;;AGhzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AHkzBA;AAAA;AAAA;AACA;;;;;;;;;;;;AG9yBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AHgzBA;AAAA;AAAA;AACA;;;;;;;;;;;AG5yBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AH8yBA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;AAAA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AOv2BA;AAAA;;;;;;;;AP22BA;AAAA;AAAA;;;;;;;;;;;AO7wBA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;;;AACA;AAAA;AAAA;;;;;;;;;AP8wBA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;AOx2BA;AAAA;AAAA;AAAA;;;;;;;;;AP42BA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;AOv2BA;AAAA;AAAA;AAAA;;;;;;;;AP22BA;AAAA;AAAA;;;;;;;;;AOr2BA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;APu2BA;AAAA;AAAA;AACA;;;;;;;;;;;;;AOl2BA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;APm2BA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AO/1BA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;APg2BA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AO31BA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;;;;;;;;;AP01BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AIjgCA;AAAA;;;;;;;;AJqgCA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AQpmCA;AAAA;;;;;;;;;;;;;;ARwmCA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;AAAA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AO/nCA;AAAA;;;;;;;;APmoCA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;ASztCA;AAAA;;;;;;;;;;;;;;;;AT6tCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AACA;;;;;;;;AAGA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AU7rCA;AAAA;AAAA;;;;;;;;AVisCA;AAAA;AAAA;;;;;;;;;AUvrCA;AAAA;AAAA;;;;;;;;AV2rCA;AAAA;AAAA;;;;;;;;;AUjrCA;AAAA;AAAA;AAAA;;;;;;;;;;;AVqrCA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AUl0CA;AAAA;AAAA;AAAA;;;;;;;;;;;AVs0CA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AUp0CA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AVu0CA;AAAA;AAAA;;;;;;;;;AUt0CA;AAAA;AAAA;AAAA;;;;;;;;;;;AV00CA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AUx0CA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AV20CA;AAAA;AAAA;;;;;;;;;AU10CA;AAAA;AAAA;AAAA;;;;;;;;;;;AV80CA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AU50CA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AV+0CA;AAAA;AAAA;;;;;;;;;AU90CA;AAAA;AAAA;AAAA;;;;;;;;AVk1CA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AU/sCA;AAAA;AAAA;;;;;;;;AVmtCA;AAAA;AAAA;;;;;;;;;AU9sCA;AAAA;AAAA;;;;;;;;AVktCA;AAAA;AAAA;;;;;;;;;AU7sCA;AAAA;AAAA;AAAA;;;;;;;;AVitCA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;;AUztCA;AAAA;AAAA;AACA;;;;;;;;;AV2tCA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;AUxtCA;AAAA;AAAA;;;;;;;;AV4tCA;AAAA;AAAA;;;;;;;;;AUvtCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AV2tCA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AUvtCA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAMA;;AAFA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;AVktCA;AAAA;AAAA;;;;;;;;;AU7sCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AVitCA;AAAA;AAAA;;;;;;;;;AUvsCA;AAAA;;;;;;;;AV2sCA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;;AADA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AACA;;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AS/8CA;AAAA;;;;;;;;ATm9CA;AAAA;AAAA;;;;;;;;;ASh9CA;AAAA;;;;;;;;ATo9CA;AAAA;AAAA;;;;;;;;;ASj9CA;AAAA;;;;;;;;ATq9CA;AAAA;AAAA;;;;;;;;;ASl9CA;AAAA;AAAA;;;;;;;;ATs9CA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;ASt6CA;AAAA;AAAA;;;;;;;;;;AT06CA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;ASj+CA;AAAA;AAAA;;;;;;;;;;ATq+CA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;AAjqDA;AAAA;;;;;;;;;;AAqqDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AGvjDA;AAAA;;;;;;;;;;AH2jDA;AAAA;AAAA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AGpjDA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AHwjDA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AGjjDA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AHqjDA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AGjjDA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AHkjDA;AAAA;AACA;;;;;;;;;AG9iDA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AH+iDA;AAAA;AACA;;;;;;;;;AG3iDA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AH4iDA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;AGziDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AHoiDA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AG9hDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AHyhDA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AWzwDA;AAAA;;;;;;;;;;;;;;;;AX6wDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AYp2DA;AAAA;;;;;;;;AZw2DA;AAAA;AAAA;;;;;;;;;Aa50DA;AAAA;AAAA;;;;;;;;Abg1DA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;Ac/7DA;AAAA;;;;;;;;;;;;;;Adm8DA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;;;AAKA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;AAAA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;Aa7jEA;AAAA;;;;;;;;AbikEA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AejnEA;AAAA;AAAA;;;;;;;;AfqnEA;AAAA;AAAA;;;;;;;;;AelnEA;AAAA;AAAA;;;;;;;;;;AfsnEA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;Ac1rEA;AAAA;;;;;;;;Ad8rEA;AAAA;AAAA;;;;;;;;;Ac3rEA;AAAA;;;;;;;;;;Ad+rEA;AAAA;AAAA;AACA;;;;;;;;;;;Ac1rEA;AAAA;AAAA;AAAA;;;;;;;;Ad6rEA;AAAA;AAAA;;;;;;;;;Ac5rEA;AAAA;AAAA;;;;;;;;;;AdgsEA;AAAA;AAAA;AACA;;;;;;;;;;;Ac9rEA;AAAA;AAAA;AAAA;;;;;;;;AdisEA;AAAA;AAAA;;;;;;;;;AchsEA;AAAA;AAAA;;;;;;;;AdosEA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;AAKA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AgBx1EA;AAAA;;;;;;;;;;;;;;;;;;;;;;AhB41EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;AAAA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AOh7EA;AAAA;;;;;;;;APo7EA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AEn9EA;AAAA;;;;;;;;AFu9EA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AG3uEA;AAAA;;;;;;;;;;AH+uEA;AAAA;AAAA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AG5uEA;AAAA;AAAA;AAAA;;;;;;;;AHgvEA;AAAA;AACA;;;;;;;;;AG5uEA;AACA;AAAA;AACA;;;;;;;;;;;;AH6uEA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AGzuEA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AH0uEA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AiBzhFA;AAAA;;;;;;;;;;;;AjB6hFA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AkB3tFA;AAAA;;;;;;;;;;;;AlB+tFA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AkB9tFA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AlBkuFA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AkBluFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AlBquFA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AmBztFA;AAAA;;;;;;;;AnB6tFA;AAAA;AAAA;;;;;;;;;AmB1tFA;AAAA;;;;;;;;;;AnB8tFA;AAAA;AAAA;AACA;;;;;;;;;;;AmB5tFA;AAAA;AAAA;AAAA;;;;;;;;AnB+tFA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AoBjzFA;AAAA;;;;;;;;;;;;ApBqzFA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AoBl1FA;AAAA;AAAA;;;;;;;;;;ApBs1FA;AAAA;AAAA;AAAA;;;;;;;;;;;AoBj0FA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AADA;AAAA;;;;;;;;;;ApBq0FA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AqBt5FA;AAAA;;;;;;;;;;;;ArB05FA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;AA59FA;AAAA;;;;;;;;;;;;AAg+FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AsBjiGA;AAAA;;;;;;;;;;;;;;AtBqiGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;AAAA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAtlGA;AAAA;;;;;;;;;;;;;;AA0lGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AWvpGA;AAAA;;;;;;;;AX2pGA;AAAA;AAAA;;;;;;;;;AWxpGA;AAAA;;;;;;;;AX4pGA;AAAA;AAAA;;;;;;;;;AWzpGA;AAAA;;;;;;;;AX6pGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AWzlGA;AAAA;AAAA;;;;;;;;;;AX6lGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AW5lGA;AAAA;AAAA;;;;;;;;;;AXgmGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;;AWhmGA;AAAA;AAAA;AACA;;;;;;;;AXkmGA;AAAA;AAAA;;;;;;;;;AW9lGA;AAAA;AAAA;;;;;;;;;;AXkmGA;AAAA;AAAA;AACA;;;;;;;;;;;AW9lGA;AAAA;AAAA;AACA;;;;;;;;AXgmGA;AAAA;AAAA;;;;;;;;;AW5lGA;AAAA;AAAA;;;;;;;;AXgmGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAKA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AuBv5GA;AAAA;;;;;;;;AvB25GA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AwBpzGA;AAAA;;;;;;;;AxBwzGA;AAAA;AAAA;;;;;;;;;AwBnxGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AxBuxGA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AwBzyGA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAMA;;AAFA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;AxBoyGA;AAAA;AAAA;;;;;;;;;AwBhyGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AxBoyGA;AAAA;AAAA;;;;;;;;;AwB1xGA;AAAA;AAAA;;;;;;;;AxB8xGA;AAAA;AAAA;;;;;;;;;AwBpxGA;AAAA;AAAA;;;;;;;;AxBwxGA;AAAA;AAAA;;;;;;;;;AwBzwGA;AAAA;AAAA;;;;;;;;AxB6wGA;AAAA;AAAA;;;;;;;;;AwBlxGA;AAAA;AAAA;;;;;;;;AxBsxGA;AAAA;AAAA;;;;;;;;;AwBvwGA;AAAA;AAAA;;;;;;;;;;AxB2wGA;AAAA;AAAA;AACA;;;;;;;;;;;AwBlwGA;AAAA;AAAA;AACA;;;;;;;;AxBowGA;AAAA;AAAA;;;;;;;;;AwBhwGA;AAAA;AAAA;;;;;;;;AxBowGA;AAAA;AACA;;;;;;;;;AwBhwGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AxBkwGA;AAAA;AAAA;AACA;;;;;;;;;;;AwB/vGA;AAAA;AAAA;AACA;;;;;;;;AxBiwGA;AAAA;AAAA;;;;;;;;;AwB7vGA;AAAA;AAAA;;;;;;;;AxBiwGA;AAAA;AACA;;;;;;;;;AwB7vGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AxBiwGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AChlHA;AAAA;;;;;;;;;;;;;;;;ADolHA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AMhxGA;AAAA;;;;;;;;ANoxGA;AAAA;AAAA;;;;;;;;;AM/wGA;AAAA;;;;;;;;ANmxGA;AAAA;AAAA;;;;;;;;;AM9wGA;AAAA;AAAA;AAAA;;;;;;;;ANkxGA;AAAA;AAAA;;;;;;;;;AM7wGA;AAAA;AAAA;;;;;;;;ANixGA;AAAA;AAAA;;;;;;;;;AM5wGA;AAAA;;;;;;;;;;ANgxGA;AAAA;AAAA;AACA;;;;;;;;;;;AM5wGA;AAAA;;AAUA;;AALA;AAAA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;ANqwGA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;AMjwGA;AAAA;AAAA;;;;;;;;;;ANqwGA;AAAA;AAAA;AACA;;;;;;;;;;;AMjwGA;AAAA;;AAUA;;AALA;AAAA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AAAA;;;;;;;;AN0vGA;AAAA;AAAA;;;;;;;;;AMrvGA;AAAA;AAAA;;;;;;;;;;;;ANyvGA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AMjiGA;AAAA;;AAWA;;AANA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ANyhGA;AAAA;AAAA;AACA;;;;;;;;;;;AMrhGA;AAAA;;AAUA;;AALA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AN8gGA;AAAA;AAAA;AACA;;;;;;;;;;;AM1gGA;AAAA;;AAUA;;AALA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;ANmgGA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AM//FA;AAAA;;AAUA;;AALA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ANw/FA;AAAA;AAAA;AACA;;;;;;;;;;;AMp/FA;AAAA;;AASA;;AAJA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AN8+FA;AAAA;AAAA;;;;;;;;;AMxwGA;AAAA;AAAA;;;;;;;;AN4wGA;AAAA;AAAA;;;;;;;;;AMvwGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AN2wGA;AAAA;AAAA;AACA;;;;;;;;;;;;AMvwGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;ANuwGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AACA;;;;;;;;;;;AAGA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AM5wGA;AAAA;AAAA;AAAA;;;;;;;;;;;ANgxGA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AM5wGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ANgxGA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AM5wGA;AAAA;AAAA;AAAA;;;;;;;;;;;ANgxGA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AM5wGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ANgxGA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AM5wGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ANgxGA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AM5wGA;AAAA;AAAA;AAAA;;;;;;;;ANgxGA;AAAA;AAAA;;;;;;;;;AM3wGA;AAAA;AAAA;;;;;;;;;;AN+wGA;AAAA;AAAA;AACA;;;;;;;;;;;AM3wGA;AAAA;AAAA;AACA;;;;;;;;AN6wGA;AAAA;AAAA;;;;;;;;;AMzwGA;AAAA;AAAA;;;;;;;;;;AN6wGA;AAAA;AAAA;AACA;;;;;;;;;;;AMzwGA;AAAA;AAAA;AACA;;;;;;;;AN2wGA;AAAA;AAAA;;;;;;;;;AMvwGA;AAAA;AAAA;;;;;;;;;;AN2wGA;AAAA;AAAA;AACA;;;;;;;;;;;AMvwGA;AAAA;AAAA;AACA;;;;;;;;;;ANywGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AM55GA;AAAA;;;;;;;;;;;ANg6GA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AM9wGA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;ANywGA;AAAA;AAAA;;;;;;;;;AMrwGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ANywGA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AMntGA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;;;;;;;;;AN6sGA;AAAA;AAAA;;;;;;;;;AMzsGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AN6sGA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AM7wGA;AAAA;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;;AAfA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAYA;;;;;;;;AN+vGA;AAAA;AAAA;;;;;;;;;AM3vGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AN+vGA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AM9vGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ANkwGA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AM9vGA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;;;;;;;;;ANuvGA;AAAA;AAAA;;;;;;;;;AMnvGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;ANuvGA;AAAA;AAAA;;;;;;;;;AMhuGA;AAAA;AAAA;;;;;;;;ANouGA;AAAA;AAAA;;;;;;;;;AM1tGA;AAAA;AAAA;;;;;;;;AN8tGA;AAAA;AAAA;;;;;;;;;AMptGA;AAAA;AAAA;;;;;;;;ANwtGA;AAAA;AAAA;;;;;;;;;AM9sGA;AAAA;AAAA;;;;;;;;ANktGA;AAAA;AAAA;;;;;;;;;AMnsGA;AAAA;AAAA;;;;;;;;;;ANusGA;AAAA;AAAA;AACA;;;;;;;;;;;AM7sGA;AAAA;AAAA;AACA;;;;;;;;AN+sGA;AAAA;AAAA;;;;;;;;;AM3mGA;AAAA;AAAA;;;;;;;;AN+mGA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AQ13HA;AAAA;;;;;;;;AR83HA;AAAA;AAAA;;;;;;;;;AQ33HA;AAAA;;;;;;;;;;AR+3HA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;Aeh/HA;AAAA;;;;;;;;Afo/HA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AsB3/HA;AAAA;;;;;;;;AtB+/HA;AAAA;AAAA;;;;;;;;;AsB5/HA;AAAA;;;;;;;;AtBggIA;AAAA;AAAA;;;;;;;;;AsB7/HA;AAAA;AAAA;;;;;;;;AtBigIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AsBv8HA;AAAA;AAAA;;;;;;;;;;AtB28HA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AsB5gIA;AAAA;AAAA;;;;;;;;;;AtBghIA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;AAKA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AmBruIA;AAAA;;;;;;;;AnByuIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;AAIA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAKA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAKA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAKA;;;;;AAGA;;;;;AAGA;;;;;AAKA;;;;;AAGA;;;;;AAGA;;;;;AAKA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAKA;;;;;AAGA;;;;;;;;;AmB/5IA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;AjByCA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;AarDA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AZyaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AApBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AA0BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAwHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;AA9KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAmDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AA7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AFxYA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;AuBMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAPA;AAAA;AAAA;;AnBw8BA;AAAA;AmBx8BA;;;;;;;;;ADVA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;AvBuFA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;AA3CA;AAAA;;;;;;;;AkBrFA;;;;;;;;;AICA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;AtBuDA;;AAAA;AAAA;;;;;;;;;;AyBpDA;AAAA;;;;;;;;;AzBoDA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAHA;AAAA;;;;;;;;AyBjDA;;;;;;;;;;AJQA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;;;;AAAA;;AAAA;;;;AAAA;;AAAA;;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;AATA;AAAA;;AASA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;AR9BA;AAAA;;;;;;;;AAaA;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AO2BA;;AAAA;AAAA;;AAAA;;;;;AAAA;AAAA;;;;AAAA;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;AAAA;;;;;;AAAA;AAAA;;;;;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAAA;;;;AACA;;;;;;AALA;AAAA;;AAKA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;AF9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AADA;;;;;;;;;;ADqEA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;AAPA;AAAA;;AAOA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;Ad2QA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAHA;AAAA;AAAA;AAAA;;;;;;;;;AIvSA;AAAA;;;;;;;;;AStCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;AHdA;AAAA;AAAA;;;;;;;;;ACGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;AF6BA;;AAAA;AAAA;;AAAA;;;;AACA;AAAA;AACA;AAAA;AACA;;AAAA;;;;AACA;;;;;AAJA;AAAA;;AAIA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;ADrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;ARqKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAVA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;AAPA;AAAA;AAAA;AAAA;;;;;;;;;AHpIA;;AAAA;AAAA;;;;;;;;;;AyBgBA;AAAA;;;;;;;;;AzBhBA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;AA7BA;AAAA;;;;;;;;AyBmBA;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAGA;;;;;;;;;;AAGA;;;;;;;;;;;;AAgBA;;;;;;;;;;;;AAYA;;;;;;;;;AhBrFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;AFgDA;;;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ACjEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;AJ0BA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;ADukBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AIpeA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AJAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAhIA;AAAA;AAAA;;AAGA;AAAA;AAKA;AAAA;AAAA;;AAFA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;;;;;;;;;;;;AA6BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AHvBA;;AAAA;AAAA;;;;;;;;;;AyBwFA;AAAA;;;;;;;;;AzBxFA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAHA;AAAA;;;;;;;;AyB2FA;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AnBnFA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AHwPA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;AARA;;;;;;;;;AH3RA;;AAAA;AAAA;;;;;;;;;;AyB8FA;AAAA;;;;;;;;;AzB9FA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAHA;AAAA;;;;;;;;AyBiGA;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ArB1FA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;ADuHA;;;;;;;;;;;;;;;AAqHA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AA5MA;;;;;;;;;AH/DA;;AAAA;AAAA;;;;;;;;;A0BOA;;AAAA;AAAA;;;;;;;;;A1BPA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;A0BeA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;A1BjBA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;AAfA;AAAA;;;;;;;;;A0BSA;AAAA;;;;;;;;AD0BA;;;;;;;;;;AAHA;AAAA;;;;;;;;;ACvBA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AD0BA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["\n#include <emscripten.h>\n\nclass JSDestructionListener : public b2DestructionListenerWrapper {\npublic:\n  void SayGoodbyeJoint(b2Joint* arg0) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDestructionListener'])[$0];\n      if (!self.hasOwnProperty('SayGoodbyeJoint')) throw 'a JSImplementation must implement all functions, you forgot JSDestructionListener::SayGoodbyeJoint.';\n      self.SayGoodbyeJoint($1);\n    }, (int)this, (int)arg0);\n  }\n  void SayGoodbyeFixture(b2Fixture* arg0) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDestructionListener'])[$0];\n      if (!self.hasOwnProperty('SayGoodbyeFixture')) throw 'a JSImplementation must implement all functions, you forgot JSDestructionListener::SayGoodbyeFixture.';\n      self.SayGoodbyeFixture($1);\n    }, (int)this, (int)arg0);\n  }\n  void __destroy__() {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDestructionListener'])[$0];\n      if (!self.hasOwnProperty('__destroy__')) throw 'a JSImplementation must implement all functions, you forgot JSDestructionListener::__destroy__.';\n      self.__destroy__();\n    }, (int)this);\n  }\n};\n\nclass JSQueryCallback : public b2QueryCallback {\npublic:\n  bool ReportFixture(b2Fixture* arg0) {\n    return EM_ASM_INT({\n      var self = Module['getCache'](Module['JSQueryCallback'])[$0];\n      if (!self.hasOwnProperty('ReportFixture')) throw 'a JSImplementation must implement all functions, you forgot JSQueryCallback::ReportFixture.';\n      return self.ReportFixture($1);\n    }, (int)this, (int)arg0);\n  }\n  void __destroy__() {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSQueryCallback'])[$0];\n      if (!self.hasOwnProperty('__destroy__')) throw 'a JSImplementation must implement all functions, you forgot JSQueryCallback::__destroy__.';\n      self.__destroy__();\n    }, (int)this);\n  }\n};\n\nclass JSRayCastCallback : public b2RayCastCallback {\npublic:\n  float ReportFixture(b2Fixture* arg0, const b2Vec2& arg1, const b2Vec2& arg2, float arg3) {\n    return EM_ASM_DOUBLE({\n      var self = Module['getCache'](Module['JSRayCastCallback'])[$0];\n      if (!self.hasOwnProperty('ReportFixture')) throw 'a JSImplementation must implement all functions, you forgot JSRayCastCallback::ReportFixture.';\n      return self.ReportFixture($1,$2,$3,$4);\n    }, (int)this, (int)arg0, (int)&arg1, (int)&arg2, arg3);\n  }\n  void __destroy__() {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSRayCastCallback'])[$0];\n      if (!self.hasOwnProperty('__destroy__')) throw 'a JSImplementation must implement all functions, you forgot JSRayCastCallback::__destroy__.';\n      self.__destroy__();\n    }, (int)this);\n  }\n};\n\nclass JSContactListener : public b2ContactListener {\npublic:\n  void BeginContact(b2Contact* arg0) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSContactListener'])[$0];\n      if (!self.hasOwnProperty('BeginContact')) throw 'a JSImplementation must implement all functions, you forgot JSContactListener::BeginContact.';\n      self.BeginContact($1);\n    }, (int)this, (int)arg0);\n  }\n  void EndContact(b2Contact* arg0) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSContactListener'])[$0];\n      if (!self.hasOwnProperty('EndContact')) throw 'a JSImplementation must implement all functions, you forgot JSContactListener::EndContact.';\n      self.EndContact($1);\n    }, (int)this, (int)arg0);\n  }\n  void PreSolve(b2Contact* arg0, const b2Manifold* arg1) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSContactListener'])[$0];\n      if (!self.hasOwnProperty('PreSolve')) throw 'a JSImplementation must implement all functions, you forgot JSContactListener::PreSolve.';\n      self.PreSolve($1,$2);\n    }, (int)this, (int)arg0, (int)arg1);\n  }\n  void PostSolve(b2Contact* arg0, const b2ContactImpulse* arg1) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSContactListener'])[$0];\n      if (!self.hasOwnProperty('PostSolve')) throw 'a JSImplementation must implement all functions, you forgot JSContactListener::PostSolve.';\n      self.PostSolve($1,$2);\n    }, (int)this, (int)arg0, (int)arg1);\n  }\n  void __destroy__() {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSContactListener'])[$0];\n      if (!self.hasOwnProperty('__destroy__')) throw 'a JSImplementation must implement all functions, you forgot JSContactListener::__destroy__.';\n      self.__destroy__();\n    }, (int)this);\n  }\n};\n\nclass JSContactFilter : public b2ContactFilter {\npublic:\n  bool ShouldCollide(b2Fixture* arg0, b2Fixture* arg1) {\n    return EM_ASM_INT({\n      var self = Module['getCache'](Module['JSContactFilter'])[$0];\n      if (!self.hasOwnProperty('ShouldCollide')) throw 'a JSImplementation must implement all functions, you forgot JSContactFilter::ShouldCollide.';\n      return self.ShouldCollide($1,$2);\n    }, (int)this, (int)arg0, (int)arg1);\n  }\n  void __destroy__() {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSContactFilter'])[$0];\n      if (!self.hasOwnProperty('__destroy__')) throw 'a JSImplementation must implement all functions, you forgot JSContactFilter::__destroy__.';\n      self.__destroy__();\n    }, (int)this);\n  }\n};\n\nclass JSDraw : public b2Draw {\npublic:\n  void DrawPolygon(const b2Vec2* arg0, int arg1, const b2Color& arg2) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDraw'])[$0];\n      if (!self.hasOwnProperty('DrawPolygon')) throw 'a JSImplementation must implement all functions, you forgot JSDraw::DrawPolygon.';\n      self.DrawPolygon($1,$2,$3);\n    }, (int)this, (int)arg0, arg1, (int)&arg2);\n  }\n  void DrawSolidPolygon(const b2Vec2* arg0, int arg1, const b2Color& arg2) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDraw'])[$0];\n      if (!self.hasOwnProperty('DrawSolidPolygon')) throw 'a JSImplementation must implement all functions, you forgot JSDraw::DrawSolidPolygon.';\n      self.DrawSolidPolygon($1,$2,$3);\n    }, (int)this, (int)arg0, arg1, (int)&arg2);\n  }\n  void DrawCircle(const b2Vec2& arg0, float arg1, const b2Color& arg2) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDraw'])[$0];\n      if (!self.hasOwnProperty('DrawCircle')) throw 'a JSImplementation must implement all functions, you forgot JSDraw::DrawCircle.';\n      self.DrawCircle($1,$2,$3);\n    }, (int)this, (int)&arg0, arg1, (int)&arg2);\n  }\n  void DrawSolidCircle(const b2Vec2& arg0, float arg1, const b2Vec2& arg2, const b2Color& arg3) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDraw'])[$0];\n      if (!self.hasOwnProperty('DrawSolidCircle')) throw 'a JSImplementation must implement all functions, you forgot JSDraw::DrawSolidCircle.';\n      self.DrawSolidCircle($1,$2,$3,$4);\n    }, (int)this, (int)&arg0, arg1, (int)&arg2, (int)&arg3);\n  }\n  void DrawSegment(const b2Vec2& arg0, const b2Vec2& arg1, const b2Color& arg2) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDraw'])[$0];\n      if (!self.hasOwnProperty('DrawSegment')) throw 'a JSImplementation must implement all functions, you forgot JSDraw::DrawSegment.';\n      self.DrawSegment($1,$2,$3);\n    }, (int)this, (int)&arg0, (int)&arg1, (int)&arg2);\n  }\n  void DrawTransform(const b2Transform& arg0) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDraw'])[$0];\n      if (!self.hasOwnProperty('DrawTransform')) throw 'a JSImplementation must implement all functions, you forgot JSDraw::DrawTransform.';\n      self.DrawTransform($1);\n    }, (int)this, (int)&arg0);\n  }\n  void __destroy__() {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDraw'])[$0];\n      if (!self.hasOwnProperty('__destroy__')) throw 'a JSImplementation must implement all functions, you forgot JSDraw::__destroy__.';\n      self.__destroy__();\n    }, (int)this);\n  }\n};\n\nextern \"C\" {\n\n// Not using size_t for array indices as the values used by the javascript code are signed.\nvoid array_bounds_check(const int array_size, const int array_idx) {\n  if (array_idx < 0 || array_idx >= array_size) {\n    EM_ASM_INT({\n      throw 'Array index ' + $0 + ' out of bounds: [0,' + $1 + ')';\n    }, array_idx, array_size);\n  }\n}\n\n// JSDestructionListener\n\nJSDestructionListener* EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDestructionListener_JSDestructionListener_0() {\n  return new JSDestructionListener();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDestructionListener_SayGoodbyeJoint_1(JSDestructionListener* self, b2Joint* arg0) {\n  self->SayGoodbyeJoint(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDestructionListener_SayGoodbyeFixture_1(JSDestructionListener* self, b2Fixture* arg0) {\n  self->SayGoodbyeFixture(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDestructionListener___destroy___0(JSDestructionListener* self) {\n  delete self;\n}\n\n// b2ContactImpulse\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactImpulse_get_count_0(b2ContactImpulse* self) {\n  return self->count;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactImpulse_set_count_1(b2ContactImpulse* self, int arg0) {\n  self->count = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactImpulse___destroy___0(b2ContactImpulse* self) {\n  delete self;\n}\n\n// b2DistanceJoint\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetLocalAnchorA_0(b2DistanceJoint* self) {\n  return &self->GetLocalAnchorA();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetLocalAnchorB_0(b2DistanceJoint* self) {\n  return &self->GetLocalAnchorB();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_SetLength_1(b2DistanceJoint* self, float arg0) {\n  self->SetLength(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetLength_0(b2DistanceJoint* self) {\n  return self->GetLength();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_SetFrequency_1(b2DistanceJoint* self, float arg0) {\n  self->SetFrequency(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetFrequency_0(b2DistanceJoint* self) {\n  return self->GetFrequency();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_SetDampingRatio_1(b2DistanceJoint* self, float arg0) {\n  self->SetDampingRatio(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetDampingRatio_0(b2DistanceJoint* self) {\n  return self->GetDampingRatio();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetType_0(b2DistanceJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetBodyA_0(b2DistanceJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetBodyB_0(b2DistanceJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetAnchorA_0(b2DistanceJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetAnchorB_0(b2DistanceJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetReactionForce_1(b2DistanceJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetReactionTorque_1(b2DistanceJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetNext_0(b2DistanceJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetUserData_0(b2DistanceJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_SetUserData_1(b2DistanceJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_IsActive_0(b2DistanceJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetCollideConnected_0(b2DistanceJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint___destroy___0(b2DistanceJoint* self) {\n  delete self;\n}\n\n// b2Mat33\n\nb2Mat33* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_b2Mat33_0() {\n  return new b2Mat33();\n}\n\nb2Mat33* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_b2Mat33_3(b2Vec3* arg0, b2Vec3* arg1, b2Vec3* arg2) {\n  return new b2Mat33(*arg0, *arg1, *arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_SetZero_0(b2Mat33* self) {\n  self->SetZero();\n}\n\nb2Vec3* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_Solve33_1(b2Mat33* self, b2Vec3* arg0) {\n  static b2Vec3 temp;\n  return (temp = self->Solve33(*arg0), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_Solve22_1(b2Mat33* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->Solve22(*arg0), &temp);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_GetInverse22_1(b2Mat33* self, b2Mat33* arg0) {\n  self->GetInverse22(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_GetSymInverse33_1(b2Mat33* self, b2Mat33* arg0) {\n  self->GetSymInverse33(arg0);\n}\n\nb2Vec3* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_get_ex_0(b2Mat33* self) {\n  return &self->ex;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_set_ex_1(b2Mat33* self, b2Vec3* arg0) {\n  self->ex = *arg0;\n}\n\nb2Vec3* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_get_ey_0(b2Mat33* self) {\n  return &self->ey;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_set_ey_1(b2Mat33* self, b2Vec3* arg0) {\n  self->ey = *arg0;\n}\n\nb2Vec3* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_get_ez_0(b2Mat33* self) {\n  return &self->ez;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_set_ez_1(b2Mat33* self, b2Vec3* arg0) {\n  self->ez = *arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33___destroy___0(b2Mat33* self) {\n  delete self;\n}\n\n// b2Fixture\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetType_0(b2Fixture* self) {\n  return self->GetType();\n}\n\nb2Shape* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetShape_0(b2Fixture* self) {\n  return self->GetShape();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_SetSensor_1(b2Fixture* self, bool arg0) {\n  self->SetSensor(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_IsSensor_0(b2Fixture* self) {\n  return self->IsSensor();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_SetFilterData_1(b2Fixture* self, b2Filter* arg0) {\n  self->SetFilterData(*arg0);\n}\n\nconst b2Filter* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetFilterData_0(b2Fixture* self) {\n  return &self->GetFilterData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_Refilter_0(b2Fixture* self) {\n  self->Refilter();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetBody_0(b2Fixture* self) {\n  return self->GetBody();\n}\n\nb2Fixture* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetNext_0(b2Fixture* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetUserData_0(b2Fixture* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_SetUserData_1(b2Fixture* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_TestPoint_1(b2Fixture* self, b2Vec2* arg0) {\n  return self->TestPoint(*arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_RayCast_3(b2Fixture* self, b2RayCastOutput* arg0, b2RayCastInput* arg1, int arg2) {\n  return self->RayCast(arg0, *arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetMassData_1(b2Fixture* self, b2MassData* arg0) {\n  self->GetMassData(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_SetDensity_1(b2Fixture* self, float arg0) {\n  self->SetDensity(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetDensity_0(b2Fixture* self) {\n  return self->GetDensity();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetFriction_0(b2Fixture* self) {\n  return self->GetFriction();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_SetFriction_1(b2Fixture* self, float arg0) {\n  self->SetFriction(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetRestitution_0(b2Fixture* self) {\n  return self->GetRestitution();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_SetRestitution_1(b2Fixture* self, float arg0) {\n  self->SetRestitution(arg0);\n}\n\nconst b2AABB* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetAABB_1(b2Fixture* self, int arg0) {\n  return &self->GetAABB(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_Dump_1(b2Fixture* self, int arg0) {\n  self->Dump(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture___destroy___0(b2Fixture* self) {\n  delete self;\n}\n\n// b2Filter\n\nb2Filter* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter_b2Filter_0() {\n  return new b2Filter();\n}\n\nunsigned short EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter_get_categoryBits_0(b2Filter* self) {\n  return self->categoryBits;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter_set_categoryBits_1(b2Filter* self, unsigned short arg0) {\n  self->categoryBits = arg0;\n}\n\nunsigned short EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter_get_maskBits_0(b2Filter* self) {\n  return self->maskBits;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter_set_maskBits_1(b2Filter* self, unsigned short arg0) {\n  self->maskBits = arg0;\n}\n\nshort EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter_get_groupIndex_0(b2Filter* self) {\n  return self->groupIndex;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter_set_groupIndex_1(b2Filter* self, short arg0) {\n  self->groupIndex = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter___destroy___0(b2Filter* self) {\n  delete self;\n}\n\n// JSQueryCallback\n\nJSQueryCallback* EMSCRIPTEN_KEEPALIVE emscripten_bind_JSQueryCallback_JSQueryCallback_0() {\n  return new JSQueryCallback();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_JSQueryCallback_ReportFixture_1(JSQueryCallback* self, b2Fixture* arg0) {\n  return self->ReportFixture(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSQueryCallback___destroy___0(JSQueryCallback* self) {\n  delete self;\n}\n\n// b2MouseJoint\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_SetTarget_1(b2MouseJoint* self, b2Vec2* arg0) {\n  self->SetTarget(*arg0);\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetTarget_0(b2MouseJoint* self) {\n  return &self->GetTarget();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_SetMaxForce_1(b2MouseJoint* self, float arg0) {\n  self->SetMaxForce(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetMaxForce_0(b2MouseJoint* self) {\n  return self->GetMaxForce();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_SetFrequency_1(b2MouseJoint* self, float arg0) {\n  self->SetFrequency(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetFrequency_0(b2MouseJoint* self) {\n  return self->GetFrequency();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_SetDampingRatio_1(b2MouseJoint* self, float arg0) {\n  self->SetDampingRatio(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetDampingRatio_0(b2MouseJoint* self) {\n  return self->GetDampingRatio();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetType_0(b2MouseJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetBodyA_0(b2MouseJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetBodyB_0(b2MouseJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetAnchorA_0(b2MouseJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetAnchorB_0(b2MouseJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetReactionForce_1(b2MouseJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetReactionTorque_1(b2MouseJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetNext_0(b2MouseJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetUserData_0(b2MouseJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_SetUserData_1(b2MouseJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_IsActive_0(b2MouseJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetCollideConnected_0(b2MouseJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint___destroy___0(b2MouseJoint* self) {\n  delete self;\n}\n\n// b2Rot\n\nb2Rot* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_b2Rot_0() {\n  return new b2Rot();\n}\n\nb2Rot* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_b2Rot_1(float arg0) {\n  return new b2Rot(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_Set_1(b2Rot* self, float arg0) {\n  self->Set(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_SetIdentity_0(b2Rot* self) {\n  self->SetIdentity();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_GetAngle_0(b2Rot* self) {\n  return self->GetAngle();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_GetXAxis_0(b2Rot* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetXAxis(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_GetYAxis_0(b2Rot* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetYAxis(), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_get_s_0(b2Rot* self) {\n  return self->s;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_set_s_1(b2Rot* self, float arg0) {\n  self->s = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_get_c_0(b2Rot* self) {\n  return self->c;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_set_c_1(b2Rot* self, float arg0) {\n  self->c = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot___destroy___0(b2Rot* self) {\n  delete self;\n}\n\n// b2Profile\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_step_0(b2Profile* self) {\n  return self->step;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_step_1(b2Profile* self, float arg0) {\n  self->step = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_collide_0(b2Profile* self) {\n  return self->collide;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_collide_1(b2Profile* self, float arg0) {\n  self->collide = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_solve_0(b2Profile* self) {\n  return self->solve;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_solve_1(b2Profile* self, float arg0) {\n  self->solve = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_solveInit_0(b2Profile* self) {\n  return self->solveInit;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_solveInit_1(b2Profile* self, float arg0) {\n  self->solveInit = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_solveVelocity_0(b2Profile* self) {\n  return self->solveVelocity;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_solveVelocity_1(b2Profile* self, float arg0) {\n  self->solveVelocity = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_solvePosition_0(b2Profile* self) {\n  return self->solvePosition;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_solvePosition_1(b2Profile* self, float arg0) {\n  self->solvePosition = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_broadphase_0(b2Profile* self) {\n  return self->broadphase;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_broadphase_1(b2Profile* self, float arg0) {\n  self->broadphase = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_solveTOI_0(b2Profile* self) {\n  return self->solveTOI;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_solveTOI_1(b2Profile* self, float arg0) {\n  self->solveTOI = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile___destroy___0(b2Profile* self) {\n  delete self;\n}\n\n// VoidPtr\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_VoidPtr___destroy___0(void** self) {\n  delete self;\n}\n\n// b2BodyDef\n\nb2BodyDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_b2BodyDef_0() {\n  return new b2BodyDef();\n}\n\nb2BodyType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_type_0(b2BodyDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_type_1(b2BodyDef* self, b2BodyType arg0) {\n  self->type = arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_position_0(b2BodyDef* self) {\n  return &self->position;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_position_1(b2BodyDef* self, b2Vec2* arg0) {\n  self->position = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_angle_0(b2BodyDef* self) {\n  return self->angle;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_angle_1(b2BodyDef* self, float arg0) {\n  self->angle = arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_linearVelocity_0(b2BodyDef* self) {\n  return &self->linearVelocity;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_linearVelocity_1(b2BodyDef* self, b2Vec2* arg0) {\n  self->linearVelocity = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_angularVelocity_0(b2BodyDef* self) {\n  return self->angularVelocity;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_angularVelocity_1(b2BodyDef* self, float arg0) {\n  self->angularVelocity = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_linearDamping_0(b2BodyDef* self) {\n  return self->linearDamping;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_linearDamping_1(b2BodyDef* self, float arg0) {\n  self->linearDamping = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_angularDamping_0(b2BodyDef* self) {\n  return self->angularDamping;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_angularDamping_1(b2BodyDef* self, float arg0) {\n  self->angularDamping = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_allowSleep_0(b2BodyDef* self) {\n  return self->allowSleep;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_allowSleep_1(b2BodyDef* self, bool arg0) {\n  self->allowSleep = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_awake_0(b2BodyDef* self) {\n  return self->awake;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_awake_1(b2BodyDef* self, bool arg0) {\n  self->awake = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_fixedRotation_0(b2BodyDef* self) {\n  return self->fixedRotation;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_fixedRotation_1(b2BodyDef* self, bool arg0) {\n  self->fixedRotation = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_bullet_0(b2BodyDef* self) {\n  return self->bullet;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_bullet_1(b2BodyDef* self, bool arg0) {\n  self->bullet = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_active_0(b2BodyDef* self) {\n  return self->active;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_active_1(b2BodyDef* self, bool arg0) {\n  self->active = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_userData_0(b2BodyDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_userData_1(b2BodyDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_gravityScale_0(b2BodyDef* self) {\n  return self->gravityScale;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_gravityScale_1(b2BodyDef* self, float arg0) {\n  self->gravityScale = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef___destroy___0(b2BodyDef* self) {\n  delete self;\n}\n\n// JSRayCastCallback\n\nJSRayCastCallback* EMSCRIPTEN_KEEPALIVE emscripten_bind_JSRayCastCallback_JSRayCastCallback_0() {\n  return new JSRayCastCallback();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_JSRayCastCallback_ReportFixture_4(JSRayCastCallback* self, b2Fixture* arg0, b2Vec2* arg1, b2Vec2* arg2, float arg3) {\n  return self->ReportFixture(arg0, *arg1, *arg2, arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSRayCastCallback___destroy___0(JSRayCastCallback* self) {\n  delete self;\n}\n\n// b2ContactFeature\n\nunsigned char EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_get_indexA_0(b2ContactFeature* self) {\n  return self->indexA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_set_indexA_1(b2ContactFeature* self, unsigned char arg0) {\n  self->indexA = arg0;\n}\n\nunsigned char EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_get_indexB_0(b2ContactFeature* self) {\n  return self->indexB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_set_indexB_1(b2ContactFeature* self, unsigned char arg0) {\n  self->indexB = arg0;\n}\n\nunsigned char EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_get_typeA_0(b2ContactFeature* self) {\n  return self->typeA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_set_typeA_1(b2ContactFeature* self, unsigned char arg0) {\n  self->typeA = arg0;\n}\n\nunsigned char EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_get_typeB_0(b2ContactFeature* self) {\n  return self->typeB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_set_typeB_1(b2ContactFeature* self, unsigned char arg0) {\n  self->typeB = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature___destroy___0(b2ContactFeature* self) {\n  delete self;\n}\n\n// b2Vec2\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_b2Vec2_0() {\n  return new b2Vec2();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_b2Vec2_2(float arg0, float arg1) {\n  return new b2Vec2(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_SetZero_0(b2Vec2* self) {\n  self->SetZero();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_Set_2(b2Vec2* self, float arg0, float arg1) {\n  self->Set(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_op_add_1(b2Vec2* self, b2Vec2* arg0) {\n  (*self += *arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_op_sub_1(b2Vec2* self, b2Vec2* arg0) {\n  (*self -= *arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_op_mul_1(b2Vec2* self, float arg0) {\n  (*self *= arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_Length_0(b2Vec2* self) {\n  return self->Length();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_LengthSquared_0(b2Vec2* self) {\n  return self->LengthSquared();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_Normalize_0(b2Vec2* self) {\n  return self->Normalize();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_IsValid_0(b2Vec2* self) {\n  return self->IsValid();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_Skew_0(b2Vec2* self) {\n  static b2Vec2 temp;\n  return (temp = self->Skew(), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_get_x_0(b2Vec2* self) {\n  return self->x;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_set_x_1(b2Vec2* self, float arg0) {\n  self->x = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_get_y_0(b2Vec2* self) {\n  return self->y;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_set_y_1(b2Vec2* self, float arg0) {\n  self->y = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2___destroy___0(b2Vec2* self) {\n  delete self;\n}\n\n// b2Vec3\n\nb2Vec3* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_b2Vec3_0() {\n  return new b2Vec3();\n}\n\nb2Vec3* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_b2Vec3_3(float arg0, float arg1, float arg2) {\n  return new b2Vec3(arg0, arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_SetZero_0(b2Vec3* self) {\n  self->SetZero();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_Set_3(b2Vec3* self, float arg0, float arg1, float arg2) {\n  self->Set(arg0, arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_op_add_1(b2Vec3* self, b2Vec3* arg0) {\n  (*self += *arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_op_sub_1(b2Vec3* self, b2Vec3* arg0) {\n  (*self -= *arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_op_mul_1(b2Vec3* self, float arg0) {\n  (*self *= arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_get_x_0(b2Vec3* self) {\n  return self->x;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_set_x_1(b2Vec3* self, float arg0) {\n  self->x = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_get_y_0(b2Vec3* self) {\n  return self->y;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_set_y_1(b2Vec3* self, float arg0) {\n  self->y = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_get_z_0(b2Vec3* self) {\n  return self->z;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_set_z_1(b2Vec3* self, float arg0) {\n  self->z = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3___destroy___0(b2Vec3* self) {\n  delete self;\n}\n\n// b2AABB\n\nb2AABB* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_b2AABB_0() {\n  return new b2AABB();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_IsValid_0(b2AABB* self) {\n  return self->IsValid();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_GetCenter_0(b2AABB* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetCenter(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_GetExtents_0(b2AABB* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetExtents(), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_GetPerimeter_0(b2AABB* self) {\n  return self->GetPerimeter();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_Combine_1(b2AABB* self, b2AABB* arg0) {\n  self->Combine(*arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_Combine_2(b2AABB* self, b2AABB* arg0, b2AABB* arg1) {\n  self->Combine(*arg0, *arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_Contains_1(b2AABB* self, b2AABB* arg0) {\n  return self->Contains(*arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_RayCast_2(b2AABB* self, b2RayCastOutput* arg0, b2RayCastInput* arg1) {\n  return self->RayCast(arg0, *arg1);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_get_lowerBound_0(b2AABB* self) {\n  return &self->lowerBound;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_set_lowerBound_1(b2AABB* self, b2Vec2* arg0) {\n  self->lowerBound = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_get_upperBound_0(b2AABB* self) {\n  return &self->upperBound;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_set_upperBound_1(b2AABB* self, b2Vec2* arg0) {\n  self->upperBound = *arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB___destroy___0(b2AABB* self) {\n  delete self;\n}\n\n// b2FixtureDef\n\nb2FixtureDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_b2FixtureDef_0() {\n  return new b2FixtureDef();\n}\n\nconst b2Shape* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_get_shape_0(b2FixtureDef* self) {\n  return self->shape;\n}\n\nconst void EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_set_shape_1(b2FixtureDef* self, b2Shape* arg0) {\n  self->shape = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_get_userData_0(b2FixtureDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_set_userData_1(b2FixtureDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_get_friction_0(b2FixtureDef* self) {\n  return self->friction;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_set_friction_1(b2FixtureDef* self, float arg0) {\n  self->friction = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_get_restitution_0(b2FixtureDef* self) {\n  return self->restitution;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_set_restitution_1(b2FixtureDef* self, float arg0) {\n  self->restitution = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_get_density_0(b2FixtureDef* self) {\n  return self->density;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_set_density_1(b2FixtureDef* self, float arg0) {\n  self->density = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_get_isSensor_0(b2FixtureDef* self) {\n  return self->isSensor;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_set_isSensor_1(b2FixtureDef* self, bool arg0) {\n  self->isSensor = arg0;\n}\n\nb2Filter* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_get_filter_0(b2FixtureDef* self) {\n  return &self->filter;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_set_filter_1(b2FixtureDef* self, b2Filter* arg0) {\n  self->filter = *arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef___destroy___0(b2FixtureDef* self) {\n  delete self;\n}\n\n// b2FrictionJointDef\n\nb2FrictionJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_b2FrictionJointDef_0() {\n  return new b2FrictionJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_Initialize_3(b2FrictionJointDef* self, b2Body* arg0, b2Body* arg1, b2Vec2* arg2) {\n  self->Initialize(arg0, arg1, *arg2);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_localAnchorA_0(b2FrictionJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_localAnchorA_1(b2FrictionJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_localAnchorB_0(b2FrictionJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_localAnchorB_1(b2FrictionJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_maxForce_0(b2FrictionJointDef* self) {\n  return self->maxForce;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_maxForce_1(b2FrictionJointDef* self, float arg0) {\n  self->maxForce = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_maxTorque_0(b2FrictionJointDef* self) {\n  return self->maxTorque;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_maxTorque_1(b2FrictionJointDef* self, float arg0) {\n  self->maxTorque = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_type_0(b2FrictionJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_type_1(b2FrictionJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_userData_0(b2FrictionJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_userData_1(b2FrictionJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_bodyA_0(b2FrictionJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_bodyA_1(b2FrictionJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_bodyB_0(b2FrictionJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_bodyB_1(b2FrictionJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_collideConnected_0(b2FrictionJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_collideConnected_1(b2FrictionJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef___destroy___0(b2FrictionJointDef* self) {\n  delete self;\n}\n\n// b2Manifold\n\nb2Manifold* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_b2Manifold_0() {\n  return new b2Manifold();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_get_localNormal_0(b2Manifold* self) {\n  return &self->localNormal;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_set_localNormal_1(b2Manifold* self, b2Vec2* arg0) {\n  self->localNormal = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_get_localPoint_0(b2Manifold* self) {\n  return &self->localPoint;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_set_localPoint_1(b2Manifold* self, b2Vec2* arg0) {\n  self->localPoint = *arg0;\n}\n\nb2ManifoldType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_get_type_0(b2Manifold* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_set_type_1(b2Manifold* self, b2ManifoldType arg0) {\n  self->type = arg0;\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_get_pointCount_0(b2Manifold* self) {\n  return self->pointCount;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_set_pointCount_1(b2Manifold* self, int arg0) {\n  self->pointCount = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold___destroy___0(b2Manifold* self) {\n  delete self;\n}\n\n// b2PrismaticJointDef\n\nb2PrismaticJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_b2PrismaticJointDef_0() {\n  return new b2PrismaticJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_Initialize_4(b2PrismaticJointDef* self, b2Body* arg0, b2Body* arg1, b2Vec2* arg2, b2Vec2* arg3) {\n  self->Initialize(arg0, arg1, *arg2, *arg3);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_localAnchorA_0(b2PrismaticJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_localAnchorA_1(b2PrismaticJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_localAnchorB_0(b2PrismaticJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_localAnchorB_1(b2PrismaticJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_localAxisA_0(b2PrismaticJointDef* self) {\n  return &self->localAxisA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_localAxisA_1(b2PrismaticJointDef* self, b2Vec2* arg0) {\n  self->localAxisA = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_referenceAngle_0(b2PrismaticJointDef* self) {\n  return self->referenceAngle;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_referenceAngle_1(b2PrismaticJointDef* self, float arg0) {\n  self->referenceAngle = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_enableLimit_0(b2PrismaticJointDef* self) {\n  return self->enableLimit;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_enableLimit_1(b2PrismaticJointDef* self, bool arg0) {\n  self->enableLimit = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_lowerTranslation_0(b2PrismaticJointDef* self) {\n  return self->lowerTranslation;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_lowerTranslation_1(b2PrismaticJointDef* self, float arg0) {\n  self->lowerTranslation = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_upperTranslation_0(b2PrismaticJointDef* self) {\n  return self->upperTranslation;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_upperTranslation_1(b2PrismaticJointDef* self, float arg0) {\n  self->upperTranslation = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_enableMotor_0(b2PrismaticJointDef* self) {\n  return self->enableMotor;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_enableMotor_1(b2PrismaticJointDef* self, bool arg0) {\n  self->enableMotor = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_maxMotorForce_0(b2PrismaticJointDef* self) {\n  return self->maxMotorForce;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_maxMotorForce_1(b2PrismaticJointDef* self, float arg0) {\n  self->maxMotorForce = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_motorSpeed_0(b2PrismaticJointDef* self) {\n  return self->motorSpeed;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_motorSpeed_1(b2PrismaticJointDef* self, float arg0) {\n  self->motorSpeed = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_type_0(b2PrismaticJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_type_1(b2PrismaticJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_userData_0(b2PrismaticJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_userData_1(b2PrismaticJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_bodyA_0(b2PrismaticJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_bodyA_1(b2PrismaticJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_bodyB_0(b2PrismaticJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_bodyB_1(b2PrismaticJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_collideConnected_0(b2PrismaticJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_collideConnected_1(b2PrismaticJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef___destroy___0(b2PrismaticJointDef* self) {\n  delete self;\n}\n\n// b2World\n\nb2World* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_b2World_1(b2Vec2* arg0) {\n  return new b2World(*arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetDestructionListener_1(b2World* self, b2DestructionListener* arg0) {\n  self->SetDestructionListener(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetContactFilter_1(b2World* self, JSContactFilter* arg0) {\n  self->SetContactFilter(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetContactListener_1(b2World* self, JSContactListener* arg0) {\n  self->SetContactListener(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetDebugDraw_1(b2World* self, b2Draw* arg0) {\n  self->SetDebugDraw(arg0);\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_CreateBody_1(b2World* self, b2BodyDef* arg0) {\n  return self->CreateBody(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_DestroyBody_1(b2World* self, b2Body* arg0) {\n  self->DestroyBody(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_CreateJoint_1(b2World* self, b2JointDef* arg0) {\n  return self->CreateJoint(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_DestroyJoint_1(b2World* self, b2Joint* arg0) {\n  self->DestroyJoint(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_Step_3(b2World* self, float arg0, int arg1, int arg2) {\n  self->Step(arg0, arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_ClearForces_0(b2World* self) {\n  self->ClearForces();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_DrawDebugData_0(b2World* self) {\n  self->DrawDebugData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_QueryAABB_2(b2World* self, b2QueryCallback* arg0, b2AABB* arg1) {\n  self->QueryAABB(arg0, *arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_RayCast_3(b2World* self, b2RayCastCallback* arg0, b2Vec2* arg1, b2Vec2* arg2) {\n  self->RayCast(arg0, *arg1, *arg2);\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetBodyList_0(b2World* self) {\n  return self->GetBodyList();\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetJointList_0(b2World* self) {\n  return self->GetJointList();\n}\n\nb2Contact* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetContactList_0(b2World* self) {\n  return self->GetContactList();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetAllowSleeping_1(b2World* self, bool arg0) {\n  self->SetAllowSleeping(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetAllowSleeping_0(b2World* self) {\n  return self->GetAllowSleeping();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetWarmStarting_1(b2World* self, bool arg0) {\n  self->SetWarmStarting(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetWarmStarting_0(b2World* self) {\n  return self->GetWarmStarting();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetContinuousPhysics_1(b2World* self, bool arg0) {\n  self->SetContinuousPhysics(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetContinuousPhysics_0(b2World* self) {\n  return self->GetContinuousPhysics();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetSubStepping_1(b2World* self, bool arg0) {\n  self->SetSubStepping(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetSubStepping_0(b2World* self) {\n  return self->GetSubStepping();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetProxyCount_0(b2World* self) {\n  return self->GetProxyCount();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetBodyCount_0(b2World* self) {\n  return self->GetBodyCount();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetJointCount_0(b2World* self) {\n  return self->GetJointCount();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetContactCount_0(b2World* self) {\n  return self->GetContactCount();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetTreeHeight_0(b2World* self) {\n  return self->GetTreeHeight();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetTreeBalance_0(b2World* self) {\n  return self->GetTreeBalance();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetTreeQuality_0(b2World* self) {\n  return self->GetTreeQuality();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetGravity_1(b2World* self, b2Vec2* arg0) {\n  self->SetGravity(*arg0);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetGravity_0(b2World* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetGravity(), &temp);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_IsLocked_0(b2World* self) {\n  return self->IsLocked();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetAutoClearForces_1(b2World* self, bool arg0) {\n  self->SetAutoClearForces(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetAutoClearForces_0(b2World* self) {\n  return self->GetAutoClearForces();\n}\n\nconst b2Profile* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetProfile_0(b2World* self) {\n  return &self->GetProfile();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_Dump_0(b2World* self) {\n  self->Dump();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World___destroy___0(b2World* self) {\n  delete self;\n}\n\n// b2PrismaticJoint\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetLocalAnchorA_0(b2PrismaticJoint* self) {\n  return &self->GetLocalAnchorA();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetLocalAnchorB_0(b2PrismaticJoint* self) {\n  return &self->GetLocalAnchorB();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetLocalAxisA_0(b2PrismaticJoint* self) {\n  return &self->GetLocalAxisA();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetReferenceAngle_0(b2PrismaticJoint* self) {\n  return self->GetReferenceAngle();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetJointTranslation_0(b2PrismaticJoint* self) {\n  return self->GetJointTranslation();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetJointSpeed_0(b2PrismaticJoint* self) {\n  return self->GetJointSpeed();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_IsLimitEnabled_0(b2PrismaticJoint* self) {\n  return self->IsLimitEnabled();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_EnableLimit_1(b2PrismaticJoint* self, bool arg0) {\n  self->EnableLimit(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetLowerLimit_0(b2PrismaticJoint* self) {\n  return self->GetLowerLimit();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetUpperLimit_0(b2PrismaticJoint* self) {\n  return self->GetUpperLimit();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_SetLimits_2(b2PrismaticJoint* self, float arg0, float arg1) {\n  self->SetLimits(arg0, arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_IsMotorEnabled_0(b2PrismaticJoint* self) {\n  return self->IsMotorEnabled();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_EnableMotor_1(b2PrismaticJoint* self, bool arg0) {\n  self->EnableMotor(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_SetMotorSpeed_1(b2PrismaticJoint* self, float arg0) {\n  self->SetMotorSpeed(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetMotorSpeed_0(b2PrismaticJoint* self) {\n  return self->GetMotorSpeed();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_SetMaxMotorForce_1(b2PrismaticJoint* self, float arg0) {\n  self->SetMaxMotorForce(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetMaxMotorForce_0(b2PrismaticJoint* self) {\n  return self->GetMaxMotorForce();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetMotorForce_1(b2PrismaticJoint* self, float arg0) {\n  return self->GetMotorForce(arg0);\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetType_0(b2PrismaticJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetBodyA_0(b2PrismaticJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetBodyB_0(b2PrismaticJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetAnchorA_0(b2PrismaticJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetAnchorB_0(b2PrismaticJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetReactionForce_1(b2PrismaticJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetReactionTorque_1(b2PrismaticJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetNext_0(b2PrismaticJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetUserData_0(b2PrismaticJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_SetUserData_1(b2PrismaticJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_IsActive_0(b2PrismaticJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetCollideConnected_0(b2PrismaticJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint___destroy___0(b2PrismaticJoint* self) {\n  delete self;\n}\n\n// b2RayCastOutput\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastOutput_get_normal_0(b2RayCastOutput* self) {\n  return &self->normal;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastOutput_set_normal_1(b2RayCastOutput* self, b2Vec2* arg0) {\n  self->normal = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastOutput_get_fraction_0(b2RayCastOutput* self) {\n  return self->fraction;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastOutput_set_fraction_1(b2RayCastOutput* self, float arg0) {\n  self->fraction = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastOutput___destroy___0(b2RayCastOutput* self) {\n  delete self;\n}\n\n// b2ContactID\n\nb2ContactFeature* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactID_get_cf_0(b2ContactID* self) {\n  return &self->cf;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactID_set_cf_1(b2ContactID* self, b2ContactFeature* arg0) {\n  self->cf = *arg0;\n}\n\nunsigned int EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactID_get_key_0(b2ContactID* self) {\n  return self->key;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactID_set_key_1(b2ContactID* self, unsigned int arg0) {\n  self->key = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactID___destroy___0(b2ContactID* self) {\n  delete self;\n}\n\n// b2DestructionListenerWrapper\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DestructionListenerWrapper___destroy___0(b2DestructionListenerWrapper* self) {\n  delete self;\n}\n\n// JSContactListener\n\nJSContactListener* EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactListener_JSContactListener_0() {\n  return new JSContactListener();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactListener_BeginContact_1(JSContactListener* self, b2Contact* arg0) {\n  self->BeginContact(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactListener_EndContact_1(JSContactListener* self, b2Contact* arg0) {\n  self->EndContact(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactListener_PreSolve_2(JSContactListener* self, b2Contact* arg0, b2Manifold* arg1) {\n  self->PreSolve(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactListener_PostSolve_2(JSContactListener* self, b2Contact* arg0, b2ContactImpulse* arg1) {\n  self->PostSolve(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactListener___destroy___0(JSContactListener* self) {\n  delete self;\n}\n\n// b2Mat22\n\nb2Mat22* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_b2Mat22_0() {\n  return new b2Mat22();\n}\n\nb2Mat22* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_b2Mat22_2(b2Vec2* arg0, b2Vec2* arg1) {\n  return new b2Mat22(*arg0, *arg1);\n}\n\nb2Mat22* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_b2Mat22_4(float arg0, float arg1, float arg2, float arg3) {\n  return new b2Mat22(arg0, arg1, arg2, arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_Set_2(b2Mat22* self, b2Vec2* arg0, b2Vec2* arg1) {\n  self->Set(*arg0, *arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_SetIdentity_0(b2Mat22* self) {\n  self->SetIdentity();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_SetZero_0(b2Mat22* self) {\n  self->SetZero();\n}\n\nb2Mat22* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_GetInverse_0(b2Mat22* self) {\n  static b2Mat22 temp;\n  return (temp = self->GetInverse(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_Solve_1(b2Mat22* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->Solve(*arg0), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_get_ex_0(b2Mat22* self) {\n  return &self->ex;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_set_ex_1(b2Mat22* self, b2Vec2* arg0) {\n  self->ex = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_get_ey_0(b2Mat22* self) {\n  return &self->ey;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_set_ey_1(b2Mat22* self, b2Vec2* arg0) {\n  self->ey = *arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22___destroy___0(b2Mat22* self) {\n  delete self;\n}\n\n// b2WheelJointDef\n\nb2WheelJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_b2WheelJointDef_0() {\n  return new b2WheelJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_Initialize_4(b2WheelJointDef* self, b2Body* arg0, b2Body* arg1, b2Vec2* arg2, b2Vec2* arg3) {\n  self->Initialize(arg0, arg1, *arg2, *arg3);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_localAnchorA_0(b2WheelJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_localAnchorA_1(b2WheelJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_localAnchorB_0(b2WheelJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_localAnchorB_1(b2WheelJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_localAxisA_0(b2WheelJointDef* self) {\n  return &self->localAxisA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_localAxisA_1(b2WheelJointDef* self, b2Vec2* arg0) {\n  self->localAxisA = *arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_enableMotor_0(b2WheelJointDef* self) {\n  return self->enableMotor;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_enableMotor_1(b2WheelJointDef* self, bool arg0) {\n  self->enableMotor = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_maxMotorTorque_0(b2WheelJointDef* self) {\n  return self->maxMotorTorque;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_maxMotorTorque_1(b2WheelJointDef* self, float arg0) {\n  self->maxMotorTorque = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_motorSpeed_0(b2WheelJointDef* self) {\n  return self->motorSpeed;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_motorSpeed_1(b2WheelJointDef* self, float arg0) {\n  self->motorSpeed = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_frequencyHz_0(b2WheelJointDef* self) {\n  return self->frequencyHz;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_frequencyHz_1(b2WheelJointDef* self, float arg0) {\n  self->frequencyHz = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_dampingRatio_0(b2WheelJointDef* self) {\n  return self->dampingRatio;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_dampingRatio_1(b2WheelJointDef* self, float arg0) {\n  self->dampingRatio = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_type_0(b2WheelJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_type_1(b2WheelJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_userData_0(b2WheelJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_userData_1(b2WheelJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_bodyA_0(b2WheelJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_bodyA_1(b2WheelJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_bodyB_0(b2WheelJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_bodyB_1(b2WheelJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_collideConnected_0(b2WheelJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_collideConnected_1(b2WheelJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef___destroy___0(b2WheelJointDef* self) {\n  delete self;\n}\n\n// b2CircleShape\n\nb2CircleShape* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_b2CircleShape_0() {\n  return new b2CircleShape();\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_GetType_0(b2CircleShape* self) {\n  return self->GetType();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_GetChildCount_0(b2CircleShape* self) {\n  return self->GetChildCount();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_TestPoint_2(b2CircleShape* self, b2Transform* arg0, b2Vec2* arg1) {\n  return self->TestPoint(*arg0, *arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_RayCast_4(b2CircleShape* self, b2RayCastOutput* arg0, b2RayCastInput* arg1, b2Transform* arg2, int arg3) {\n  return self->RayCast(arg0, *arg1, *arg2, arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_ComputeAABB_3(b2CircleShape* self, b2AABB* arg0, b2Transform* arg1, int arg2) {\n  self->ComputeAABB(arg0, *arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_ComputeMass_2(b2CircleShape* self, b2MassData* arg0, float arg1) {\n  self->ComputeMass(arg0, arg1);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_get_m_p_0(b2CircleShape* self) {\n  return &self->m_p;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_set_m_p_1(b2CircleShape* self, b2Vec2* arg0) {\n  self->m_p = *arg0;\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_get_m_type_0(b2CircleShape* self) {\n  return self->m_type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_set_m_type_1(b2CircleShape* self, b2ShapeType arg0) {\n  self->m_type = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_get_m_radius_0(b2CircleShape* self) {\n  return self->m_radius;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_set_m_radius_1(b2CircleShape* self, float arg0) {\n  self->m_radius = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape___destroy___0(b2CircleShape* self) {\n  delete self;\n}\n\n// b2WeldJointDef\n\nb2WeldJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_b2WeldJointDef_0() {\n  return new b2WeldJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_Initialize_3(b2WeldJointDef* self, b2Body* arg0, b2Body* arg1, b2Vec2* arg2) {\n  self->Initialize(arg0, arg1, *arg2);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_localAnchorA_0(b2WeldJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_localAnchorA_1(b2WeldJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_localAnchorB_0(b2WeldJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_localAnchorB_1(b2WeldJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_referenceAngle_0(b2WeldJointDef* self) {\n  return self->referenceAngle;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_referenceAngle_1(b2WeldJointDef* self, float arg0) {\n  self->referenceAngle = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_frequencyHz_0(b2WeldJointDef* self) {\n  return self->frequencyHz;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_frequencyHz_1(b2WeldJointDef* self, float arg0) {\n  self->frequencyHz = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_dampingRatio_0(b2WeldJointDef* self) {\n  return self->dampingRatio;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_dampingRatio_1(b2WeldJointDef* self, float arg0) {\n  self->dampingRatio = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_type_0(b2WeldJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_type_1(b2WeldJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_userData_0(b2WeldJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_userData_1(b2WeldJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_bodyA_0(b2WeldJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_bodyA_1(b2WeldJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_bodyB_0(b2WeldJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_bodyB_1(b2WeldJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_collideConnected_0(b2WeldJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_collideConnected_1(b2WeldJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef___destroy___0(b2WeldJointDef* self) {\n  delete self;\n}\n\n// b2Draw\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Draw_SetFlags_1(b2Draw* self, unsigned int arg0) {\n  self->SetFlags(arg0);\n}\n\nunsigned int EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Draw_GetFlags_0(b2Draw* self) {\n  return self->GetFlags();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Draw_AppendFlags_1(b2Draw* self, unsigned int arg0) {\n  self->AppendFlags(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Draw_ClearFlags_1(b2Draw* self, unsigned int arg0) {\n  self->ClearFlags(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Draw___destroy___0(b2Draw* self) {\n  delete self;\n}\n\n// b2MassData\n\nb2MassData* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData_b2MassData_0() {\n  return new b2MassData();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData_get_mass_0(b2MassData* self) {\n  return self->mass;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData_set_mass_1(b2MassData* self, float arg0) {\n  self->mass = arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData_get_center_0(b2MassData* self) {\n  return &self->center;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData_set_center_1(b2MassData* self, b2Vec2* arg0) {\n  self->center = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData_get_I_0(b2MassData* self) {\n  return self->I;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData_set_I_1(b2MassData* self, float arg0) {\n  self->I = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData___destroy___0(b2MassData* self) {\n  delete self;\n}\n\n// b2Joint\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetType_0(b2Joint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetBodyA_0(b2Joint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetBodyB_0(b2Joint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetAnchorA_0(b2Joint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetAnchorB_0(b2Joint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetReactionForce_1(b2Joint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetReactionTorque_1(b2Joint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetNext_0(b2Joint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetUserData_0(b2Joint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_SetUserData_1(b2Joint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_IsActive_0(b2Joint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetCollideConnected_0(b2Joint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_Dump_0(b2Joint* self) {\n  self->Dump();\n}\n\n// b2GearJoint\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetJoint1_0(b2GearJoint* self) {\n  return self->GetJoint1();\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetJoint2_0(b2GearJoint* self) {\n  return self->GetJoint2();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_SetRatio_1(b2GearJoint* self, float arg0) {\n  self->SetRatio(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetRatio_0(b2GearJoint* self) {\n  return self->GetRatio();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetType_0(b2GearJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetBodyA_0(b2GearJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetBodyB_0(b2GearJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetAnchorA_0(b2GearJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetAnchorB_0(b2GearJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetReactionForce_1(b2GearJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetReactionTorque_1(b2GearJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetNext_0(b2GearJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetUserData_0(b2GearJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_SetUserData_1(b2GearJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_IsActive_0(b2GearJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetCollideConnected_0(b2GearJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint___destroy___0(b2GearJoint* self) {\n  delete self;\n}\n\n// b2RayCastCallback\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastCallback___destroy___0(b2RayCastCallback* self) {\n  delete self;\n}\n\n// b2WeldJoint\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetLocalAnchorA_0(b2WeldJoint* self) {\n  return &self->GetLocalAnchorA();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetLocalAnchorB_0(b2WeldJoint* self) {\n  return &self->GetLocalAnchorB();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_SetFrequency_1(b2WeldJoint* self, float arg0) {\n  self->SetFrequency(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetFrequency_0(b2WeldJoint* self) {\n  return self->GetFrequency();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_SetDampingRatio_1(b2WeldJoint* self, float arg0) {\n  self->SetDampingRatio(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetDampingRatio_0(b2WeldJoint* self) {\n  return self->GetDampingRatio();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_Dump_0(b2WeldJoint* self) {\n  self->Dump();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetType_0(b2WeldJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetBodyA_0(b2WeldJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetBodyB_0(b2WeldJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetAnchorA_0(b2WeldJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetAnchorB_0(b2WeldJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetReactionForce_1(b2WeldJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetReactionTorque_1(b2WeldJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetNext_0(b2WeldJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetUserData_0(b2WeldJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_SetUserData_1(b2WeldJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_IsActive_0(b2WeldJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetCollideConnected_0(b2WeldJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint___destroy___0(b2WeldJoint* self) {\n  delete self;\n}\n\n// b2JointEdge\n\nb2JointEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_b2JointEdge_0() {\n  return new b2JointEdge();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_get_other_0(b2JointEdge* self) {\n  return self->other;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_set_other_1(b2JointEdge* self, b2Body* arg0) {\n  self->other = arg0;\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_get_joint_0(b2JointEdge* self) {\n  return self->joint;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_set_joint_1(b2JointEdge* self, b2Joint* arg0) {\n  self->joint = arg0;\n}\n\nb2JointEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_get_prev_0(b2JointEdge* self) {\n  return self->prev;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_set_prev_1(b2JointEdge* self, b2JointEdge* arg0) {\n  self->prev = arg0;\n}\n\nb2JointEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_get_next_0(b2JointEdge* self) {\n  return self->next;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_set_next_1(b2JointEdge* self, b2JointEdge* arg0) {\n  self->next = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge___destroy___0(b2JointEdge* self) {\n  delete self;\n}\n\n// b2PulleyJointDef\n\nb2PulleyJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_b2PulleyJointDef_0() {\n  return new b2PulleyJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_Initialize_7(b2PulleyJointDef* self, b2Body* arg0, b2Body* arg1, b2Vec2* arg2, b2Vec2* arg3, b2Vec2* arg4, b2Vec2* arg5, float arg6) {\n  self->Initialize(arg0, arg1, *arg2, *arg3, *arg4, *arg5, arg6);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_groundAnchorA_0(b2PulleyJointDef* self) {\n  return &self->groundAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_groundAnchorA_1(b2PulleyJointDef* self, b2Vec2* arg0) {\n  self->groundAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_groundAnchorB_0(b2PulleyJointDef* self) {\n  return &self->groundAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_groundAnchorB_1(b2PulleyJointDef* self, b2Vec2* arg0) {\n  self->groundAnchorB = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_localAnchorA_0(b2PulleyJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_localAnchorA_1(b2PulleyJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_localAnchorB_0(b2PulleyJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_localAnchorB_1(b2PulleyJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_lengthA_0(b2PulleyJointDef* self) {\n  return self->lengthA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_lengthA_1(b2PulleyJointDef* self, float arg0) {\n  self->lengthA = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_lengthB_0(b2PulleyJointDef* self) {\n  return self->lengthB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_lengthB_1(b2PulleyJointDef* self, float arg0) {\n  self->lengthB = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_ratio_0(b2PulleyJointDef* self) {\n  return self->ratio;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_ratio_1(b2PulleyJointDef* self, float arg0) {\n  self->ratio = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_type_0(b2PulleyJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_type_1(b2PulleyJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_userData_0(b2PulleyJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_userData_1(b2PulleyJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_bodyA_0(b2PulleyJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_bodyA_1(b2PulleyJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_bodyB_0(b2PulleyJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_bodyB_1(b2PulleyJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_collideConnected_0(b2PulleyJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_collideConnected_1(b2PulleyJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef___destroy___0(b2PulleyJointDef* self) {\n  delete self;\n}\n\n// b2ContactListener\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactListener___destroy___0(b2ContactListener* self) {\n  delete self;\n}\n\n// b2ManifoldPoint\n\nb2ManifoldPoint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_b2ManifoldPoint_0() {\n  return new b2ManifoldPoint();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_get_localPoint_0(b2ManifoldPoint* self) {\n  return &self->localPoint;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_set_localPoint_1(b2ManifoldPoint* self, b2Vec2* arg0) {\n  self->localPoint = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_get_normalImpulse_0(b2ManifoldPoint* self) {\n  return self->normalImpulse;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_set_normalImpulse_1(b2ManifoldPoint* self, float arg0) {\n  self->normalImpulse = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_get_tangentImpulse_0(b2ManifoldPoint* self) {\n  return self->tangentImpulse;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_set_tangentImpulse_1(b2ManifoldPoint* self, float arg0) {\n  self->tangentImpulse = arg0;\n}\n\nb2ContactID* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_get_id_0(b2ManifoldPoint* self) {\n  return &self->id;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_set_id_1(b2ManifoldPoint* self, b2ContactID* arg0) {\n  self->id = *arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint___destroy___0(b2ManifoldPoint* self) {\n  delete self;\n}\n\n// b2QueryCallback\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2QueryCallback___destroy___0(b2QueryCallback* self) {\n  delete self;\n}\n\n// b2JointDef\n\nb2JointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_b2JointDef_0() {\n  return new b2JointDef();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_get_type_0(b2JointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_set_type_1(b2JointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_get_userData_0(b2JointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_set_userData_1(b2JointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_get_bodyA_0(b2JointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_set_bodyA_1(b2JointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_get_bodyB_0(b2JointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_set_bodyB_1(b2JointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_get_collideConnected_0(b2JointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_set_collideConnected_1(b2JointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef___destroy___0(b2JointDef* self) {\n  delete self;\n}\n\n// b2Transform\n\nb2Transform* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_b2Transform_0() {\n  return new b2Transform();\n}\n\nb2Transform* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_b2Transform_2(b2Vec2* arg0, b2Rot* arg1) {\n  return new b2Transform(*arg0, *arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_SetIdentity_0(b2Transform* self) {\n  self->SetIdentity();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_Set_2(b2Transform* self, b2Vec2* arg0, float arg1) {\n  self->Set(*arg0, arg1);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_get_p_0(b2Transform* self) {\n  return &self->p;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_set_p_1(b2Transform* self, b2Vec2* arg0) {\n  self->p = *arg0;\n}\n\nb2Rot* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_get_q_0(b2Transform* self) {\n  return &self->q;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_set_q_1(b2Transform* self, b2Rot* arg0) {\n  self->q = *arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform___destroy___0(b2Transform* self) {\n  delete self;\n}\n\n// b2ChainShape\n\nb2ChainShape* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_b2ChainShape_0() {\n  return new b2ChainShape();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_CreateLoop_2(b2ChainShape* self, b2Vec2* arg0, int arg1) {\n  self->CreateLoop(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_CreateChain_2(b2ChainShape* self, b2Vec2* arg0, int arg1) {\n  self->CreateChain(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_SetPrevVertex_1(b2ChainShape* self, b2Vec2* arg0) {\n  self->SetPrevVertex(*arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_SetNextVertex_1(b2ChainShape* self, b2Vec2* arg0) {\n  self->SetNextVertex(*arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_GetChildEdge_2(b2ChainShape* self, b2EdgeShape* arg0, int arg1) {\n  self->GetChildEdge(arg0, arg1);\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_GetType_0(b2ChainShape* self) {\n  return self->GetType();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_GetChildCount_0(b2ChainShape* self) {\n  return self->GetChildCount();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_TestPoint_2(b2ChainShape* self, b2Transform* arg0, b2Vec2* arg1) {\n  return self->TestPoint(*arg0, *arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_RayCast_4(b2ChainShape* self, b2RayCastOutput* arg0, b2RayCastInput* arg1, b2Transform* arg2, int arg3) {\n  return self->RayCast(arg0, *arg1, *arg2, arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_ComputeAABB_3(b2ChainShape* self, b2AABB* arg0, b2Transform* arg1, int arg2) {\n  self->ComputeAABB(arg0, *arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_ComputeMass_2(b2ChainShape* self, b2MassData* arg0, float arg1) {\n  self->ComputeMass(arg0, arg1);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_vertices_0(b2ChainShape* self) {\n  return self->m_vertices;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_vertices_1(b2ChainShape* self, b2Vec2* arg0) {\n  self->m_vertices = arg0;\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_count_0(b2ChainShape* self) {\n  return self->m_count;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_count_1(b2ChainShape* self, int arg0) {\n  self->m_count = arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_prevVertex_0(b2ChainShape* self) {\n  return &self->m_prevVertex;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_prevVertex_1(b2ChainShape* self, b2Vec2* arg0) {\n  self->m_prevVertex = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_nextVertex_0(b2ChainShape* self) {\n  return &self->m_nextVertex;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_nextVertex_1(b2ChainShape* self, b2Vec2* arg0) {\n  self->m_nextVertex = *arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_hasPrevVertex_0(b2ChainShape* self) {\n  return self->m_hasPrevVertex;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_hasPrevVertex_1(b2ChainShape* self, bool arg0) {\n  self->m_hasPrevVertex = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_hasNextVertex_0(b2ChainShape* self) {\n  return self->m_hasNextVertex;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_hasNextVertex_1(b2ChainShape* self, bool arg0) {\n  self->m_hasNextVertex = arg0;\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_type_0(b2ChainShape* self) {\n  return self->m_type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_type_1(b2ChainShape* self, b2ShapeType arg0) {\n  self->m_type = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_radius_0(b2ChainShape* self) {\n  return self->m_radius;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_radius_1(b2ChainShape* self, float arg0) {\n  self->m_radius = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape___destroy___0(b2ChainShape* self) {\n  delete self;\n}\n\n// b2Color\n\nb2Color* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_b2Color_0() {\n  return new b2Color();\n}\n\nb2Color* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_b2Color_3(float arg0, float arg1, float arg2) {\n  return new b2Color(arg0, arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_Set_3(b2Color* self, float arg0, float arg1, float arg2) {\n  self->Set(arg0, arg1, arg2);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_get_r_0(b2Color* self) {\n  return self->r;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_set_r_1(b2Color* self, float arg0) {\n  self->r = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_get_g_0(b2Color* self) {\n  return self->g;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_set_g_1(b2Color* self, float arg0) {\n  self->g = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_get_b_0(b2Color* self) {\n  return self->b;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_set_b_1(b2Color* self, float arg0) {\n  self->b = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color___destroy___0(b2Color* self) {\n  delete self;\n}\n\n// b2RopeJoint\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetLocalAnchorA_0(b2RopeJoint* self) {\n  return &self->GetLocalAnchorA();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetLocalAnchorB_0(b2RopeJoint* self) {\n  return &self->GetLocalAnchorB();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_SetMaxLength_1(b2RopeJoint* self, float arg0) {\n  self->SetMaxLength(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetMaxLength_0(b2RopeJoint* self) {\n  return self->GetMaxLength();\n}\n\nb2LimitState EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetLimitState_0(b2RopeJoint* self) {\n  return self->GetLimitState();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetType_0(b2RopeJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetBodyA_0(b2RopeJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetBodyB_0(b2RopeJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetAnchorA_0(b2RopeJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetAnchorB_0(b2RopeJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetReactionForce_1(b2RopeJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetReactionTorque_1(b2RopeJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetNext_0(b2RopeJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetUserData_0(b2RopeJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_SetUserData_1(b2RopeJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_IsActive_0(b2RopeJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetCollideConnected_0(b2RopeJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint___destroy___0(b2RopeJoint* self) {\n  delete self;\n}\n\n// b2RayCastInput\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastInput_get_p1_0(b2RayCastInput* self) {\n  return &self->p1;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastInput_set_p1_1(b2RayCastInput* self, b2Vec2* arg0) {\n  self->p1 = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastInput_get_p2_0(b2RayCastInput* self) {\n  return &self->p2;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastInput_set_p2_1(b2RayCastInput* self, b2Vec2* arg0) {\n  self->p2 = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastInput_get_maxFraction_0(b2RayCastInput* self) {\n  return self->maxFraction;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastInput_set_maxFraction_1(b2RayCastInput* self, float arg0) {\n  self->maxFraction = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastInput___destroy___0(b2RayCastInput* self) {\n  delete self;\n}\n\n// b2PolygonShape\n\nb2PolygonShape* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_b2PolygonShape_0() {\n  return new b2PolygonShape();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_Set_2(b2PolygonShape* self, b2Vec2* arg0, int arg1) {\n  self->Set(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_SetAsBox_2(b2PolygonShape* self, float arg0, float arg1) {\n  self->SetAsBox(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_SetAsBox_4(b2PolygonShape* self, float arg0, float arg1, b2Vec2* arg2, float arg3) {\n  self->SetAsBox(arg0, arg1, *arg2, arg3);\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_GetVertexCount_0(b2PolygonShape* self) {\n  return self->GetVertexCount();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_GetVertex_1(b2PolygonShape* self, int arg0) {\n  return &self->GetVertex(arg0);\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_GetType_0(b2PolygonShape* self) {\n  return self->GetType();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_GetChildCount_0(b2PolygonShape* self) {\n  return self->GetChildCount();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_TestPoint_2(b2PolygonShape* self, b2Transform* arg0, b2Vec2* arg1) {\n  return self->TestPoint(*arg0, *arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_RayCast_4(b2PolygonShape* self, b2RayCastOutput* arg0, b2RayCastInput* arg1, b2Transform* arg2, int arg3) {\n  return self->RayCast(arg0, *arg1, *arg2, arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_ComputeAABB_3(b2PolygonShape* self, b2AABB* arg0, b2Transform* arg1, int arg2) {\n  self->ComputeAABB(arg0, *arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_ComputeMass_2(b2PolygonShape* self, b2MassData* arg0, float arg1) {\n  self->ComputeMass(arg0, arg1);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_get_m_centroid_0(b2PolygonShape* self) {\n  return &self->m_centroid;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_set_m_centroid_1(b2PolygonShape* self, b2Vec2* arg0) {\n  self->m_centroid = *arg0;\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_get_m_vertexCount_0(b2PolygonShape* self) {\n  return self->m_vertexCount;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_set_m_vertexCount_1(b2PolygonShape* self, int arg0) {\n  self->m_vertexCount = arg0;\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_get_m_type_0(b2PolygonShape* self) {\n  return self->m_type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_set_m_type_1(b2PolygonShape* self, b2ShapeType arg0) {\n  self->m_type = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_get_m_radius_0(b2PolygonShape* self) {\n  return self->m_radius;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_set_m_radius_1(b2PolygonShape* self, float arg0) {\n  self->m_radius = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape___destroy___0(b2PolygonShape* self) {\n  delete self;\n}\n\n// b2EdgeShape\n\nb2EdgeShape* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_b2EdgeShape_0() {\n  return new b2EdgeShape();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_Set_2(b2EdgeShape* self, b2Vec2* arg0, b2Vec2* arg1) {\n  self->Set(*arg0, *arg1);\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_GetType_0(b2EdgeShape* self) {\n  return self->GetType();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_GetChildCount_0(b2EdgeShape* self) {\n  return self->GetChildCount();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_TestPoint_2(b2EdgeShape* self, b2Transform* arg0, b2Vec2* arg1) {\n  return self->TestPoint(*arg0, *arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_RayCast_4(b2EdgeShape* self, b2RayCastOutput* arg0, b2RayCastInput* arg1, b2Transform* arg2, int arg3) {\n  return self->RayCast(arg0, *arg1, *arg2, arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_ComputeAABB_3(b2EdgeShape* self, b2AABB* arg0, b2Transform* arg1, int arg2) {\n  self->ComputeAABB(arg0, *arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_ComputeMass_2(b2EdgeShape* self, b2MassData* arg0, float arg1) {\n  self->ComputeMass(arg0, arg1);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_vertex1_0(b2EdgeShape* self) {\n  return &self->m_vertex1;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_vertex1_1(b2EdgeShape* self, b2Vec2* arg0) {\n  self->m_vertex1 = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_vertex2_0(b2EdgeShape* self) {\n  return &self->m_vertex2;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_vertex2_1(b2EdgeShape* self, b2Vec2* arg0) {\n  self->m_vertex2 = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_vertex0_0(b2EdgeShape* self) {\n  return &self->m_vertex0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_vertex0_1(b2EdgeShape* self, b2Vec2* arg0) {\n  self->m_vertex0 = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_vertex3_0(b2EdgeShape* self) {\n  return &self->m_vertex3;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_vertex3_1(b2EdgeShape* self, b2Vec2* arg0) {\n  self->m_vertex3 = *arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_hasVertex0_0(b2EdgeShape* self) {\n  return self->m_hasVertex0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_hasVertex0_1(b2EdgeShape* self, bool arg0) {\n  self->m_hasVertex0 = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_hasVertex3_0(b2EdgeShape* self) {\n  return self->m_hasVertex3;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_hasVertex3_1(b2EdgeShape* self, bool arg0) {\n  self->m_hasVertex3 = arg0;\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_type_0(b2EdgeShape* self) {\n  return self->m_type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_type_1(b2EdgeShape* self, b2ShapeType arg0) {\n  self->m_type = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_radius_0(b2EdgeShape* self) {\n  return self->m_radius;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_radius_1(b2EdgeShape* self, float arg0) {\n  self->m_radius = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape___destroy___0(b2EdgeShape* self) {\n  delete self;\n}\n\n// JSContactFilter\n\nJSContactFilter* EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactFilter_JSContactFilter_0() {\n  return new JSContactFilter();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactFilter_ShouldCollide_2(JSContactFilter* self, b2Fixture* arg0, b2Fixture* arg1) {\n  return self->ShouldCollide(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactFilter___destroy___0(JSContactFilter* self) {\n  delete self;\n}\n\n// b2RevoluteJointDef\n\nb2RevoluteJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_b2RevoluteJointDef_0() {\n  return new b2RevoluteJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_Initialize_3(b2RevoluteJointDef* self, b2Body* arg0, b2Body* arg1, b2Vec2* arg2) {\n  self->Initialize(arg0, arg1, *arg2);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_localAnchorA_0(b2RevoluteJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_localAnchorA_1(b2RevoluteJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_localAnchorB_0(b2RevoluteJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_localAnchorB_1(b2RevoluteJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_referenceAngle_0(b2RevoluteJointDef* self) {\n  return self->referenceAngle;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_referenceAngle_1(b2RevoluteJointDef* self, float arg0) {\n  self->referenceAngle = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_enableLimit_0(b2RevoluteJointDef* self) {\n  return self->enableLimit;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_enableLimit_1(b2RevoluteJointDef* self, bool arg0) {\n  self->enableLimit = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_lowerAngle_0(b2RevoluteJointDef* self) {\n  return self->lowerAngle;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_lowerAngle_1(b2RevoluteJointDef* self, float arg0) {\n  self->lowerAngle = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_upperAngle_0(b2RevoluteJointDef* self) {\n  return self->upperAngle;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_upperAngle_1(b2RevoluteJointDef* self, float arg0) {\n  self->upperAngle = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_enableMotor_0(b2RevoluteJointDef* self) {\n  return self->enableMotor;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_enableMotor_1(b2RevoluteJointDef* self, bool arg0) {\n  self->enableMotor = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_motorSpeed_0(b2RevoluteJointDef* self) {\n  return self->motorSpeed;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_motorSpeed_1(b2RevoluteJointDef* self, float arg0) {\n  self->motorSpeed = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_maxMotorTorque_0(b2RevoluteJointDef* self) {\n  return self->maxMotorTorque;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_maxMotorTorque_1(b2RevoluteJointDef* self, float arg0) {\n  self->maxMotorTorque = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_type_0(b2RevoluteJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_type_1(b2RevoluteJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_userData_0(b2RevoluteJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_userData_1(b2RevoluteJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_bodyA_0(b2RevoluteJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_bodyA_1(b2RevoluteJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_bodyB_0(b2RevoluteJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_bodyB_1(b2RevoluteJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_collideConnected_0(b2RevoluteJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_collideConnected_1(b2RevoluteJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef___destroy___0(b2RevoluteJointDef* self) {\n  delete self;\n}\n\n// JSDraw\n\nJSDraw* EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw_JSDraw_0() {\n  return new JSDraw();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw_DrawPolygon_3(JSDraw* self, b2Vec2* arg0, int arg1, b2Color* arg2) {\n  self->DrawPolygon(arg0, arg1, *arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw_DrawSolidPolygon_3(JSDraw* self, b2Vec2* arg0, int arg1, b2Color* arg2) {\n  self->DrawSolidPolygon(arg0, arg1, *arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw_DrawCircle_3(JSDraw* self, b2Vec2* arg0, float arg1, b2Color* arg2) {\n  self->DrawCircle(*arg0, arg1, *arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw_DrawSolidCircle_4(JSDraw* self, b2Vec2* arg0, float arg1, b2Vec2* arg2, b2Color* arg3) {\n  self->DrawSolidCircle(*arg0, arg1, *arg2, *arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw_DrawSegment_3(JSDraw* self, b2Vec2* arg0, b2Vec2* arg1, b2Color* arg2) {\n  self->DrawSegment(*arg0, *arg1, *arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw_DrawTransform_1(JSDraw* self, b2Transform* arg0) {\n  self->DrawTransform(*arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw___destroy___0(JSDraw* self) {\n  delete self;\n}\n\n// b2WheelJoint\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetLocalAnchorA_0(b2WheelJoint* self) {\n  return &self->GetLocalAnchorA();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetLocalAnchorB_0(b2WheelJoint* self) {\n  return &self->GetLocalAnchorB();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetLocalAxisA_0(b2WheelJoint* self) {\n  return &self->GetLocalAxisA();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetJointTranslation_0(b2WheelJoint* self) {\n  return self->GetJointTranslation();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetJointSpeed_0(b2WheelJoint* self) {\n  return self->GetJointSpeed();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_IsMotorEnabled_0(b2WheelJoint* self) {\n  return self->IsMotorEnabled();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_EnableMotor_1(b2WheelJoint* self, bool arg0) {\n  self->EnableMotor(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_SetMotorSpeed_1(b2WheelJoint* self, float arg0) {\n  self->SetMotorSpeed(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetMotorSpeed_0(b2WheelJoint* self) {\n  return self->GetMotorSpeed();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_SetMaxMotorTorque_1(b2WheelJoint* self, float arg0) {\n  self->SetMaxMotorTorque(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetMaxMotorTorque_0(b2WheelJoint* self) {\n  return self->GetMaxMotorTorque();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetMotorTorque_1(b2WheelJoint* self, float arg0) {\n  return self->GetMotorTorque(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_SetSpringFrequencyHz_1(b2WheelJoint* self, float arg0) {\n  self->SetSpringFrequencyHz(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetSpringFrequencyHz_0(b2WheelJoint* self) {\n  return self->GetSpringFrequencyHz();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_SetSpringDampingRatio_1(b2WheelJoint* self, float arg0) {\n  self->SetSpringDampingRatio(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetSpringDampingRatio_0(b2WheelJoint* self) {\n  return self->GetSpringDampingRatio();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetType_0(b2WheelJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetBodyA_0(b2WheelJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetBodyB_0(b2WheelJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetAnchorA_0(b2WheelJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetAnchorB_0(b2WheelJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetReactionForce_1(b2WheelJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetReactionTorque_1(b2WheelJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetNext_0(b2WheelJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetUserData_0(b2WheelJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_SetUserData_1(b2WheelJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_IsActive_0(b2WheelJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetCollideConnected_0(b2WheelJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint___destroy___0(b2WheelJoint* self) {\n  delete self;\n}\n\n// b2PulleyJoint\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetGroundAnchorA_0(b2PulleyJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetGroundAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetGroundAnchorB_0(b2PulleyJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetGroundAnchorB(), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetLengthA_0(b2PulleyJoint* self) {\n  return self->GetLengthA();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetLengthB_0(b2PulleyJoint* self) {\n  return self->GetLengthB();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetRatio_0(b2PulleyJoint* self) {\n  return self->GetRatio();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetType_0(b2PulleyJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetBodyA_0(b2PulleyJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetBodyB_0(b2PulleyJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetAnchorA_0(b2PulleyJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetAnchorB_0(b2PulleyJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetReactionForce_1(b2PulleyJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetReactionTorque_1(b2PulleyJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetNext_0(b2PulleyJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetUserData_0(b2PulleyJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_SetUserData_1(b2PulleyJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_IsActive_0(b2PulleyJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetCollideConnected_0(b2PulleyJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint___destroy___0(b2PulleyJoint* self) {\n  delete self;\n}\n\n// b2MouseJointDef\n\nb2MouseJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_b2MouseJointDef_0() {\n  return new b2MouseJointDef();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_target_0(b2MouseJointDef* self) {\n  return &self->target;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_target_1(b2MouseJointDef* self, b2Vec2* arg0) {\n  self->target = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_maxForce_0(b2MouseJointDef* self) {\n  return self->maxForce;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_maxForce_1(b2MouseJointDef* self, float arg0) {\n  self->maxForce = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_frequencyHz_0(b2MouseJointDef* self) {\n  return self->frequencyHz;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_frequencyHz_1(b2MouseJointDef* self, float arg0) {\n  self->frequencyHz = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_dampingRatio_0(b2MouseJointDef* self) {\n  return self->dampingRatio;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_dampingRatio_1(b2MouseJointDef* self, float arg0) {\n  self->dampingRatio = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_type_0(b2MouseJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_type_1(b2MouseJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_userData_0(b2MouseJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_userData_1(b2MouseJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_bodyA_0(b2MouseJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_bodyA_1(b2MouseJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_bodyB_0(b2MouseJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_bodyB_1(b2MouseJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_collideConnected_0(b2MouseJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_collideConnected_1(b2MouseJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef___destroy___0(b2MouseJointDef* self) {\n  delete self;\n}\n\n// b2Contact\n\nb2Manifold* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetManifold_0(b2Contact* self) {\n  return self->GetManifold();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_IsTouching_0(b2Contact* self) {\n  return self->IsTouching();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_SetEnabled_1(b2Contact* self, bool arg0) {\n  self->SetEnabled(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_IsEnabled_0(b2Contact* self) {\n  return self->IsEnabled();\n}\n\nb2Contact* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetNext_0(b2Contact* self) {\n  return self->GetNext();\n}\n\nb2Fixture* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetFixtureA_0(b2Contact* self) {\n  return self->GetFixtureA();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetChildIndexA_0(b2Contact* self) {\n  return self->GetChildIndexA();\n}\n\nb2Fixture* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetFixtureB_0(b2Contact* self) {\n  return self->GetFixtureB();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetChildIndexB_0(b2Contact* self) {\n  return self->GetChildIndexB();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_SetFriction_1(b2Contact* self, float arg0) {\n  self->SetFriction(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetFriction_0(b2Contact* self) {\n  return self->GetFriction();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_ResetFriction_0(b2Contact* self) {\n  self->ResetFriction();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_SetRestitution_1(b2Contact* self, float arg0) {\n  self->SetRestitution(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetRestitution_0(b2Contact* self) {\n  return self->GetRestitution();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_ResetRestitution_0(b2Contact* self) {\n  self->ResetRestitution();\n}\n\n// b2Shape\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_GetType_0(b2Shape* self) {\n  return self->GetType();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_GetChildCount_0(b2Shape* self) {\n  return self->GetChildCount();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_TestPoint_2(b2Shape* self, b2Transform* arg0, b2Vec2* arg1) {\n  return self->TestPoint(*arg0, *arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_RayCast_4(b2Shape* self, b2RayCastOutput* arg0, b2RayCastInput* arg1, b2Transform* arg2, int arg3) {\n  return self->RayCast(arg0, *arg1, *arg2, arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_ComputeAABB_3(b2Shape* self, b2AABB* arg0, b2Transform* arg1, int arg2) {\n  self->ComputeAABB(arg0, *arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_ComputeMass_2(b2Shape* self, b2MassData* arg0, float arg1) {\n  self->ComputeMass(arg0, arg1);\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_get_m_type_0(b2Shape* self) {\n  return self->m_type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_set_m_type_1(b2Shape* self, b2ShapeType arg0) {\n  self->m_type = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_get_m_radius_0(b2Shape* self) {\n  return self->m_radius;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_set_m_radius_1(b2Shape* self, float arg0) {\n  self->m_radius = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape___destroy___0(b2Shape* self) {\n  delete self;\n}\n\n// b2DistanceJointDef\n\nb2DistanceJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_b2DistanceJointDef_0() {\n  return new b2DistanceJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_Initialize_4(b2DistanceJointDef* self, b2Body* arg0, b2Body* arg1, b2Vec2* arg2, b2Vec2* arg3) {\n  self->Initialize(arg0, arg1, *arg2, *arg3);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_localAnchorA_0(b2DistanceJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_localAnchorA_1(b2DistanceJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_localAnchorB_0(b2DistanceJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_localAnchorB_1(b2DistanceJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_length_0(b2DistanceJointDef* self) {\n  return self->length;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_length_1(b2DistanceJointDef* self, float arg0) {\n  self->length = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_frequencyHz_0(b2DistanceJointDef* self) {\n  return self->frequencyHz;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_frequencyHz_1(b2DistanceJointDef* self, float arg0) {\n  self->frequencyHz = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_dampingRatio_0(b2DistanceJointDef* self) {\n  return self->dampingRatio;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_dampingRatio_1(b2DistanceJointDef* self, float arg0) {\n  self->dampingRatio = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_type_0(b2DistanceJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_type_1(b2DistanceJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_userData_0(b2DistanceJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_userData_1(b2DistanceJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_bodyA_0(b2DistanceJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_bodyA_1(b2DistanceJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_bodyB_0(b2DistanceJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_bodyB_1(b2DistanceJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_collideConnected_0(b2DistanceJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_collideConnected_1(b2DistanceJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef___destroy___0(b2DistanceJointDef* self) {\n  delete self;\n}\n\n// b2Body\n\nb2Fixture* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_CreateFixture_1(b2Body* self, b2FixtureDef* arg0) {\n  return self->CreateFixture(arg0);\n}\n\nb2Fixture* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_CreateFixture_2(b2Body* self, b2Shape* arg0, float arg1) {\n  return self->CreateFixture(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_DestroyFixture_1(b2Body* self, b2Fixture* arg0) {\n  self->DestroyFixture(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetTransform_2(b2Body* self, b2Vec2* arg0, float arg1) {\n  self->SetTransform(*arg0, arg1);\n}\n\nconst b2Transform* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetTransform_0(b2Body* self) {\n  return &self->GetTransform();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetPosition_0(b2Body* self) {\n  return &self->GetPosition();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetAngle_0(b2Body* self) {\n  return self->GetAngle();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetWorldCenter_0(b2Body* self) {\n  return &self->GetWorldCenter();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetLocalCenter_0(b2Body* self) {\n  return &self->GetLocalCenter();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetLinearVelocity_1(b2Body* self, b2Vec2* arg0) {\n  self->SetLinearVelocity(*arg0);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetLinearVelocity_0(b2Body* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetLinearVelocity(), &temp);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetAngularVelocity_1(b2Body* self, float arg0) {\n  self->SetAngularVelocity(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetAngularVelocity_0(b2Body* self) {\n  return self->GetAngularVelocity();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_ApplyForce_2(b2Body* self, b2Vec2* arg0, b2Vec2* arg1) {\n  self->ApplyForce(*arg0, *arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_ApplyForceToCenter_1(b2Body* self, b2Vec2* arg0) {\n  self->ApplyForceToCenter(*arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_ApplyTorque_1(b2Body* self, float arg0) {\n  self->ApplyTorque(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_ApplyLinearImpulse_2(b2Body* self, b2Vec2* arg0, b2Vec2* arg1) {\n  self->ApplyLinearImpulse(*arg0, *arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_ApplyAngularImpulse_1(b2Body* self, float arg0) {\n  self->ApplyAngularImpulse(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetMass_0(b2Body* self) {\n  return self->GetMass();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetInertia_0(b2Body* self) {\n  return self->GetInertia();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetMassData_1(b2Body* self, b2MassData* arg0) {\n  self->GetMassData(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetMassData_1(b2Body* self, b2MassData* arg0) {\n  self->SetMassData(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_ResetMassData_0(b2Body* self) {\n  self->ResetMassData();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetWorldPoint_1(b2Body* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetWorldPoint(*arg0), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetWorldVector_1(b2Body* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetWorldVector(*arg0), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetLocalPoint_1(b2Body* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetLocalPoint(*arg0), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetLocalVector_1(b2Body* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetLocalVector(*arg0), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetLinearVelocityFromWorldPoint_1(b2Body* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetLinearVelocityFromWorldPoint(*arg0), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetLinearVelocityFromLocalPoint_1(b2Body* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetLinearVelocityFromLocalPoint(*arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetLinearDamping_0(b2Body* self) {\n  return self->GetLinearDamping();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetLinearDamping_1(b2Body* self, float arg0) {\n  self->SetLinearDamping(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetAngularDamping_0(b2Body* self) {\n  return self->GetAngularDamping();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetAngularDamping_1(b2Body* self, float arg0) {\n  self->SetAngularDamping(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetGravityScale_0(b2Body* self) {\n  return self->GetGravityScale();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetGravityScale_1(b2Body* self, float arg0) {\n  self->SetGravityScale(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetType_1(b2Body* self, b2BodyType arg0) {\n  self->SetType(arg0);\n}\n\nb2BodyType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetType_0(b2Body* self) {\n  return self->GetType();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetBullet_1(b2Body* self, bool arg0) {\n  self->SetBullet(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_IsBullet_0(b2Body* self) {\n  return self->IsBullet();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetSleepingAllowed_1(b2Body* self, bool arg0) {\n  self->SetSleepingAllowed(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_IsSleepingAllowed_0(b2Body* self) {\n  return self->IsSleepingAllowed();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetAwake_1(b2Body* self, bool arg0) {\n  self->SetAwake(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_IsAwake_0(b2Body* self) {\n  return self->IsAwake();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetActive_1(b2Body* self, bool arg0) {\n  self->SetActive(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_IsActive_0(b2Body* self) {\n  return self->IsActive();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetFixedRotation_1(b2Body* self, bool arg0) {\n  self->SetFixedRotation(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_IsFixedRotation_0(b2Body* self) {\n  return self->IsFixedRotation();\n}\n\nb2Fixture* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetFixtureList_0(b2Body* self) {\n  return self->GetFixtureList();\n}\n\nb2JointEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetJointList_0(b2Body* self) {\n  return self->GetJointList();\n}\n\nb2ContactEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetContactList_0(b2Body* self) {\n  return self->GetContactList();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetNext_0(b2Body* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetUserData_0(b2Body* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetUserData_1(b2Body* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nb2World* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetWorld_0(b2Body* self) {\n  return self->GetWorld();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_Dump_0(b2Body* self) {\n  self->Dump();\n}\n\n// b2FrictionJoint\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetLocalAnchorA_0(b2FrictionJoint* self) {\n  return &self->GetLocalAnchorA();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetLocalAnchorB_0(b2FrictionJoint* self) {\n  return &self->GetLocalAnchorB();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_SetMaxForce_1(b2FrictionJoint* self, float arg0) {\n  self->SetMaxForce(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetMaxForce_0(b2FrictionJoint* self) {\n  return self->GetMaxForce();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_SetMaxTorque_1(b2FrictionJoint* self, float arg0) {\n  self->SetMaxTorque(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetMaxTorque_0(b2FrictionJoint* self) {\n  return self->GetMaxTorque();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetType_0(b2FrictionJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetBodyA_0(b2FrictionJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetBodyB_0(b2FrictionJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetAnchorA_0(b2FrictionJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetAnchorB_0(b2FrictionJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetReactionForce_1(b2FrictionJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetReactionTorque_1(b2FrictionJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetNext_0(b2FrictionJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetUserData_0(b2FrictionJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_SetUserData_1(b2FrictionJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_IsActive_0(b2FrictionJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetCollideConnected_0(b2FrictionJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint___destroy___0(b2FrictionJoint* self) {\n  delete self;\n}\n\n// b2DestructionListener\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DestructionListener___destroy___0(b2DestructionListener* self) {\n  delete self;\n}\n\n// b2GearJointDef\n\nb2GearJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_b2GearJointDef_0() {\n  return new b2GearJointDef();\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_joint1_0(b2GearJointDef* self) {\n  return self->joint1;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_joint1_1(b2GearJointDef* self, b2Joint* arg0) {\n  self->joint1 = arg0;\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_joint2_0(b2GearJointDef* self) {\n  return self->joint2;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_joint2_1(b2GearJointDef* self, b2Joint* arg0) {\n  self->joint2 = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_ratio_0(b2GearJointDef* self) {\n  return self->ratio;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_ratio_1(b2GearJointDef* self, float arg0) {\n  self->ratio = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_type_0(b2GearJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_type_1(b2GearJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_userData_0(b2GearJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_userData_1(b2GearJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_bodyA_0(b2GearJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_bodyA_1(b2GearJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_bodyB_0(b2GearJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_bodyB_1(b2GearJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_collideConnected_0(b2GearJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_collideConnected_1(b2GearJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef___destroy___0(b2GearJointDef* self) {\n  delete self;\n}\n\n// b2RevoluteJoint\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetLocalAnchorA_0(b2RevoluteJoint* self) {\n  return &self->GetLocalAnchorA();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetLocalAnchorB_0(b2RevoluteJoint* self) {\n  return &self->GetLocalAnchorB();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetReferenceAngle_0(b2RevoluteJoint* self) {\n  return self->GetReferenceAngle();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetJointAngle_0(b2RevoluteJoint* self) {\n  return self->GetJointAngle();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetJointSpeed_0(b2RevoluteJoint* self) {\n  return self->GetJointSpeed();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_IsLimitEnabled_0(b2RevoluteJoint* self) {\n  return self->IsLimitEnabled();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_EnableLimit_1(b2RevoluteJoint* self, bool arg0) {\n  self->EnableLimit(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetLowerLimit_0(b2RevoluteJoint* self) {\n  return self->GetLowerLimit();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetUpperLimit_0(b2RevoluteJoint* self) {\n  return self->GetUpperLimit();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_SetLimits_2(b2RevoluteJoint* self, float arg0, float arg1) {\n  self->SetLimits(arg0, arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_IsMotorEnabled_0(b2RevoluteJoint* self) {\n  return self->IsMotorEnabled();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_EnableMotor_1(b2RevoluteJoint* self, bool arg0) {\n  self->EnableMotor(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_SetMotorSpeed_1(b2RevoluteJoint* self, float arg0) {\n  self->SetMotorSpeed(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetMotorSpeed_0(b2RevoluteJoint* self) {\n  return self->GetMotorSpeed();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_SetMaxMotorTorque_1(b2RevoluteJoint* self, float arg0) {\n  self->SetMaxMotorTorque(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetMaxMotorTorque_0(b2RevoluteJoint* self) {\n  return self->GetMaxMotorTorque();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetMotorTorque_1(b2RevoluteJoint* self, float arg0) {\n  return self->GetMotorTorque(arg0);\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetType_0(b2RevoluteJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetBodyA_0(b2RevoluteJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetBodyB_0(b2RevoluteJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetAnchorA_0(b2RevoluteJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetAnchorB_0(b2RevoluteJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetReactionForce_1(b2RevoluteJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetReactionTorque_1(b2RevoluteJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetNext_0(b2RevoluteJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetUserData_0(b2RevoluteJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_SetUserData_1(b2RevoluteJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_IsActive_0(b2RevoluteJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetCollideConnected_0(b2RevoluteJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint___destroy___0(b2RevoluteJoint* self) {\n  delete self;\n}\n\n// b2ContactFilter\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFilter___destroy___0(b2ContactFilter* self) {\n  delete self;\n}\n\n// b2ContactEdge\n\nb2ContactEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_b2ContactEdge_0() {\n  return new b2ContactEdge();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_get_other_0(b2ContactEdge* self) {\n  return self->other;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_set_other_1(b2ContactEdge* self, b2Body* arg0) {\n  self->other = arg0;\n}\n\nb2Contact* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_get_contact_0(b2ContactEdge* self) {\n  return self->contact;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_set_contact_1(b2ContactEdge* self, b2Contact* arg0) {\n  self->contact = arg0;\n}\n\nb2ContactEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_get_prev_0(b2ContactEdge* self) {\n  return self->prev;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_set_prev_1(b2ContactEdge* self, b2ContactEdge* arg0) {\n  self->prev = arg0;\n}\n\nb2ContactEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_get_next_0(b2ContactEdge* self) {\n  return self->next;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_set_next_1(b2ContactEdge* self, b2ContactEdge* arg0) {\n  self->next = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge___destroy___0(b2ContactEdge* self) {\n  delete self;\n}\n\n// b2RopeJointDef\n\nb2RopeJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_b2RopeJointDef_0() {\n  return new b2RopeJointDef();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_localAnchorA_0(b2RopeJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_localAnchorA_1(b2RopeJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_localAnchorB_0(b2RopeJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_localAnchorB_1(b2RopeJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_maxLength_0(b2RopeJointDef* self) {\n  return self->maxLength;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_maxLength_1(b2RopeJointDef* self, float arg0) {\n  self->maxLength = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_type_0(b2RopeJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_type_1(b2RopeJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_userData_0(b2RopeJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_userData_1(b2RopeJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_bodyA_0(b2RopeJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_bodyA_1(b2RopeJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_bodyB_0(b2RopeJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_bodyB_1(b2RopeJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_collideConnected_0(b2RopeJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_collideConnected_1(b2RopeJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef___destroy___0(b2RopeJointDef* self) {\n  delete self;\n}\n\n// b2ShapeType\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ShapeType_e_circle() {\n  return b2Shape::e_circle;\n}\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ShapeType_e_edge() {\n  return b2Shape::e_edge;\n}\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ShapeType_e_polygon() {\n  return b2Shape::e_polygon;\n}\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ShapeType_e_chain() {\n  return b2Shape::e_chain;\n}\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ShapeType_e_typeCount() {\n  return b2Shape::e_typeCount;\n}\n\n// b2JointType\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_unknownJoint() {\n  return e_unknownJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_revoluteJoint() {\n  return e_revoluteJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_prismaticJoint() {\n  return e_prismaticJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_distanceJoint() {\n  return e_distanceJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_pulleyJoint() {\n  return e_pulleyJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_mouseJoint() {\n  return e_mouseJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_gearJoint() {\n  return e_gearJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_wheelJoint() {\n  return e_wheelJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_weldJoint() {\n  return e_weldJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_frictionJoint() {\n  return e_frictionJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_ropeJoint() {\n  return e_ropeJoint;\n}\n\n// b2LimitState\nb2LimitState EMSCRIPTEN_KEEPALIVE emscripten_enum_b2LimitState_e_inactiveLimit() {\n  return e_inactiveLimit;\n}\nb2LimitState EMSCRIPTEN_KEEPALIVE emscripten_enum_b2LimitState_e_atLowerLimit() {\n  return e_atLowerLimit;\n}\nb2LimitState EMSCRIPTEN_KEEPALIVE emscripten_enum_b2LimitState_e_atUpperLimit() {\n  return e_atUpperLimit;\n}\nb2LimitState EMSCRIPTEN_KEEPALIVE emscripten_enum_b2LimitState_e_equalLimits() {\n  return e_equalLimits;\n}\n\n// b2ManifoldType\nb2ManifoldType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ManifoldType_e_circles() {\n  return b2Manifold::e_circles;\n}\nb2ManifoldType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ManifoldType_e_faceA() {\n  return b2Manifold::e_faceA;\n}\nb2ManifoldType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ManifoldType_e_faceB() {\n  return b2Manifold::e_faceB;\n}\n\n// b2BodyType\nb2BodyType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2BodyType_b2_staticBody() {\n  return b2_staticBody;\n}\nb2BodyType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2BodyType_b2_kinematicBody() {\n  return b2_kinematicBody;\n}\nb2BodyType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2BodyType_b2_dynamicBody() {\n  return b2_dynamicBody;\n}\n\n// b2DrawFlag\nb2DrawFlag EMSCRIPTEN_KEEPALIVE emscripten_enum_b2DrawFlag_e_shapeBit() {\n  return b2Draw::e_shapeBit;\n}\nb2DrawFlag EMSCRIPTEN_KEEPALIVE emscripten_enum_b2DrawFlag_e_jointBit() {\n  return b2Draw::e_jointBit;\n}\nb2DrawFlag EMSCRIPTEN_KEEPALIVE emscripten_enum_b2DrawFlag_e_aabbBit() {\n  return b2Draw::e_aabbBit;\n}\nb2DrawFlag EMSCRIPTEN_KEEPALIVE emscripten_enum_b2DrawFlag_e_pairBit() {\n  return b2Draw::e_pairBit;\n}\nb2DrawFlag EMSCRIPTEN_KEEPALIVE emscripten_enum_b2DrawFlag_e_centerOfMassBit() {\n  return b2Draw::e_centerOfMassBit;\n}\n\n// b2ContactFeatureType\nb2ContactFeatureType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ContactFeatureType_e_vertex() {\n  return b2ContactFeature::e_vertex;\n}\nb2ContactFeatureType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ContactFeatureType_e_face() {\n  return b2ContactFeature::e_face;\n}\n\n}\n\n","/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_DISTANCE_JOINT_H\r\n#define B2_DISTANCE_JOINT_H\r\n\r\n#include <Box2D/Dynamics/Joints/b2Joint.h>\r\n\r\n/// Distance joint definition. This requires defining an\r\n/// anchor point on both bodies and the non-zero length of the\r\n/// distance joint. The definition uses local anchor points\r\n/// so that the initial configuration can violate the constraint\r\n/// slightly. This helps when saving and loading a game.\r\n/// @warning Do not use a zero or short length.\r\nstruct b2DistanceJointDef : public b2JointDef\r\n{\r\n\tb2DistanceJointDef()\r\n\t{\r\n\t\ttype = e_distanceJoint;\r\n\t\tlocalAnchorA.Set(0.0f, 0.0f);\r\n\t\tlocalAnchorB.Set(0.0f, 0.0f);\r\n\t\tlength = 1.0f;\r\n\t\tfrequencyHz = 0.0f;\r\n\t\tdampingRatio = 0.0f;\r\n\t}\r\n\r\n\t/// Initialize the bodies, anchors, and length using the world\r\n\t/// anchors.\r\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB,\r\n\t\t\t\t\tconst b2Vec2& anchorA, const b2Vec2& anchorB);\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tb2Vec2 localAnchorA;\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tb2Vec2 localAnchorB;\r\n\r\n\t/// The natural length between the anchor points.\r\n\tfloat32 length;\r\n\r\n\t/// The mass-spring-damper frequency in Hertz. A value of 0\r\n\t/// disables softness.\r\n\tfloat32 frequencyHz;\r\n\r\n\t/// The damping ratio. 0 = no damping, 1 = critical damping.\r\n\tfloat32 dampingRatio;\r\n};\r\n\r\n/// A distance joint constrains two points on two bodies\r\n/// to remain at a fixed distance from each other. You can view\r\n/// this as a massless, rigid rod.\r\nclass b2DistanceJoint : public b2Joint\r\n{\r\npublic:\r\n\r\n\tb2Vec2 GetAnchorA() const;\r\n\tb2Vec2 GetAnchorB() const;\r\n\r\n\t/// Get the reaction force given the inverse time step.\r\n\t/// Unit is N.\r\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\r\n\r\n\t/// Get the reaction torque given the inverse time step.\r\n\t/// Unit is N*m. This is always zero for a distance joint.\r\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tconst b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tconst b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }\r\n\r\n\t/// Set/get the natural length.\r\n\t/// Manipulating the length can lead to non-physical behavior when the frequency is zero.\r\n\tvoid SetLength(float32 length);\r\n\tfloat32 GetLength() const;\r\n\r\n\t/// Set/get frequency in Hz.\r\n\tvoid SetFrequency(float32 hz);\r\n\tfloat32 GetFrequency() const;\r\n\r\n\t/// Set/get damping ratio.\r\n\tvoid SetDampingRatio(float32 ratio);\r\n\tfloat32 GetDampingRatio() const;\r\n\r\n\t/// Dump joint to dmLog\r\n\tvoid Dump();\r\n\r\nprotected:\r\n\r\n\tfriend class b2Joint;\r\n\tb2DistanceJoint(const b2DistanceJointDef* data);\r\n\r\n\tvoid InitVelocityConstraints(const b2SolverData& data);\r\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\r\n\tbool SolvePositionConstraints(const b2SolverData& data);\r\n\r\n\tfloat32 m_frequencyHz;\r\n\tfloat32 m_dampingRatio;\r\n\tfloat32 m_bias;\r\n\r\n\t// Solver shared\r\n\tb2Vec2 m_localAnchorA;\r\n\tb2Vec2 m_localAnchorB;\r\n\tfloat32 m_gamma;\r\n\tfloat32 m_impulse;\r\n\tfloat32 m_length;\r\n\r\n\t// Solver temp\r\n\tint32 m_indexA;\r\n\tint32 m_indexB;\r\n\tb2Vec2 m_u;\r\n\tb2Vec2 m_rA;\r\n\tb2Vec2 m_rB;\r\n\tb2Vec2 m_localCenterA;\r\n\tb2Vec2 m_localCenterB;\r\n\tfloat32 m_invMassA;\r\n\tfloat32 m_invMassB;\r\n\tfloat32 m_invIA;\r\n\tfloat32 m_invIB;\r\n\tfloat32 m_mass;\r\n};\r\n\r\ninline void b2DistanceJoint::SetLength(float32 length)\r\n{\r\n\tm_length = length;\r\n}\r\n\r\ninline float32 b2DistanceJoint::GetLength() const\r\n{\r\n\treturn m_length;\r\n}\r\n\r\ninline void b2DistanceJoint::SetFrequency(float32 hz)\r\n{\r\n\tm_frequencyHz = hz;\r\n}\r\n\r\ninline float32 b2DistanceJoint::GetFrequency() const\r\n{\r\n\treturn m_frequencyHz;\r\n}\r\n\r\ninline void b2DistanceJoint::SetDampingRatio(float32 ratio)\r\n{\r\n\tm_dampingRatio = ratio;\r\n}\r\n\r\ninline float32 b2DistanceJoint::GetDampingRatio() const\r\n{\r\n\treturn m_dampingRatio;\r\n}\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_JOINT_H\r\n#define B2_JOINT_H\r\n\r\n#include <Box2D/Common/b2Math.h>\r\n\r\nclass b2Body;\r\nclass b2Joint;\r\nstruct b2SolverData;\r\nclass b2BlockAllocator;\r\n\r\nenum b2JointType\r\n{\r\n\te_unknownJoint,\r\n\te_revoluteJoint,\r\n\te_prismaticJoint,\r\n\te_distanceJoint,\r\n\te_pulleyJoint,\r\n\te_mouseJoint,\r\n\te_gearJoint,\r\n\te_wheelJoint,\r\n    e_weldJoint,\r\n\te_frictionJoint,\r\n\te_ropeJoint\r\n};\r\n\r\nenum b2LimitState\r\n{\r\n\te_inactiveLimit,\r\n\te_atLowerLimit,\r\n\te_atUpperLimit,\r\n\te_equalLimits\r\n};\r\n\r\nstruct b2Jacobian\r\n{\r\n\tb2Vec2 linear;\r\n\tfloat32 angularA;\r\n\tfloat32 angularB;\r\n};\r\n\r\n/// A joint edge is used to connect bodies and joints together\r\n/// in a joint graph where each body is a node and each joint\r\n/// is an edge. A joint edge belongs to a doubly linked list\r\n/// maintained in each attached body. Each joint has two joint\r\n/// nodes, one for each attached body.\r\nstruct b2JointEdge\r\n{\r\n\tb2Body* other;\t\t\t///< provides quick access to the other body attached.\r\n\tb2Joint* joint;\t\t\t///< the joint\r\n\tb2JointEdge* prev;\t\t///< the previous joint edge in the body's joint list\r\n\tb2JointEdge* next;\t\t///< the next joint edge in the body's joint list\r\n};\r\n\r\n/// Joint definitions are used to construct joints.\r\nstruct b2JointDef\r\n{\r\n\tb2JointDef()\r\n\t{\r\n\t\ttype = e_unknownJoint;\r\n\t\tuserData = NULL;\r\n\t\tbodyA = NULL;\r\n\t\tbodyB = NULL;\r\n\t\tcollideConnected = false;\r\n\t}\r\n\r\n\t/// The joint type is set automatically for concrete joint types.\r\n\tb2JointType type;\r\n\r\n\t/// Use this to attach application specific data to your joints.\r\n\tvoid* userData;\r\n\r\n\t/// The first attached body.\r\n\tb2Body* bodyA;\r\n\r\n\t/// The second attached body.\r\n\tb2Body* bodyB;\r\n\r\n\t/// Set this flag to true if the attached bodies should collide.\r\n\tbool collideConnected;\r\n};\r\n\r\n/// The base joint class. Joints are used to constraint two bodies together in\r\n/// various fashions. Some joints also feature limits and motors.\r\nclass b2Joint\r\n{\r\npublic:\r\n\r\n\t/// Get the type of the concrete joint.\r\n\tb2JointType GetType() const;\r\n\r\n\t/// Get the first body attached to this joint.\r\n\tb2Body* GetBodyA();\r\n\r\n\t/// Get the second body attached to this joint.\r\n\tb2Body* GetBodyB();\r\n\r\n\t/// Get the anchor point on bodyA in world coordinates.\r\n\tvirtual b2Vec2 GetAnchorA() const = 0;\r\n\r\n\t/// Get the anchor point on bodyB in world coordinates.\r\n\tvirtual b2Vec2 GetAnchorB() const = 0;\r\n\r\n\t/// Get the reaction force on bodyB at the joint anchor in Newtons.\r\n\tvirtual b2Vec2 GetReactionForce(float32 inv_dt) const = 0;\r\n\r\n\t/// Get the reaction torque on bodyB in N*m.\r\n\tvirtual float32 GetReactionTorque(float32 inv_dt) const = 0;\r\n\r\n\t/// Get the next joint the world joint list.\r\n\tb2Joint* GetNext();\r\n\tconst b2Joint* GetNext() const;\r\n\r\n\t/// Get the user data pointer.\r\n\tvoid* GetUserData() const;\r\n\r\n\t/// Set the user data pointer.\r\n\tvoid SetUserData(void* data);\r\n\r\n\t/// Short-cut function to determine if either body is inactive.\r\n\tbool IsActive() const;\r\n\r\n\t/// Get collide connected.\r\n\t/// Note: modifying the collide connect flag won't work correctly because\r\n\t/// the flag is only checked when fixture AABBs begin to overlap.\r\n\tbool GetCollideConnected() const;\r\n\r\n\t/// Dump this joint to the log file.\r\n\tvirtual void Dump() { b2Log(\"// Dump is not supported for this joint type.\\n\"); }\r\n\r\nprotected:\r\n\tfriend class b2World;\r\n\tfriend class b2Body;\r\n\tfriend class b2Island;\r\n\tfriend class b2GearJoint;\r\n\r\n\tstatic b2Joint* Create(const b2JointDef* def, b2BlockAllocator* allocator);\r\n\tstatic void Destroy(b2Joint* joint, b2BlockAllocator* allocator);\r\n\r\n\tb2Joint(const b2JointDef* def);\r\n\tvirtual ~b2Joint() {}\r\n\r\n\tvirtual void InitVelocityConstraints(const b2SolverData& data) = 0;\r\n\tvirtual void SolveVelocityConstraints(const b2SolverData& data) = 0;\r\n\r\n\t// This returns true if the position errors are within tolerance.\r\n\tvirtual bool SolvePositionConstraints(const b2SolverData& data) = 0;\r\n\r\n\tb2JointType m_type;\r\n\tb2Joint* m_prev;\r\n\tb2Joint* m_next;\r\n\tb2JointEdge m_edgeA;\r\n\tb2JointEdge m_edgeB;\r\n\tb2Body* m_bodyA;\r\n\tb2Body* m_bodyB;\r\n\r\n\tint32 m_index;\r\n\r\n\tbool m_islandFlag;\r\n\tbool m_collideConnected;\r\n\r\n\tvoid* m_userData;\r\n};\r\n\r\ninline b2JointType b2Joint::GetType() const\r\n{\r\n\treturn m_type;\r\n}\r\n\r\ninline b2Body* b2Joint::GetBodyA()\r\n{\r\n\treturn m_bodyA;\r\n}\r\n\r\ninline b2Body* b2Joint::GetBodyB()\r\n{\r\n\treturn m_bodyB;\r\n}\r\n\r\ninline b2Joint* b2Joint::GetNext()\r\n{\r\n\treturn m_next;\r\n}\r\n\r\ninline const b2Joint* b2Joint::GetNext() const\r\n{\r\n\treturn m_next;\r\n}\r\n\r\ninline void* b2Joint::GetUserData() const\r\n{\r\n\treturn m_userData;\r\n}\r\n\r\ninline void b2Joint::SetUserData(void* data)\r\n{\r\n\tm_userData = data;\r\n}\r\n\r\ninline bool b2Joint::GetCollideConnected() const\r\n{\r\n\treturn m_collideConnected;\r\n}\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_MATH_H\r\n#define B2_MATH_H\r\n\r\n#include <Box2D/Common/b2Settings.h>\r\n\r\n#include <cmath>\r\n#include <cfloat>\r\n#include <cstddef>\r\n#include <limits>\r\n\r\n/// This function is used to ensure that a floating point number is\r\n/// not a NaN or infinity.\r\ninline bool b2IsValid(float32 x)\r\n{\r\n\tif (x != x)\r\n\t{\r\n\t\t// NaN.\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfloat32 infinity = std::numeric_limits<float32>::infinity();\r\n\treturn -infinity < x && x < infinity;\r\n}\r\n\r\n/// This is a approximate yet fast inverse square-root.\r\ninline float32 b2InvSqrt(float32 x)\r\n{\r\n\tunion\r\n\t{\r\n\t\tfloat32 x;\r\n\t\tint32 i;\r\n\t} convert;\r\n\r\n\tconvert.x = x;\r\n\tfloat32 xhalf = 0.5f * x;\r\n\tconvert.i = 0x5f3759df - (convert.i >> 1);\r\n\tx = convert.x;\r\n\tx = x * (1.5f - xhalf * x * x);\r\n\treturn x;\r\n}\r\n\r\n#define\tb2Sqrt(x)\tstd::sqrt(x)\r\n#define\tb2Atan2(y, x)\tstd::atan2(y, x)\r\n\r\n/// A 2D column vector.\r\nstruct b2Vec2\r\n{\r\n\t/// Default constructor does nothing (for performance).\r\n\tb2Vec2() {}\r\n\r\n\t/// Construct using coordinates.\r\n\tb2Vec2(float32 x, float32 y) : x(x), y(y) {}\r\n\r\n\t/// Set this vector to all zeros.\r\n\tvoid SetZero() { x = 0.0f; y = 0.0f; }\r\n\r\n\t/// Set this vector to some specified coordinates.\r\n\tvoid Set(float32 x_, float32 y_) { x = x_; y = y_; }\r\n\r\n\t/// Negate this vector.\r\n\tb2Vec2 operator -() const { b2Vec2 v; v.Set(-x, -y); return v; }\r\n\t\r\n\t/// Read from and indexed element.\r\n\tfloat32 operator () (int32 i) const\r\n\t{\r\n\t\treturn (&x)[i];\r\n\t}\r\n\r\n\t/// Write to an indexed element.\r\n\tfloat32& operator () (int32 i)\r\n\t{\r\n\t\treturn (&x)[i];\r\n\t}\r\n\r\n\t/// Add a vector to this vector.\r\n\tvoid operator += (const b2Vec2& v)\r\n\t{\r\n\t\tx += v.x; y += v.y;\r\n\t}\r\n\t\r\n\t/// Subtract a vector from this vector.\r\n\tvoid operator -= (const b2Vec2& v)\r\n\t{\r\n\t\tx -= v.x; y -= v.y;\r\n\t}\r\n\r\n\t/// Multiply this vector by a scalar.\r\n\tvoid operator *= (float32 a)\r\n\t{\r\n\t\tx *= a; y *= a;\r\n\t}\r\n\r\n\t/// Get the length of this vector (the norm).\r\n\tfloat32 Length() const\r\n\t{\r\n\t\treturn b2Sqrt(x * x + y * y);\r\n\t}\r\n\r\n\t/// Get the length squared. For performance, use this instead of\r\n\t/// b2Vec2::Length (if possible).\r\n\tfloat32 LengthSquared() const\r\n\t{\r\n\t\treturn x * x + y * y;\r\n\t}\r\n\r\n\t/// Convert this vector into a unit vector. Returns the length.\r\n\tfloat32 Normalize()\r\n\t{\r\n\t\tfloat32 length = Length();\r\n\t\tif (length < b2_epsilon)\r\n\t\t{\r\n\t\t\treturn 0.0f;\r\n\t\t}\r\n\t\tfloat32 invLength = 1.0f / length;\r\n\t\tx *= invLength;\r\n\t\ty *= invLength;\r\n\r\n\t\treturn length;\r\n\t}\r\n\r\n\t/// Does this vector contain finite coordinates?\r\n\tbool IsValid() const\r\n\t{\r\n\t\treturn b2IsValid(x) && b2IsValid(y);\r\n\t}\r\n\r\n\t/// Get the skew vector such that dot(skew_vec, other) == cross(vec, other)\r\n\tb2Vec2 Skew() const\r\n\t{\r\n\t\treturn b2Vec2(-y, x);\r\n\t}\r\n\r\n\tfloat32 x, y;\r\n};\r\n\r\n/// A 2D column vector with 3 elements.\r\nstruct b2Vec3\r\n{\r\n\t/// Default constructor does nothing (for performance).\r\n\tb2Vec3() {}\r\n\r\n\t/// Construct using coordinates.\r\n\tb2Vec3(float32 x, float32 y, float32 z) : x(x), y(y), z(z) {}\r\n\r\n\t/// Set this vector to all zeros.\r\n\tvoid SetZero() { x = 0.0f; y = 0.0f; z = 0.0f; }\r\n\r\n\t/// Set this vector to some specified coordinates.\r\n\tvoid Set(float32 x_, float32 y_, float32 z_) { x = x_; y = y_; z = z_; }\r\n\r\n\t/// Negate this vector.\r\n\tb2Vec3 operator -() const { b2Vec3 v; v.Set(-x, -y, -z); return v; }\r\n\r\n\t/// Add a vector to this vector.\r\n\tvoid operator += (const b2Vec3& v)\r\n\t{\r\n\t\tx += v.x; y += v.y; z += v.z;\r\n\t}\r\n\r\n\t/// Subtract a vector from this vector.\r\n\tvoid operator -= (const b2Vec3& v)\r\n\t{\r\n\t\tx -= v.x; y -= v.y; z -= v.z;\r\n\t}\r\n\r\n\t/// Multiply this vector by a scalar.\r\n\tvoid operator *= (float32 s)\r\n\t{\r\n\t\tx *= s; y *= s; z *= s;\r\n\t}\r\n\r\n\tfloat32 x, y, z;\r\n};\r\n\r\n/// A 2-by-2 matrix. Stored in column-major order.\r\nstruct b2Mat22\r\n{\r\n\t/// The default constructor does nothing (for performance).\r\n\tb2Mat22() {}\r\n\r\n\t/// Construct this matrix using columns.\r\n\tb2Mat22(const b2Vec2& c1, const b2Vec2& c2)\r\n\t{\r\n\t\tex = c1;\r\n\t\tey = c2;\r\n\t}\r\n\r\n\t/// Construct this matrix using scalars.\r\n\tb2Mat22(float32 a11, float32 a12, float32 a21, float32 a22)\r\n\t{\r\n\t\tex.x = a11; ex.y = a21;\r\n\t\tey.x = a12; ey.y = a22;\r\n\t}\r\n\r\n\t/// Initialize this matrix using columns.\r\n\tvoid Set(const b2Vec2& c1, const b2Vec2& c2)\r\n\t{\r\n\t\tex = c1;\r\n\t\tey = c2;\r\n\t}\r\n\r\n\t/// Set this to the identity matrix.\r\n\tvoid SetIdentity()\r\n\t{\r\n\t\tex.x = 1.0f; ey.x = 0.0f;\r\n\t\tex.y = 0.0f; ey.y = 1.0f;\r\n\t}\r\n\r\n\t/// Set this matrix to all zeros.\r\n\tvoid SetZero()\r\n\t{\r\n\t\tex.x = 0.0f; ey.x = 0.0f;\r\n\t\tex.y = 0.0f; ey.y = 0.0f;\r\n\t}\r\n\r\n\tb2Mat22 GetInverse() const\r\n\t{\r\n\t\tfloat32 a = ex.x, b = ey.x, c = ex.y, d = ey.y;\r\n\t\tb2Mat22 B;\r\n\t\tfloat32 det = a * d - b * c;\r\n\t\tif (det != 0.0f)\r\n\t\t{\r\n\t\t\tdet = 1.0f / det;\r\n\t\t}\r\n\t\tB.ex.x =  det * d;\tB.ey.x = -det * b;\r\n\t\tB.ex.y = -det * c;\tB.ey.y =  det * a;\r\n\t\treturn B;\r\n\t}\r\n\r\n\t/// Solve A * x = b, where b is a column vector. This is more efficient\r\n\t/// than computing the inverse in one-shot cases.\r\n\tb2Vec2 Solve(const b2Vec2& b) const\r\n\t{\r\n\t\tfloat32 a11 = ex.x, a12 = ey.x, a21 = ex.y, a22 = ey.y;\r\n\t\tfloat32 det = a11 * a22 - a12 * a21;\r\n\t\tif (det != 0.0f)\r\n\t\t{\r\n\t\t\tdet = 1.0f / det;\r\n\t\t}\r\n\t\tb2Vec2 x;\r\n\t\tx.x = det * (a22 * b.x - a12 * b.y);\r\n\t\tx.y = det * (a11 * b.y - a21 * b.x);\r\n\t\treturn x;\r\n\t}\r\n\r\n\tb2Vec2 ex, ey;\r\n};\r\n\r\n/// A 3-by-3 matrix. Stored in column-major order.\r\nstruct b2Mat33\r\n{\r\n\t/// The default constructor does nothing (for performance).\r\n\tb2Mat33() {}\r\n\r\n\t/// Construct this matrix using columns.\r\n\tb2Mat33(const b2Vec3& c1, const b2Vec3& c2, const b2Vec3& c3)\r\n\t{\r\n\t\tex = c1;\r\n\t\tey = c2;\r\n\t\tez = c3;\r\n\t}\r\n\r\n\t/// Set this matrix to all zeros.\r\n\tvoid SetZero()\r\n\t{\r\n\t\tex.SetZero();\r\n\t\tey.SetZero();\r\n\t\tez.SetZero();\r\n\t}\r\n\r\n\t/// Solve A * x = b, where b is a column vector. This is more efficient\r\n\t/// than computing the inverse in one-shot cases.\r\n\tb2Vec3 Solve33(const b2Vec3& b) const;\r\n\r\n\t/// Solve A * x = b, where b is a column vector. This is more efficient\r\n\t/// than computing the inverse in one-shot cases. Solve only the upper\r\n\t/// 2-by-2 matrix equation.\r\n\tb2Vec2 Solve22(const b2Vec2& b) const;\r\n\r\n\t/// Get the inverse of this matrix as a 2-by-2.\r\n\t/// Returns the zero matrix if singular.\r\n\tvoid GetInverse22(b2Mat33* M) const;\r\n\r\n\t/// Get the symmetric inverse of this matrix as a 3-by-3.\r\n\t/// Returns the zero matrix if singular.\r\n\tvoid GetSymInverse33(b2Mat33* M) const;\r\n\r\n\tb2Vec3 ex, ey, ez;\r\n};\r\n\r\n/// Rotation\r\nstruct b2Rot\r\n{\r\n\tb2Rot() {}\r\n\r\n\t/// Initialize from an angle in radians\r\n\texplicit b2Rot(float32 angle)\r\n\t{\r\n\t\t/// TODO_ERIN optimize\r\n\t\ts = sinf(angle);\r\n\t\tc = cosf(angle);\r\n\t}\r\n\r\n\t/// Set using an angle in radians.\r\n\tvoid Set(float32 angle)\r\n\t{\r\n\t\t/// TODO_ERIN optimize\r\n\t\ts = sinf(angle);\r\n\t\tc = cosf(angle);\r\n\t}\r\n\r\n\t/// Set to the identity rotation\r\n\tvoid SetIdentity()\r\n\t{\r\n\t\ts = 0.0f;\r\n\t\tc = 1.0f;\r\n\t}\r\n\r\n\t/// Get the angle in radians\r\n\tfloat32 GetAngle() const\r\n\t{\r\n\t\treturn b2Atan2(s, c);\r\n\t}\r\n\r\n\t/// Get the x-axis\r\n\tb2Vec2 GetXAxis() const\r\n\t{\r\n\t\treturn b2Vec2(c, s);\r\n\t}\r\n\r\n\t/// Get the u-axis\r\n\tb2Vec2 GetYAxis() const\r\n\t{\r\n\t\treturn b2Vec2(-s, c);\r\n\t}\r\n\r\n\t/// Sine and cosine\r\n\tfloat32 s, c;\r\n};\r\n\r\n/// A transform contains translation and rotation. It is used to represent\r\n/// the position and orientation of rigid frames.\r\nstruct b2Transform\r\n{\r\n\t/// The default constructor does nothing.\r\n\tb2Transform() {}\r\n\r\n\t/// Initialize using a position vector and a rotation.\r\n\tb2Transform(const b2Vec2& position, const b2Rot& rotation) : p(position), q(rotation) {}\r\n\r\n\t/// Set this to the identity transform.\r\n\tvoid SetIdentity()\r\n\t{\r\n\t\tp.SetZero();\r\n\t\tq.SetIdentity();\r\n\t}\r\n\r\n\t/// Set this based on the position and angle.\r\n\tvoid Set(const b2Vec2& position, float32 angle)\r\n\t{\r\n\t\tp = position;\r\n\t\tq.Set(angle);\r\n\t}\r\n\r\n\tb2Vec2 p;\r\n\tb2Rot q;\r\n};\r\n\r\n/// This describes the motion of a body/shape for TOI computation.\r\n/// Shapes are defined with respect to the body origin, which may\r\n/// no coincide with the center of mass. However, to support dynamics\r\n/// we must interpolate the center of mass position.\r\nstruct b2Sweep\r\n{\r\n\t/// Get the interpolated transform at a specific time.\r\n\t/// @param beta is a factor in [0,1], where 0 indicates alpha0.\r\n\tvoid GetTransform(b2Transform* xfb, float32 beta) const;\r\n\r\n\t/// Advance the sweep forward, yielding a new initial state.\r\n\t/// @param alpha the new initial time.\r\n\tvoid Advance(float32 alpha);\r\n\r\n\t/// Normalize the angles.\r\n\tvoid Normalize();\r\n\r\n\tb2Vec2 localCenter;\t///< local center of mass position\r\n\tb2Vec2 c0, c;\t\t///< center world positions\r\n\tfloat32 a0, a;\t\t///< world angles\r\n\r\n\t/// Fraction of the current time step in the range [0,1]\r\n\t/// c0 and a0 are the positions at alpha0.\r\n\tfloat32 alpha0;\r\n};\r\n\r\n/// Useful constant\r\nextern const b2Vec2 b2Vec2_zero;\r\n\r\n/// Perform the dot product on two vectors.\r\ninline float32 b2Dot(const b2Vec2& a, const b2Vec2& b)\r\n{\r\n\treturn a.x * b.x + a.y * b.y;\r\n}\r\n\r\n/// Perform the cross product on two vectors. In 2D this produces a scalar.\r\ninline float32 b2Cross(const b2Vec2& a, const b2Vec2& b)\r\n{\r\n\treturn a.x * b.y - a.y * b.x;\r\n}\r\n\r\n/// Perform the cross product on a vector and a scalar. In 2D this produces\r\n/// a vector.\r\ninline b2Vec2 b2Cross(const b2Vec2& a, float32 s)\r\n{\r\n\treturn b2Vec2(s * a.y, -s * a.x);\r\n}\r\n\r\n/// Perform the cross product on a scalar and a vector. In 2D this produces\r\n/// a vector.\r\ninline b2Vec2 b2Cross(float32 s, const b2Vec2& a)\r\n{\r\n\treturn b2Vec2(-s * a.y, s * a.x);\r\n}\r\n\r\n/// Multiply a matrix times a vector. If a rotation matrix is provided,\r\n/// then this transforms the vector from one frame to another.\r\ninline b2Vec2 b2Mul(const b2Mat22& A, const b2Vec2& v)\r\n{\r\n\treturn b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);\r\n}\r\n\r\n/// Multiply a matrix transpose times a vector. If a rotation matrix is provided,\r\n/// then this transforms the vector from one frame to another (inverse transform).\r\ninline b2Vec2 b2MulT(const b2Mat22& A, const b2Vec2& v)\r\n{\r\n\treturn b2Vec2(b2Dot(v, A.ex), b2Dot(v, A.ey));\r\n}\r\n\r\n/// Add two vectors component-wise.\r\ninline b2Vec2 operator + (const b2Vec2& a, const b2Vec2& b)\r\n{\r\n\treturn b2Vec2(a.x + b.x, a.y + b.y);\r\n}\r\n\r\n/// Subtract two vectors component-wise.\r\ninline b2Vec2 operator - (const b2Vec2& a, const b2Vec2& b)\r\n{\r\n\treturn b2Vec2(a.x - b.x, a.y - b.y);\r\n}\r\n\r\ninline b2Vec2 operator * (float32 s, const b2Vec2& a)\r\n{\r\n\treturn b2Vec2(s * a.x, s * a.y);\r\n}\r\n\r\ninline bool operator == (const b2Vec2& a, const b2Vec2& b)\r\n{\r\n\treturn a.x == b.x && a.y == b.y;\r\n}\r\n\r\ninline float32 b2Distance(const b2Vec2& a, const b2Vec2& b)\r\n{\r\n\tb2Vec2 c = a - b;\r\n\treturn c.Length();\r\n}\r\n\r\ninline float32 b2DistanceSquared(const b2Vec2& a, const b2Vec2& b)\r\n{\r\n\tb2Vec2 c = a - b;\r\n\treturn b2Dot(c, c);\r\n}\r\n\r\ninline b2Vec3 operator * (float32 s, const b2Vec3& a)\r\n{\r\n\treturn b2Vec3(s * a.x, s * a.y, s * a.z);\r\n}\r\n\r\n/// Add two vectors component-wise.\r\ninline b2Vec3 operator + (const b2Vec3& a, const b2Vec3& b)\r\n{\r\n\treturn b2Vec3(a.x + b.x, a.y + b.y, a.z + b.z);\r\n}\r\n\r\n/// Subtract two vectors component-wise.\r\ninline b2Vec3 operator - (const b2Vec3& a, const b2Vec3& b)\r\n{\r\n\treturn b2Vec3(a.x - b.x, a.y - b.y, a.z - b.z);\r\n}\r\n\r\n/// Perform the dot product on two vectors.\r\ninline float32 b2Dot(const b2Vec3& a, const b2Vec3& b)\r\n{\r\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\r\n}\r\n\r\n/// Perform the cross product on two vectors.\r\ninline b2Vec3 b2Cross(const b2Vec3& a, const b2Vec3& b)\r\n{\r\n\treturn b2Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\r\n}\r\n\r\ninline b2Mat22 operator + (const b2Mat22& A, const b2Mat22& B)\r\n{\r\n\treturn b2Mat22(A.ex + B.ex, A.ey + B.ey);\r\n}\r\n\r\n// A * B\r\ninline b2Mat22 b2Mul(const b2Mat22& A, const b2Mat22& B)\r\n{\r\n\treturn b2Mat22(b2Mul(A, B.ex), b2Mul(A, B.ey));\r\n}\r\n\r\n// A^T * B\r\ninline b2Mat22 b2MulT(const b2Mat22& A, const b2Mat22& B)\r\n{\r\n\tb2Vec2 c1(b2Dot(A.ex, B.ex), b2Dot(A.ey, B.ex));\r\n\tb2Vec2 c2(b2Dot(A.ex, B.ey), b2Dot(A.ey, B.ey));\r\n\treturn b2Mat22(c1, c2);\r\n}\r\n\r\n/// Multiply a matrix times a vector.\r\ninline b2Vec3 b2Mul(const b2Mat33& A, const b2Vec3& v)\r\n{\r\n\treturn v.x * A.ex + v.y * A.ey + v.z * A.ez;\r\n}\r\n\r\n/// Multiply a matrix times a vector.\r\ninline b2Vec2 b2Mul22(const b2Mat33& A, const b2Vec2& v)\r\n{\r\n\treturn b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);\r\n}\r\n\r\n/// Multiply two rotations: q * r\r\ninline b2Rot b2Mul(const b2Rot& q, const b2Rot& r)\r\n{\r\n\t// [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\r\n\t// [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]\r\n\t// s = qs * rc + qc * rs\r\n\t// c = qc * rc - qs * rs\r\n\tb2Rot qr;\r\n\tqr.s = q.s * r.c + q.c * r.s;\r\n\tqr.c = q.c * r.c - q.s * r.s;\r\n\treturn qr;\r\n}\r\n\r\n/// Transpose multiply two rotations: qT * r\r\ninline b2Rot b2MulT(const b2Rot& q, const b2Rot& r)\r\n{\r\n\t// [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\r\n\t// [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]\r\n\t// s = qc * rs - qs * rc\r\n\t// c = qc * rc + qs * rs\r\n\tb2Rot qr;\r\n\tqr.s = q.c * r.s - q.s * r.c;\r\n\tqr.c = q.c * r.c + q.s * r.s;\r\n\treturn qr;\r\n}\r\n\r\n/// Rotate a vector\r\ninline b2Vec2 b2Mul(const b2Rot& q, const b2Vec2& v)\r\n{\r\n\treturn b2Vec2(q.c * v.x - q.s * v.y, q.s * v.x + q.c * v.y);\r\n}\r\n\r\n/// Inverse rotate a vector\r\ninline b2Vec2 b2MulT(const b2Rot& q, const b2Vec2& v)\r\n{\r\n\treturn b2Vec2(q.c * v.x + q.s * v.y, -q.s * v.x + q.c * v.y);\r\n}\r\n\r\ninline b2Vec2 b2Mul(const b2Transform& T, const b2Vec2& v)\r\n{\r\n\tfloat32 x = (T.q.c * v.x - T.q.s * v.y) + T.p.x;\r\n\tfloat32 y = (T.q.s * v.x + T.q.c * v.y) + T.p.y;\r\n\r\n\treturn b2Vec2(x, y);\r\n}\r\n\r\ninline b2Vec2 b2MulT(const b2Transform& T, const b2Vec2& v)\r\n{\r\n\tfloat32 px = v.x - T.p.x;\r\n\tfloat32 py = v.y - T.p.y;\r\n\tfloat32 x = (T.q.c * px + T.q.s * py);\r\n\tfloat32 y = (-T.q.s * px + T.q.c * py);\r\n\r\n\treturn b2Vec2(x, y);\r\n}\r\n\r\n// v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p\r\n//    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p\r\ninline b2Transform b2Mul(const b2Transform& A, const b2Transform& B)\r\n{\r\n\tb2Transform C;\r\n\tC.q = b2Mul(A.q, B.q);\r\n\tC.p = b2Mul(A.q, B.p) + A.p;\r\n\treturn C;\r\n}\r\n\r\n// v2 = A.q' * (B.q * v1 + B.p - A.p)\r\n//    = A.q' * B.q * v1 + A.q' * (B.p - A.p)\r\ninline b2Transform b2MulT(const b2Transform& A, const b2Transform& B)\r\n{\r\n\tb2Transform C;\r\n\tC.q = b2MulT(A.q, B.q);\r\n\tC.p = b2MulT(A.q, B.p - A.p);\r\n\treturn C;\r\n}\r\n\r\ntemplate <typename T>\r\ninline T b2Abs(T a)\r\n{\r\n\treturn a > T(0) ? a : -a;\r\n}\r\n\r\ninline b2Vec2 b2Abs(const b2Vec2& a)\r\n{\r\n\treturn b2Vec2(b2Abs(a.x), b2Abs(a.y));\r\n}\r\n\r\ninline b2Mat22 b2Abs(const b2Mat22& A)\r\n{\r\n\treturn b2Mat22(b2Abs(A.ex), b2Abs(A.ey));\r\n}\r\n\r\ntemplate <typename T>\r\ninline T b2Min(T a, T b)\r\n{\r\n\treturn a < b ? a : b;\r\n}\r\n\r\ninline b2Vec2 b2Min(const b2Vec2& a, const b2Vec2& b)\r\n{\r\n\treturn b2Vec2(b2Min(a.x, b.x), b2Min(a.y, b.y));\r\n}\r\n\r\ntemplate <typename T>\r\ninline T b2Max(T a, T b)\r\n{\r\n\treturn a > b ? a : b;\r\n}\r\n\r\ninline b2Vec2 b2Max(const b2Vec2& a, const b2Vec2& b)\r\n{\r\n\treturn b2Vec2(b2Max(a.x, b.x), b2Max(a.y, b.y));\r\n}\r\n\r\ntemplate <typename T>\r\ninline T b2Clamp(T a, T low, T high)\r\n{\r\n\treturn b2Max(low, b2Min(a, high));\r\n}\r\n\r\ninline b2Vec2 b2Clamp(const b2Vec2& a, const b2Vec2& low, const b2Vec2& high)\r\n{\r\n\treturn b2Max(low, b2Min(a, high));\r\n}\r\n\r\ntemplate<typename T> inline void b2Swap(T& a, T& b)\r\n{\r\n\tT tmp = a;\r\n\ta = b;\r\n\tb = tmp;\r\n}\r\n\r\n/// \"Next Largest Power of 2\r\n/// Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm\r\n/// that recursively \"folds\" the upper bits into the lower bits. This process yields a bit vector with\r\n/// the same most significant 1 as x, but all 1's below it. Adding 1 to that value yields the next\r\n/// largest power of 2. For a 32-bit value:\"\r\ninline uint32 b2NextPowerOfTwo(uint32 x)\r\n{\r\n\tx |= (x >> 1);\r\n\tx |= (x >> 2);\r\n\tx |= (x >> 4);\r\n\tx |= (x >> 8);\r\n\tx |= (x >> 16);\r\n\treturn x + 1;\r\n}\r\n\r\ninline bool b2IsPowerOfTwo(uint32 x)\r\n{\r\n\tbool result = x > 0 && (x & (x - 1)) == 0;\r\n\treturn result;\r\n}\r\n\r\ninline void b2Sweep::GetTransform(b2Transform* xf, float32 beta) const\r\n{\r\n\txf->p = (1.0f - beta) * c0 + beta * c;\r\n\tfloat32 angle = (1.0f - beta) * a0 + beta * a;\r\n\txf->q.Set(angle);\r\n\r\n\t// Shift to origin\r\n\txf->p -= b2Mul(xf->q, localCenter);\r\n}\r\n\r\ninline void b2Sweep::Advance(float32 alpha)\r\n{\r\n\tb2Assert(alpha0 < 1.0f);\r\n\tfloat32 beta = (alpha - alpha0) / (1.0f - alpha0);\r\n\tc0 = (1.0f - beta) * c0 + beta * c;\r\n\ta0 = (1.0f - beta) * a0 + beta * a;\r\n\talpha0 = alpha;\r\n}\r\n\r\n/// Normalize an angle in radians to be between -pi and pi\r\ninline void b2Sweep::Normalize()\r\n{\r\n\tfloat32 twoPi = 2.0f * b2_pi;\r\n\tfloat32 d =  twoPi * floorf(a0 / twoPi);\r\n\ta0 -= d;\r\n\ta -= d;\r\n}\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_FIXTURE_H\r\n#define B2_FIXTURE_H\r\n\r\n#include <Box2D/Dynamics/b2Body.h>\r\n#include <Box2D/Collision/b2Collision.h>\r\n#include <Box2D/Collision/Shapes/b2Shape.h>\r\n\r\nclass b2BlockAllocator;\r\nclass b2Body;\r\nclass b2BroadPhase;\r\nclass b2Fixture;\r\n\r\n/// This holds contact filtering data.\r\nstruct b2Filter\r\n{\r\n\tb2Filter()\r\n\t{\r\n\t\tcategoryBits = 0x0001;\r\n\t\tmaskBits = 0xFFFF;\r\n\t\tgroupIndex = 0;\r\n\t}\r\n\r\n\t/// The collision category bits. Normally you would just set one bit.\r\n\tuint16 categoryBits;\r\n\r\n\t/// The collision mask bits. This states the categories that this\r\n\t/// shape would accept for collision.\r\n\tuint16 maskBits;\r\n\r\n\t/// Collision groups allow a certain group of objects to never collide (negative)\r\n\t/// or always collide (positive). Zero means no collision group. Non-zero group\r\n\t/// filtering always wins against the mask bits.\r\n\tint16 groupIndex;\r\n};\r\n\r\n/// A fixture definition is used to create a fixture. This class defines an\r\n/// abstract fixture definition. You can reuse fixture definitions safely.\r\nstruct b2FixtureDef\r\n{\r\n\t/// The constructor sets the default fixture definition values.\r\n\tb2FixtureDef()\r\n\t{\r\n\t\tshape = NULL;\r\n\t\tuserData = NULL;\r\n\t\tfriction = 0.2f;\r\n\t\trestitution = 0.0f;\r\n\t\tdensity = 0.0f;\r\n\t\tisSensor = false;\r\n\t}\r\n\r\n\t/// The shape, this must be set. The shape will be cloned, so you\r\n\t/// can create the shape on the stack.\r\n\tconst b2Shape* shape;\r\n\r\n\t/// Use this to store application specific fixture data.\r\n\tvoid* userData;\r\n\r\n\t/// The friction coefficient, usually in the range [0,1].\r\n\tfloat32 friction;\r\n\r\n\t/// The restitution (elasticity) usually in the range [0,1].\r\n\tfloat32 restitution;\r\n\r\n\t/// The density, usually in kg/m^2.\r\n\tfloat32 density;\r\n\r\n\t/// A sensor shape collects contact information but never generates a collision\r\n\t/// response.\r\n\tbool isSensor;\r\n\r\n\t/// Contact filtering data.\r\n\tb2Filter filter;\r\n};\r\n\r\n/// This proxy is used internally to connect fixtures to the broad-phase.\r\nstruct b2FixtureProxy\r\n{\r\n\tb2AABB aabb;\r\n\tb2Fixture* fixture;\r\n\tint32 childIndex;\r\n\tint32 proxyId;\r\n};\r\n\r\n/// A fixture is used to attach a shape to a body for collision detection. A fixture\r\n/// inherits its transform from its parent. Fixtures hold additional non-geometric data\r\n/// such as friction, collision filters, etc.\r\n/// Fixtures are created via b2Body::CreateFixture.\r\n/// @warning you cannot reuse fixtures.\r\nclass b2Fixture\r\n{\r\npublic:\r\n\t/// Get the type of the child shape. You can use this to down cast to the concrete shape.\r\n\t/// @return the shape type.\r\n\tb2Shape::Type GetType() const;\r\n\r\n\t/// Get the child shape. You can modify the child shape, however you should not change the\r\n\t/// number of vertices because this will crash some collision caching mechanisms.\r\n\t/// Manipulating the shape may lead to non-physical behavior.\r\n\tb2Shape* GetShape();\r\n\tconst b2Shape* GetShape() const;\r\n\r\n\t/// Set if this fixture is a sensor.\r\n\tvoid SetSensor(bool sensor);\r\n\r\n\t/// Is this fixture a sensor (non-solid)?\r\n\t/// @return the true if the shape is a sensor.\r\n\tbool IsSensor() const;\r\n\r\n\t/// Set the contact filtering data. This will not update contacts until the next time\r\n\t/// step when either parent body is active and awake.\r\n\t/// This automatically calls Refilter.\r\n\tvoid SetFilterData(const b2Filter& filter);\r\n\r\n\t/// Get the contact filtering data.\r\n\tconst b2Filter& GetFilterData() const;\r\n\r\n\t/// Call this if you want to establish collision that was previously disabled by b2ContactFilter::ShouldCollide.\r\n\tvoid Refilter();\r\n\r\n\t/// Get the parent body of this fixture. This is NULL if the fixture is not attached.\r\n\t/// @return the parent body.\r\n\tb2Body* GetBody();\r\n\tconst b2Body* GetBody() const;\r\n\r\n\t/// Get the next fixture in the parent body's fixture list.\r\n\t/// @return the next shape.\r\n\tb2Fixture* GetNext();\r\n\tconst b2Fixture* GetNext() const;\r\n\r\n\t/// Get the user data that was assigned in the fixture definition. Use this to\r\n\t/// store your application specific data.\r\n\tvoid* GetUserData() const;\r\n\r\n\t/// Set the user data. Use this to store your application specific data.\r\n\tvoid SetUserData(void* data);\r\n\r\n\t/// Test a point for containment in this fixture.\r\n\t/// @param p a point in world coordinates.\r\n\tbool TestPoint(const b2Vec2& p) const;\r\n\r\n\t/// Cast a ray against this shape.\r\n\t/// @param output the ray-cast results.\r\n\t/// @param input the ray-cast input parameters.\r\n\tbool RayCast(b2RayCastOutput* output, const b2RayCastInput& input, int32 childIndex) const;\r\n\r\n\t/// Get the mass data for this fixture. The mass data is based on the density and\r\n\t/// the shape. The rotational inertia is about the shape's origin. This operation\r\n\t/// may be expensive.\r\n\tvoid GetMassData(b2MassData* massData) const;\r\n\r\n\t/// Set the density of this fixture. This will _not_ automatically adjust the mass\r\n\t/// of the body. You must call b2Body::ResetMassData to update the body's mass.\r\n\tvoid SetDensity(float32 density);\r\n\r\n\t/// Get the density of this fixture.\r\n\tfloat32 GetDensity() const;\r\n\r\n\t/// Get the coefficient of friction.\r\n\tfloat32 GetFriction() const;\r\n\r\n\t/// Set the coefficient of friction. This will _not_ change the friction of\r\n\t/// existing contacts.\r\n\tvoid SetFriction(float32 friction);\r\n\r\n\t/// Get the coefficient of restitution.\r\n\tfloat32 GetRestitution() const;\r\n\r\n\t/// Set the coefficient of restitution. This will _not_ change the restitution of\r\n\t/// existing contacts.\r\n\tvoid SetRestitution(float32 restitution);\r\n\r\n\t/// Get the fixture's AABB. This AABB may be enlarge and/or stale.\r\n\t/// If you need a more accurate AABB, compute it using the shape and\r\n\t/// the body transform.\r\n\tconst b2AABB& GetAABB(int32 childIndex) const;\r\n\r\n\t/// Dump this fixture to the log file.\r\n\tvoid Dump(int32 bodyIndex);\r\n\r\nprotected:\r\n\r\n\tfriend class b2Body;\r\n\tfriend class b2World;\r\n\tfriend class b2Contact;\r\n\tfriend class b2ContactManager;\r\n\r\n\tb2Fixture();\r\n\r\n\t// We need separation create/destroy functions from the constructor/destructor because\r\n\t// the destructor cannot access the allocator (no destructor arguments allowed by C++).\r\n\tvoid Create(b2BlockAllocator* allocator, b2Body* body, const b2FixtureDef* def);\r\n\tvoid Destroy(b2BlockAllocator* allocator);\r\n\r\n\t// These support body activation/deactivation.\r\n\tvoid CreateProxies(b2BroadPhase* broadPhase, const b2Transform& xf);\r\n\tvoid DestroyProxies(b2BroadPhase* broadPhase);\r\n\r\n\tvoid Synchronize(b2BroadPhase* broadPhase, const b2Transform& xf1, const b2Transform& xf2);\r\n\r\n\tfloat32 m_density;\r\n\r\n\tb2Fixture* m_next;\r\n\tb2Body* m_body;\r\n\r\n\tb2Shape* m_shape;\r\n\r\n\tfloat32 m_friction;\r\n\tfloat32 m_restitution;\r\n\r\n\tb2FixtureProxy* m_proxies;\r\n\tint32 m_proxyCount;\r\n\r\n\tb2Filter m_filter;\r\n\r\n\tbool m_isSensor;\r\n\r\n\tvoid* m_userData;\r\n};\r\n\r\ninline b2Shape::Type b2Fixture::GetType() const\r\n{\r\n\treturn m_shape->GetType();\r\n}\r\n\r\ninline b2Shape* b2Fixture::GetShape()\r\n{\r\n\treturn m_shape;\r\n}\r\n\r\ninline const b2Shape* b2Fixture::GetShape() const\r\n{\r\n\treturn m_shape;\r\n}\r\n\r\ninline bool b2Fixture::IsSensor() const\r\n{\r\n\treturn m_isSensor;\r\n}\r\n\r\ninline const b2Filter& b2Fixture::GetFilterData() const\r\n{\r\n\treturn m_filter;\r\n}\r\n\r\ninline void* b2Fixture::GetUserData() const\r\n{\r\n\treturn m_userData;\r\n}\r\n\r\ninline void b2Fixture::SetUserData(void* data)\r\n{\r\n\tm_userData = data;\r\n}\r\n\r\ninline b2Body* b2Fixture::GetBody()\r\n{\r\n\treturn m_body;\r\n}\r\n\r\ninline const b2Body* b2Fixture::GetBody() const\r\n{\r\n\treturn m_body;\r\n}\r\n\r\ninline b2Fixture* b2Fixture::GetNext()\r\n{\r\n\treturn m_next;\r\n}\r\n\r\ninline const b2Fixture* b2Fixture::GetNext() const\r\n{\r\n\treturn m_next;\r\n}\r\n\r\ninline void b2Fixture::SetDensity(float32 density)\r\n{\r\n\tb2Assert(b2IsValid(density) && density >= 0.0f);\r\n\tm_density = density;\r\n}\r\n\r\ninline float32 b2Fixture::GetDensity() const\r\n{\r\n\treturn m_density;\r\n}\r\n\r\ninline float32 b2Fixture::GetFriction() const\r\n{\r\n\treturn m_friction;\r\n}\r\n\r\ninline void b2Fixture::SetFriction(float32 friction)\r\n{\r\n\tm_friction = friction;\r\n}\r\n\r\ninline float32 b2Fixture::GetRestitution() const\r\n{\r\n\treturn m_restitution;\r\n}\r\n\r\ninline void b2Fixture::SetRestitution(float32 restitution)\r\n{\r\n\tm_restitution = restitution;\r\n}\r\n\r\ninline bool b2Fixture::TestPoint(const b2Vec2& p) const\r\n{\r\n\treturn m_shape->TestPoint(m_body->GetTransform(), p);\r\n}\r\n\r\ninline bool b2Fixture::RayCast(b2RayCastOutput* output, const b2RayCastInput& input, int32 childIndex) const\r\n{\r\n\treturn m_shape->RayCast(output, input, m_body->GetTransform(), childIndex);\r\n}\r\n\r\ninline void b2Fixture::GetMassData(b2MassData* massData) const\r\n{\r\n\tm_shape->ComputeMass(massData, m_density);\r\n}\r\n\r\ninline const b2AABB& b2Fixture::GetAABB(int32 childIndex) const\r\n{\r\n\tb2Assert(0 <= childIndex && childIndex < m_proxyCount);\r\n\treturn m_proxies[childIndex].aabb;\r\n}\r\n\r\n#endif\r\n","// -*- C++ -*-\n//===---------------------------- cmath -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_CMATH\n#define _LIBCPP_CMATH\n\n/*\n    cmath synopsis\n\nMacros:\n\n    HUGE_VAL\n    HUGE_VALF               // C99\n    HUGE_VALL               // C99\n    INFINITY                // C99\n    NAN                     // C99\n    FP_INFINITE             // C99\n    FP_NAN                  // C99\n    FP_NORMAL               // C99\n    FP_SUBNORMAL            // C99\n    FP_ZERO                 // C99\n    FP_FAST_FMA             // C99\n    FP_FAST_FMAF            // C99\n    FP_FAST_FMAL            // C99\n    FP_ILOGB0               // C99\n    FP_ILOGBNAN             // C99\n    MATH_ERRNO              // C99\n    MATH_ERREXCEPT          // C99\n    math_errhandling        // C99\n\nnamespace std\n{\n\nTypes:\n\n    float_t                 // C99\n    double_t                // C99\n\n// C90\n\nfloating_point abs(floating_point x);\n\nfloating_point acos (arithmetic x);\nfloat          acosf(float x);\nlong double    acosl(long double x);\n\nfloating_point asin (arithmetic x);\nfloat          asinf(float x);\nlong double    asinl(long double x);\n\nfloating_point atan (arithmetic x);\nfloat          atanf(float x);\nlong double    atanl(long double x);\n\nfloating_point atan2 (arithmetic y, arithmetic x);\nfloat          atan2f(float y, float x);\nlong double    atan2l(long double y, long double x);\n\nfloating_point ceil (arithmetic x);\nfloat          ceilf(float x);\nlong double    ceill(long double x);\n\nfloating_point cos (arithmetic x);\nfloat          cosf(float x);\nlong double    cosl(long double x);\n\nfloating_point cosh (arithmetic x);\nfloat          coshf(float x);\nlong double    coshl(long double x);\n\nfloating_point exp (arithmetic x);\nfloat          expf(float x);\nlong double    expl(long double x);\n\nfloating_point fabs (arithmetic x);\nfloat          fabsf(float x);\nlong double    fabsl(long double x);\n\nfloating_point floor (arithmetic x);\nfloat          floorf(float x);\nlong double    floorl(long double x);\n\nfloating_point fmod (arithmetic x, arithmetic y);\nfloat          fmodf(float x, float y);\nlong double    fmodl(long double x, long double y);\n\nfloating_point frexp (arithmetic value, int* exp);\nfloat          frexpf(float value, int* exp);\nlong double    frexpl(long double value, int* exp);\n\nfloating_point ldexp (arithmetic value, int exp);\nfloat          ldexpf(float value, int exp);\nlong double    ldexpl(long double value, int exp);\n\nfloating_point log (arithmetic x);\nfloat          logf(float x);\nlong double    logl(long double x);\n\nfloating_point log10 (arithmetic x);\nfloat          log10f(float x);\nlong double    log10l(long double x);\n\nfloating_point modf (floating_point value, floating_point* iptr);\nfloat          modff(float value, float* iptr);\nlong double    modfl(long double value, long double* iptr);\n\nfloating_point pow (arithmetic x, arithmetic y);\nfloat          powf(float x, float y);\nlong double    powl(long double x, long double y);\n\nfloating_point sin (arithmetic x);\nfloat          sinf(float x);\nlong double    sinl(long double x);\n\nfloating_point sinh (arithmetic x);\nfloat          sinhf(float x);\nlong double    sinhl(long double x);\n\nfloating_point sqrt (arithmetic x);\nfloat          sqrtf(float x);\nlong double    sqrtl(long double x);\n\nfloating_point tan (arithmetic x);\nfloat          tanf(float x);\nlong double    tanl(long double x);\n\nfloating_point tanh (arithmetic x);\nfloat          tanhf(float x);\nlong double    tanhl(long double x);\n\n//  C99\n\nbool signbit(arithmetic x);\n\nint fpclassify(arithmetic x);\n\nbool isfinite(arithmetic x);\nbool isinf(arithmetic x);\nbool isnan(arithmetic x);\nbool isnormal(arithmetic x);\n\nbool isgreater(arithmetic x, arithmetic y);\nbool isgreaterequal(arithmetic x, arithmetic y);\nbool isless(arithmetic x, arithmetic y);\nbool islessequal(arithmetic x, arithmetic y);\nbool islessgreater(arithmetic x, arithmetic y);\nbool isunordered(arithmetic x, arithmetic y);\n\nfloating_point acosh (arithmetic x);\nfloat          acoshf(float x);\nlong double    acoshl(long double x);\n\nfloating_point asinh (arithmetic x);\nfloat          asinhf(float x);\nlong double    asinhl(long double x);\n\nfloating_point atanh (arithmetic x);\nfloat          atanhf(float x);\nlong double    atanhl(long double x);\n\nfloating_point cbrt (arithmetic x);\nfloat          cbrtf(float x);\nlong double    cbrtl(long double x);\n\nfloating_point copysign (arithmetic x, arithmetic y);\nfloat          copysignf(float x, float y);\nlong double    copysignl(long double x, long double y);\n\nfloating_point erf (arithmetic x);\nfloat          erff(float x);\nlong double    erfl(long double x);\n\nfloating_point erfc (arithmetic x);\nfloat          erfcf(float x);\nlong double    erfcl(long double x);\n\nfloating_point exp2 (arithmetic x);\nfloat          exp2f(float x);\nlong double    exp2l(long double x);\n\nfloating_point expm1 (arithmetic x);\nfloat          expm1f(float x);\nlong double    expm1l(long double x);\n\nfloating_point fdim (arithmetic x, arithmetic y);\nfloat          fdimf(float x, float y);\nlong double    fdiml(long double x, long double y);\n\nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);\nfloat          fmaf(float x, float y, float z);\nlong double    fmal(long double x, long double y, long double z);\n\nfloating_point fmax (arithmetic x, arithmetic y);\nfloat          fmaxf(float x, float y);\nlong double    fmaxl(long double x, long double y);\n\nfloating_point fmin (arithmetic x, arithmetic y);\nfloat          fminf(float x, float y);\nlong double    fminl(long double x, long double y);\n\nfloating_point hypot (arithmetic x, arithmetic y);\nfloat          hypotf(float x, float y);\nlong double    hypotl(long double x, long double y);\n\nint ilogb (arithmetic x);\nint ilogbf(float x);\nint ilogbl(long double x);\n\nfloating_point lgamma (arithmetic x);\nfloat          lgammaf(float x);\nlong double    lgammal(long double x);\n\nlong long llrint (arithmetic x);\nlong long llrintf(float x);\nlong long llrintl(long double x);\n\nlong long llround (arithmetic x);\nlong long llroundf(float x);\nlong long llroundl(long double x);\n\nfloating_point log1p (arithmetic x);\nfloat          log1pf(float x);\nlong double    log1pl(long double x);\n\nfloating_point log2 (arithmetic x);\nfloat          log2f(float x);\nlong double    log2l(long double x);\n\nfloating_point logb (arithmetic x);\nfloat          logbf(float x);\nlong double    logbl(long double x);\n\nlong lrint (arithmetic x);\nlong lrintf(float x);\nlong lrintl(long double x);\n\nlong lround (arithmetic x);\nlong lroundf(float x);\nlong lroundl(long double x);\n\ndouble      nan (const char* str);\nfloat       nanf(const char* str);\nlong double nanl(const char* str);\n\nfloating_point nearbyint (arithmetic x);\nfloat          nearbyintf(float x);\nlong double    nearbyintl(long double x);\n\nfloating_point nextafter (arithmetic x, arithmetic y);\nfloat          nextafterf(float x, float y);\nlong double    nextafterl(long double x, long double y);\n\nfloating_point nexttoward (arithmetic x, long double y);\nfloat          nexttowardf(float x, long double y);\nlong double    nexttowardl(long double x, long double y);\n\nfloating_point remainder (arithmetic x, arithmetic y);\nfloat          remainderf(float x, float y);\nlong double    remainderl(long double x, long double y);\n\nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);\nfloat          remquof(float x, float y, int* pquo);\nlong double    remquol(long double x, long double y, int* pquo);\n\nfloating_point rint (arithmetic x);\nfloat          rintf(float x);\nlong double    rintl(long double x);\n\nfloating_point round (arithmetic x);\nfloat          roundf(float x);\nlong double    roundl(long double x);\n\nfloating_point scalbln (arithmetic x, long ex);\nfloat          scalblnf(float x, long ex);\nlong double    scalblnl(long double x, long ex);\n\nfloating_point scalbn (arithmetic x, int ex);\nfloat          scalbnf(float x, int ex);\nlong double    scalbnl(long double x, int ex);\n\nfloating_point tgamma (arithmetic x);\nfloat          tgammaf(float x);\nlong double    tgammal(long double x);\n\nfloating_point trunc (arithmetic x);\nfloat          truncf(float x);\nlong double    truncl(long double x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <math.h>\n#include <type_traits>\n\n#ifdef _LIBCPP_MSVCRT\n#include \"support/win32/math_win32.h\"\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n// signbit\n\n#ifdef signbit\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return signbit(__lcpp_x);\n}\n\n#undef signbit\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // signbit\n\n// fpclassify\n\n#ifdef fpclassify\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nint\n__libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return fpclassify(__lcpp_x);\n}\n\n#undef fpclassify\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // fpclassify\n\n// isfinite\n\n#ifdef isfinite\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isfinite(__lcpp_x);\n}\n\n#undef isfinite\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isfinite\n\n// isinf\n\n#ifdef isinf\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isinf(__lcpp_x);\n}\n\n#undef isinf\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isinf\n\n// isnan\n\n#ifdef isnan\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnan(__lcpp_x);\n}\n\n#undef isnan\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnan\n\n// isnormal\n\n#ifdef isnormal\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnormal(__lcpp_x);\n}\n\n#undef isnormal\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnormal\n\n// isgreater\n\n#ifdef isgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreater\n\n// isgreaterequal\n\n#ifdef isgreaterequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreaterequal(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreaterequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreaterequal\n\n// isless\n\n#ifdef isless\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isless(__lcpp_x, __lcpp_y);\n}\n\n#undef isless\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isless\n\n// islessequal\n\n#ifdef islessequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessequal(__lcpp_x, __lcpp_y);\n}\n\n#undef islessequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessequal\n\n// islessgreater\n\n#ifdef islessgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef islessgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessgreater\n\n// isunordered\n\n#ifdef isunordered\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isunordered(__lcpp_x, __lcpp_y);\n}\n\n#undef isunordered\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isunordered\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nusing ::signbit;\nusing ::fpclassify;\nusing ::isfinite;\nusing ::isinf;\nusing ::isnan;\nusing ::isnormal;\nusing ::isgreater;\nusing ::isgreaterequal;\nusing ::isless;\nusing ::islessequal;\nusing ::islessgreater;\nusing ::isunordered;\nusing ::isunordered;\n\nusing ::float_t;\nusing ::double_t;\n\n// abs\n\n#if !defined(_AIX)\ninline _LIBCPP_INLINE_VISIBILITY\nfloat\nabs(float __lcpp_x) _NOEXCEPT {return fabsf(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\ndouble\nabs(double __lcpp_x) _NOEXCEPT {return fabs(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong double\nabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif // !defined(_AIX)\n\n#ifndef __sun__\n\n// acos\n\nusing ::acos;\nusing ::acosf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return acosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return acosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nacos(_A1 __lcpp_x) _NOEXCEPT {return acos((double)__lcpp_x);}\n\n// asin\n\nusing ::asin;\nusing ::asinf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return asinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return asinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nasin(_A1 __lcpp_x) _NOEXCEPT {return asin((double)__lcpp_x);}\n\n// atan\n\nusing ::atan;\nusing ::atanf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __lcpp_x) _NOEXCEPT       {return atanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __lcpp_x) _NOEXCEPT {return atanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\natan(_A1 __lcpp_x) _NOEXCEPT {return atan((double)__lcpp_x);}\n\n// atan2\n\nusing ::atan2;\nusing ::atan2f;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __lcpp_y, float __lcpp_x) _NOEXCEPT             {return atan2f(__lcpp_y, __lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __lcpp_y, long double __lcpp_x) _NOEXCEPT {return atan2l(__lcpp_y, __lcpp_x);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\natan2(_A1 __lcpp_y, _A2 __lcpp_x) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);\n}\n\n// ceil\n\nusing ::ceil;\nusing ::ceilf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __lcpp_x) _NOEXCEPT       {return ceilf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __lcpp_x) _NOEXCEPT {return ceill(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nceil(_A1 __lcpp_x) _NOEXCEPT {return ceil((double)__lcpp_x);}\n\n// cos\n\nusing ::cos;\nusing ::cosf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __lcpp_x) _NOEXCEPT       {return cosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __lcpp_x) _NOEXCEPT {return cosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncos(_A1 __lcpp_x) _NOEXCEPT {return cos((double)__lcpp_x);}\n\n// cosh\n\nusing ::cosh;\nusing ::coshf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __lcpp_x) _NOEXCEPT       {return coshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __lcpp_x) _NOEXCEPT {return coshl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncosh(_A1 __lcpp_x) _NOEXCEPT {return cosh((double)__lcpp_x);}\n\n#endif // __sun__\n// exp\n\nusing ::exp;\nusing ::expf;\n\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __lcpp_x) _NOEXCEPT       {return expf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __lcpp_x) _NOEXCEPT {return expl(__lcpp_x);}\n#endif\n\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexp(_A1 __lcpp_x) _NOEXCEPT {return exp((double)__lcpp_x);}\n\n// fabs\n\nusing ::fabs;\nusing ::fabsf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __lcpp_x) _NOEXCEPT       {return fabsf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfabs(_A1 __lcpp_x) _NOEXCEPT {return fabs((double)__lcpp_x);}\n\n// floor\n\nusing ::floor;\nusing ::floorf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __lcpp_x) _NOEXCEPT       {return floorf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __lcpp_x) _NOEXCEPT {return floorl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfloor(_A1 __lcpp_x) _NOEXCEPT {return floor((double)__lcpp_x);}\n\n// fmod\n\n#endif //__sun__\nusing ::fmod;\nusing ::fmodf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmodf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmodl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmod(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n\n// frexp\n\nusing ::frexp;\nusing ::frexpf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __lcpp_x, int* __lcpp_e) _NOEXCEPT       {return frexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfrexp(_A1 __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexp((double)__lcpp_x, __lcpp_e);}\n\n// ldexp\n\nusing ::ldexp;\nusing ::ldexpf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __lcpp_x, int __lcpp_e) _NOEXCEPT       {return ldexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nldexp(_A1 __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexp((double)__lcpp_x, __lcpp_e);}\n\n// log\n\n#endif // __sun__\nusing ::log;\nusing ::logf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       log(float __lcpp_x) _NOEXCEPT       {return logf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __lcpp_x) _NOEXCEPT {return logl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog(_A1 __lcpp_x) _NOEXCEPT {return log((double)__lcpp_x);}\n\n\n// log10\n\nusing ::log10;\nusing ::log10f;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __lcpp_x) _NOEXCEPT       {return log10f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __lcpp_x) _NOEXCEPT {return log10l(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog10(_A1 __lcpp_x) _NOEXCEPT {return log10((double)__lcpp_x);}\n\n// modf\n\nusing ::modf;\nusing ::modff;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __lcpp_x, float* __lcpp_y) _NOEXCEPT             {return modff(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __lcpp_x, long double* __lcpp_y) _NOEXCEPT {return modfl(__lcpp_x, __lcpp_y);}\n#endif\n\n// pow\n\n#endif // __sun__ \nusing ::pow;\nusing ::powf;\n\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return powf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return powl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\npow(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// sin\n\nusing ::sin;\nusing ::sinf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __lcpp_x) _NOEXCEPT       {return sinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __lcpp_x) _NOEXCEPT {return sinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsin(_A1 __lcpp_x) _NOEXCEPT {return sin((double)__lcpp_x);}\n\n// sinh\n\nusing ::sinh;\nusing ::sinhf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __lcpp_x) _NOEXCEPT       {return sinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __lcpp_x) _NOEXCEPT {return sinhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsinh(_A1 __lcpp_x) _NOEXCEPT {return sinh((double)__lcpp_x);}\n\n// sqrt\n\n#endif // __sun__\nusing ::sqrt;\nusing ::sqrtf;\n\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(__sun__) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return sqrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return sqrtl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsqrt(_A1 __lcpp_x) _NOEXCEPT {return sqrt((double)__lcpp_x);}\n\n// tan\n\nusing ::tan;\nusing ::tanf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return tanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return tanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntan(_A1 __lcpp_x) _NOEXCEPT {return tan((double)__lcpp_x);}\n\n// tanh\n\nusing ::tanh;\nusing ::tanhf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return tanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return tanhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntanh(_A1 __lcpp_x) _NOEXCEPT {return tanh((double)__lcpp_x);}\n\n// acosh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::acosh;\nusing ::acoshf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __lcpp_x) _NOEXCEPT       {return acoshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __lcpp_x) _NOEXCEPT {return acoshl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nacosh(_A1 __lcpp_x) _NOEXCEPT {return acosh((double)__lcpp_x);}\n#endif\n\n// asinh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::asinh;\nusing ::asinhf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return asinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return asinhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nasinh(_A1 __lcpp_x) _NOEXCEPT {return asinh((double)__lcpp_x);}\n#endif\n\n// atanh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::atanh;\nusing ::atanhf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __lcpp_x) _NOEXCEPT       {return atanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __lcpp_x) _NOEXCEPT {return atanhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\natanh(_A1 __lcpp_x) _NOEXCEPT {return atanh((double)__lcpp_x);}\n#endif\n\n// cbrt\n\n#ifndef _LIBCPP_MSVCRT\nusing ::cbrt;\nusing ::cbrtf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __lcpp_x) _NOEXCEPT       {return cbrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __lcpp_x) _NOEXCEPT {return cbrtl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncbrt(_A1 __lcpp_x) _NOEXCEPT {return cbrt((double)__lcpp_x);}\n#endif\n\n// copysign\n\nusing ::copysign;\nusing ::copysignf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       copysign(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return copysignf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double copysign(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return copysignl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\ncopysign(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n#ifndef _LIBCPP_MSVCRT\n\n// erf\n\nusing ::erf;\nusing ::erff;\n\ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __lcpp_x) _NOEXCEPT       {return erff(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __lcpp_x) _NOEXCEPT {return erfl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nerf(_A1 __lcpp_x) _NOEXCEPT {return erf((double)__lcpp_x);}\n\n// erfc\n\nusing ::erfc;\nusing ::erfcf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __lcpp_x) _NOEXCEPT       {return erfcf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __lcpp_x) _NOEXCEPT {return erfcl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nerfc(_A1 __lcpp_x) _NOEXCEPT {return erfc((double)__lcpp_x);}\n\n// exp2\n\nusing ::exp2;\nusing ::exp2f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __lcpp_x) _NOEXCEPT       {return exp2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __lcpp_x) _NOEXCEPT {return exp2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexp2(_A1 __lcpp_x) _NOEXCEPT {return exp2((double)__lcpp_x);}\n\n// expm1\n\nusing ::expm1;\nusing ::expm1f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __lcpp_x) _NOEXCEPT       {return expm1f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __lcpp_x) _NOEXCEPT {return expm1l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexpm1(_A1 __lcpp_x) _NOEXCEPT {return expm1((double)__lcpp_x);}\n\n// fdim\n\nusing ::fdim;\nusing ::fdimf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fdimf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fdiml(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfdim(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fma\n\nusing ::fmaf;\nusing ::fma;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) _NOEXCEPT                   {return fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) _NOEXCEPT {return fmal(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2, class _A3>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value &&\n    is_arithmetic<_A3>::value,\n    typename __promote<_A1, _A2, _A3>::type\n>::type\nfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2, _A3>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value &&\n                      is_same<_A3, __result_type>::value)), \"\");\n    return fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);\n}\n\n// fmax\n\nusing ::fmax;\nusing ::fmaxf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmaxf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmaxl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmax(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fmin\n\nusing ::fmin;\nusing ::fminf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fminf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fminl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmin(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// hypot\n\nusing ::hypot;\nusing ::hypotf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return hypotf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return hypotl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nhypot(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// ilogb\n\nusing ::ilogb;\nusing ::ilogbf;\n\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __lcpp_x) _NOEXCEPT       {return ilogbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __lcpp_x) _NOEXCEPT {return ilogbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, int>::type\nilogb(_A1 __lcpp_x) _NOEXCEPT {return ilogb((double)__lcpp_x);}\n\n// lgamma\n\nusing ::lgamma;\nusing ::lgammaf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __lcpp_x) _NOEXCEPT       {return lgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __lcpp_x) _NOEXCEPT {return lgammal(__lcpp_x);}\n\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlgamma(_A1 __lcpp_x) _NOEXCEPT {return lgamma((double)__lcpp_x);}\n\n\n// llrint\n\nusing ::llrint;\nusing ::llrintf;\n\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __lcpp_x) _NOEXCEPT       {return llrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __lcpp_x) _NOEXCEPT {return llrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long long>::type\nllrint(_A1 __lcpp_x) _NOEXCEPT {return llrint((double)__lcpp_x);}\n\n// llround\n\nusing ::llround;\nusing ::llroundf;\n\ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __lcpp_x) _NOEXCEPT       {return llroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __lcpp_x) _NOEXCEPT {return llroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long long>::type\nllround(_A1 __lcpp_x) _NOEXCEPT {return llround((double)__lcpp_x);}\n\n// log1p\n\nusing ::log1p;\nusing ::log1pf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __lcpp_x) _NOEXCEPT       {return log1pf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __lcpp_x) _NOEXCEPT {return log1pl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog1p(_A1 __lcpp_x) _NOEXCEPT {return log1p((double)__lcpp_x);}\n\n// log2\n\nusing ::log2;\nusing ::log2f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __lcpp_x) _NOEXCEPT       {return log2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __lcpp_x) _NOEXCEPT {return log2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog2(_A1 __lcpp_x) _NOEXCEPT {return log2((double)__lcpp_x);}\n\n// logb\n\nusing ::logb;\nusing ::logbf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __lcpp_x) _NOEXCEPT       {return logbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __lcpp_x) _NOEXCEPT {return logbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlogb(_A1 __lcpp_x) _NOEXCEPT {return logb((double)__lcpp_x);}\n\n// lrint\n\nusing ::lrint;\nusing ::lrintf;\n\ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __lcpp_x) _NOEXCEPT       {return lrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __lcpp_x) _NOEXCEPT {return lrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long>::type\nlrint(_A1 __lcpp_x) _NOEXCEPT {return lrint((double)__lcpp_x);}\n\n// lround\n\nusing ::lround;\nusing ::lroundf;\n\ninline _LIBCPP_INLINE_VISIBILITY long lround(float __lcpp_x) _NOEXCEPT       {return lroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __lcpp_x) _NOEXCEPT {return lroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long>::type\nlround(_A1 __lcpp_x) _NOEXCEPT {return lround((double)__lcpp_x);}\n\n#endif // _LIBCPP_MSVCRT\n#endif // __sun__\n\n// nan\n\n#ifndef _LIBCPP_MSVCRT\nusing ::nan;\nusing ::nanf;\n#endif // _LIBCPP_MSVCRT\n\n#ifndef __sun__\n#ifndef _LIBCPP_MSVCRT\n\n// nearbyint\n\nusing ::nearbyint;\nusing ::nearbyintf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __lcpp_x) _NOEXCEPT       {return nearbyintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __lcpp_x) _NOEXCEPT {return nearbyintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nnearbyint(_A1 __lcpp_x) _NOEXCEPT {return nearbyint((double)__lcpp_x);}\n\n// nextafter\n\nusing ::nextafter;\nusing ::nextafterf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return nextafterf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nextafterl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nnextafter(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// nexttoward\n\nusing ::nexttoward;\nusing ::nexttowardf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __lcpp_x, long double __lcpp_y) _NOEXCEPT       {return nexttowardf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttowardl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nnexttoward(_A1 __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttoward((double)__lcpp_x, __lcpp_y);}\n\n// remainder\n\nusing ::remainder;\nusing ::remainderf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return remainderf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return remainderl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nremainder(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// remquo\n\nusing ::remquo;\nusing ::remquof;\n\ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) _NOEXCEPT             {return remquof(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) _NOEXCEPT {return remquol(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);\n}\n\n// rint\n\nusing ::rint;\nusing ::rintf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __lcpp_x) _NOEXCEPT       {return rintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __lcpp_x) _NOEXCEPT {return rintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nrint(_A1 __lcpp_x) _NOEXCEPT {return rint((double)__lcpp_x);}\n\n// round\n\nusing ::round;\nusing ::roundf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return roundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return roundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nround(_A1 __lcpp_x) _NOEXCEPT {return round((double)__lcpp_x);}\n\n// scalbln\n\nusing ::scalbln;\nusing ::scalblnf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return scalblnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalblnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nscalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalbln((double)__lcpp_x, __lcpp_y);}\n\n// scalbn\n\nusing ::scalbn;\nusing ::scalbnf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return scalbnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nscalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbn((double)__lcpp_x, __lcpp_y);}\n\n// tgamma\n\nusing ::tgamma;\nusing ::tgammaf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return tgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return tgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntgamma(_A1 __lcpp_x) _NOEXCEPT {return tgamma((double)__lcpp_x);}\n\n// trunc\n\nusing ::trunc;\nusing ::truncf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return truncf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return truncl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntrunc(_A1 __lcpp_x) _NOEXCEPT {return trunc((double)__lcpp_x);}\n\n#endif // !_LIBCPP_MSVCRT\n\nusing ::acosl;\nusing ::asinl;\nusing ::atanl;\nusing ::atan2l;\nusing ::ceill;\nusing ::cosl;\nusing ::coshl;\nusing ::expl;\nusing ::fabsl;\nusing ::floorl;\nusing ::fmodl;\nusing ::frexpl;\nusing ::ldexpl;\nusing ::logl;\nusing ::log10l;\nusing ::modfl;\nusing ::powl;\nusing ::sinl;\nusing ::sinhl;\nusing ::sqrtl;\nusing ::tanl;\n#ifndef _LIBCPP_MSVCRT\nusing ::tanhl;\nusing ::acoshl;\nusing ::asinhl;\nusing ::atanhl;\nusing ::cbrtl;\n#endif  // !_LIBCPP_MSVCRT\nusing ::copysignl;\n#ifndef _LIBCPP_MSVCRT\nusing ::erfl;\nusing ::erfcl;\nusing ::exp2l;\nusing ::expm1l;\nusing ::fdiml;\nusing ::fmal;\nusing ::fmaxl;\nusing ::fminl;\nusing ::hypotl;\nusing ::ilogbl;\nusing ::lgammal;\nusing ::llrintl;\nusing ::llroundl;\nusing ::log1pl;\nusing ::log2l;\nusing ::logbl;\nusing ::lrintl;\nusing ::lroundl;\nusing ::nanl;\nusing ::nearbyintl;\nusing ::nextafterl;\nusing ::nexttowardl;\nusing ::remainderl;\nusing ::remquol;\nusing ::rintl;\nusing ::roundl;\nusing ::scalblnl;\nusing ::scalbnl;\nusing ::tgammal;\nusing ::truncl;\n#endif // !_LIBCPP_MSVCRT\n\n#else \nusing ::lgamma;\nusing ::lgammaf;\n#endif // __sun__\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_CMATH\n","/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_BODY_H\r\n#define B2_BODY_H\r\n\r\n#include <Box2D/Common/b2Math.h>\r\n#include <Box2D/Collision/Shapes/b2Shape.h>\r\n#include <memory>\r\n\r\nclass b2Fixture;\r\nclass b2Joint;\r\nclass b2Contact;\r\nclass b2Controller;\r\nclass b2World;\r\nstruct b2FixtureDef;\r\nstruct b2JointEdge;\r\nstruct b2ContactEdge;\r\n\r\n/// The body type.\r\n/// static: zero mass, zero velocity, may be manually moved\r\n/// kinematic: zero mass, non-zero velocity set by user, moved by solver\r\n/// dynamic: positive mass, non-zero velocity determined by forces, moved by solver\r\nenum b2BodyType\r\n{\r\n\tb2_staticBody = 0,\r\n\tb2_kinematicBody,\r\n\tb2_dynamicBody\r\n\r\n\t// TODO_ERIN\r\n\t//b2_bulletBody,\r\n};\r\n\r\n/// A body definition holds all the data needed to construct a rigid body.\r\n/// You can safely re-use body definitions. Shapes are added to a body after construction.\r\nstruct b2BodyDef\r\n{\r\n\t/// This constructor sets the body definition default values.\r\n\tb2BodyDef()\r\n\t{\r\n\t\tuserData = NULL;\r\n\t\tposition.Set(0.0f, 0.0f);\r\n\t\tangle = 0.0f;\r\n\t\tlinearVelocity.Set(0.0f, 0.0f);\r\n\t\tangularVelocity = 0.0f;\r\n\t\tlinearDamping = 0.0f;\r\n\t\tangularDamping = 0.0f;\r\n\t\tallowSleep = true;\r\n\t\tawake = true;\r\n\t\tfixedRotation = false;\r\n\t\tbullet = false;\r\n\t\ttype = b2_staticBody;\r\n\t\tactive = true;\r\n\t\tgravityScale = 1.0f;\r\n\t}\r\n\r\n\t/// The body type: static, kinematic, or dynamic.\r\n\t/// Note: if a dynamic body would have zero mass, the mass is set to one.\r\n\tb2BodyType type;\r\n\r\n\t/// The world position of the body. Avoid creating bodies at the origin\r\n\t/// since this can lead to many overlapping shapes.\r\n\tb2Vec2 position;\r\n\r\n\t/// The world angle of the body in radians.\r\n\tfloat32 angle;\r\n\r\n\t/// The linear velocity of the body's origin in world co-ordinates.\r\n\tb2Vec2 linearVelocity;\r\n\r\n\t/// The angular velocity of the body.\r\n\tfloat32 angularVelocity;\r\n\r\n\t/// Linear damping is use to reduce the linear velocity. The damping parameter\r\n\t/// can be larger than 1.0f but the damping effect becomes sensitive to the\r\n\t/// time step when the damping parameter is large.\r\n\tfloat32 linearDamping;\r\n\r\n\t/// Angular damping is use to reduce the angular velocity. The damping parameter\r\n\t/// can be larger than 1.0f but the damping effect becomes sensitive to the\r\n\t/// time step when the damping parameter is large.\r\n\tfloat32 angularDamping;\r\n\r\n\t/// Set this flag to false if this body should never fall asleep. Note that\r\n\t/// this increases CPU usage.\r\n\tbool allowSleep;\r\n\r\n\t/// Is this body initially awake or sleeping?\r\n\tbool awake;\r\n\r\n\t/// Should this body be prevented from rotating? Useful for characters.\r\n\tbool fixedRotation;\r\n\r\n\t/// Is this a fast moving body that should be prevented from tunneling through\r\n\t/// other moving bodies? Note that all bodies are prevented from tunneling through\r\n\t/// kinematic and static bodies. This setting is only considered on dynamic bodies.\r\n\t/// @warning You should use this flag sparingly since it increases processing time.\r\n\tbool bullet;\r\n\r\n\t/// Does this body start out active?\r\n\tbool active;\r\n\r\n\t/// Use this to store application specific body data.\r\n\tvoid* userData;\r\n\r\n\t/// Scale the gravity applied to this body.\r\n\tfloat32 gravityScale;\r\n};\r\n\r\n/// A rigid body. These are created via b2World::CreateBody.\r\nclass b2Body\r\n{\r\npublic:\r\n\t/// Creates a fixture and attach it to this body. Use this function if you need\r\n\t/// to set some fixture parameters, like friction. Otherwise you can create the\r\n\t/// fixture directly from a shape.\r\n\t/// If the density is non-zero, this function automatically updates the mass of the body.\r\n\t/// Contacts are not created until the next time step.\r\n\t/// @param def the fixture definition.\r\n\t/// @warning This function is locked during callbacks.\r\n\tb2Fixture* CreateFixture(const b2FixtureDef* def);\r\n\r\n\t/// Creates a fixture from a shape and attach it to this body.\r\n\t/// This is a convenience function. Use b2FixtureDef if you need to set parameters\r\n\t/// like friction, restitution, user data, or filtering.\r\n\t/// If the density is non-zero, this function automatically updates the mass of the body.\r\n\t/// @param shape the shape to be cloned.\r\n\t/// @param density the shape density (set to zero for static bodies).\r\n\t/// @warning This function is locked during callbacks.\r\n\tb2Fixture* CreateFixture(const b2Shape* shape, float32 density);\r\n\r\n\t/// Destroy a fixture. This removes the fixture from the broad-phase and\r\n\t/// destroys all contacts associated with this fixture. This will\r\n\t/// automatically adjust the mass of the body if the body is dynamic and the\r\n\t/// fixture has positive density.\r\n\t/// All fixtures attached to a body are implicitly destroyed when the body is destroyed.\r\n\t/// @param fixture the fixture to be removed.\r\n\t/// @warning This function is locked during callbacks.\r\n\tvoid DestroyFixture(b2Fixture* fixture);\r\n\r\n\t/// Set the position of the body's origin and rotation.\r\n\t/// This breaks any contacts and wakes the other bodies.\r\n\t/// Manipulating a body's transform may cause non-physical behavior.\r\n\t/// @param position the world position of the body's local origin.\r\n\t/// @param angle the world rotation in radians.\r\n\tvoid SetTransform(const b2Vec2& position, float32 angle);\r\n\r\n\t/// Get the body transform for the body's origin.\r\n\t/// @return the world transform of the body's origin.\r\n\tconst b2Transform& GetTransform() const;\r\n\r\n\t/// Get the world body origin position.\r\n\t/// @return the world position of the body's origin.\r\n\tconst b2Vec2& GetPosition() const;\r\n\r\n\t/// Get the angle in radians.\r\n\t/// @return the current world rotation angle in radians.\r\n\tfloat32 GetAngle() const;\r\n\r\n\t/// Get the world position of the center of mass.\r\n\tconst b2Vec2& GetWorldCenter() const;\r\n\r\n\t/// Get the local position of the center of mass.\r\n\tconst b2Vec2& GetLocalCenter() const;\r\n\r\n\t/// Set the linear velocity of the center of mass.\r\n\t/// @param v the new linear velocity of the center of mass.\r\n\tvoid SetLinearVelocity(const b2Vec2& v);\r\n\r\n\t/// Get the linear velocity of the center of mass.\r\n\t/// @return the linear velocity of the center of mass.\r\n\tb2Vec2 GetLinearVelocity() const;\r\n\r\n\t/// Set the angular velocity.\r\n\t/// @param omega the new angular velocity in radians/second.\r\n\tvoid SetAngularVelocity(float32 omega);\r\n\r\n\t/// Get the angular velocity.\r\n\t/// @return the angular velocity in radians/second.\r\n\tfloat32 GetAngularVelocity() const;\r\n\r\n\t/// Apply a force at a world point. If the force is not\r\n\t/// applied at the center of mass, it will generate a torque and\r\n\t/// affect the angular velocity. This wakes up the body.\r\n\t/// @param force the world force vector, usually in Newtons (N).\r\n\t/// @param point the world position of the point of application.\r\n\tvoid ApplyForce(const b2Vec2& force, const b2Vec2& point);\r\n\r\n\t/// Apply a force to the center of mass. This wakes up the body.\r\n\t/// @param force the world force vector, usually in Newtons (N).\r\n\tvoid ApplyForceToCenter(const b2Vec2& force);\r\n\r\n\t/// Apply a torque. This affects the angular velocity\r\n\t/// without affecting the linear velocity of the center of mass.\r\n\t/// This wakes up the body.\r\n\t/// @param torque about the z-axis (out of the screen), usually in N-m.\r\n\tvoid ApplyTorque(float32 torque);\r\n\r\n\t/// Apply an impulse at a point. This immediately modifies the velocity.\r\n\t/// It also modifies the angular velocity if the point of application\r\n\t/// is not at the center of mass. This wakes up the body.\r\n\t/// @param impulse the world impulse vector, usually in N-seconds or kg-m/s.\r\n\t/// @param point the world position of the point of application.\r\n\tvoid ApplyLinearImpulse(const b2Vec2& impulse, const b2Vec2& point);\r\n\r\n\t/// Apply an angular impulse.\r\n\t/// @param impulse the angular impulse in units of kg*m*m/s\r\n\tvoid ApplyAngularImpulse(float32 impulse);\r\n\r\n\t/// Get the total mass of the body.\r\n\t/// @return the mass, usually in kilograms (kg).\r\n\tfloat32 GetMass() const;\r\n\r\n\t/// Get the rotational inertia of the body about the local origin.\r\n\t/// @return the rotational inertia, usually in kg-m^2.\r\n\tfloat32 GetInertia() const;\r\n\r\n\t/// Get the mass data of the body.\r\n\t/// @return a struct containing the mass, inertia and center of the body.\r\n\tvoid GetMassData(b2MassData* data) const;\r\n\r\n\t/// Set the mass properties to override the mass properties of the fixtures.\r\n\t/// Note that this changes the center of mass position.\r\n\t/// Note that creating or destroying fixtures can also alter the mass.\r\n\t/// This function has no effect if the body isn't dynamic.\r\n\t/// @param massData the mass properties.\r\n\tvoid SetMassData(const b2MassData* data);\r\n\r\n\t/// This resets the mass properties to the sum of the mass properties of the fixtures.\r\n\t/// This normally does not need to be called unless you called SetMassData to override\r\n\t/// the mass and you later want to reset the mass.\r\n\tvoid ResetMassData();\r\n\r\n\t/// Get the world coordinates of a point given the local coordinates.\r\n\t/// @param localPoint a point on the body measured relative the the body's origin.\r\n\t/// @return the same point expressed in world coordinates.\r\n\tb2Vec2 GetWorldPoint(const b2Vec2& localPoint) const;\r\n\r\n\t/// Get the world coordinates of a vector given the local coordinates.\r\n\t/// @param localVector a vector fixed in the body.\r\n\t/// @return the same vector expressed in world coordinates.\r\n\tb2Vec2 GetWorldVector(const b2Vec2& localVector) const;\r\n\r\n\t/// Gets a local point relative to the body's origin given a world point.\r\n\t/// @param a point in world coordinates.\r\n\t/// @return the corresponding local point relative to the body's origin.\r\n\tb2Vec2 GetLocalPoint(const b2Vec2& worldPoint) const;\r\n\r\n\t/// Gets a local vector given a world vector.\r\n\t/// @param a vector in world coordinates.\r\n\t/// @return the corresponding local vector.\r\n\tb2Vec2 GetLocalVector(const b2Vec2& worldVector) const;\r\n\r\n\t/// Get the world linear velocity of a world point attached to this body.\r\n\t/// @param a point in world coordinates.\r\n\t/// @return the world velocity of a point.\r\n\tb2Vec2 GetLinearVelocityFromWorldPoint(const b2Vec2& worldPoint) const;\r\n\r\n\t/// Get the world velocity of a local point.\r\n\t/// @param a point in local coordinates.\r\n\t/// @return the world velocity of a point.\r\n\tb2Vec2 GetLinearVelocityFromLocalPoint(const b2Vec2& localPoint) const;\r\n\r\n\t/// Get the linear damping of the body.\r\n\tfloat32 GetLinearDamping() const;\r\n\r\n\t/// Set the linear damping of the body.\r\n\tvoid SetLinearDamping(float32 linearDamping);\r\n\r\n\t/// Get the angular damping of the body.\r\n\tfloat32 GetAngularDamping() const;\r\n\r\n\t/// Set the angular damping of the body.\r\n\tvoid SetAngularDamping(float32 angularDamping);\r\n\r\n\t/// Get the gravity scale of the body.\r\n\tfloat32 GetGravityScale() const;\r\n\r\n\t/// Set the gravity scale of the body.\r\n\tvoid SetGravityScale(float32 scale);\r\n\r\n\t/// Set the type of this body. This may alter the mass and velocity.\r\n\tvoid SetType(b2BodyType type);\r\n\r\n\t/// Get the type of this body.\r\n\tb2BodyType GetType() const;\r\n\r\n\t/// Should this body be treated like a bullet for continuous collision detection?\r\n\tvoid SetBullet(bool flag);\r\n\r\n\t/// Is this body treated like a bullet for continuous collision detection?\r\n\tbool IsBullet() const;\r\n\r\n\t/// You can disable sleeping on this body. If you disable sleeping, the\r\n\t/// body will be woken.\r\n\tvoid SetSleepingAllowed(bool flag);\r\n\r\n\t/// Is this body allowed to sleep\r\n\tbool IsSleepingAllowed() const;\r\n\r\n\t/// Set the sleep state of the body. A sleeping body has very\r\n\t/// low CPU cost.\r\n\t/// @param flag set to true to put body to sleep, false to wake it.\r\n\tvoid SetAwake(bool flag);\r\n\r\n\t/// Get the sleeping state of this body.\r\n\t/// @return true if the body is sleeping.\r\n\tbool IsAwake() const;\r\n\r\n\t/// Set the active state of the body. An inactive body is not\r\n\t/// simulated and cannot be collided with or woken up.\r\n\t/// If you pass a flag of true, all fixtures will be added to the\r\n\t/// broad-phase.\r\n\t/// If you pass a flag of false, all fixtures will be removed from\r\n\t/// the broad-phase and all contacts will be destroyed.\r\n\t/// Fixtures and joints are otherwise unaffected. You may continue\r\n\t/// to create/destroy fixtures and joints on inactive bodies.\r\n\t/// Fixtures on an inactive body are implicitly inactive and will\r\n\t/// not participate in collisions, ray-casts, or queries.\r\n\t/// Joints connected to an inactive body are implicitly inactive.\r\n\t/// An inactive body is still owned by a b2World object and remains\r\n\t/// in the body list.\r\n\tvoid SetActive(bool flag);\r\n\r\n\t/// Get the active state of the body.\r\n\tbool IsActive() const;\r\n\r\n\t/// Set this body to have fixed rotation. This causes the mass\r\n\t/// to be reset.\r\n\tvoid SetFixedRotation(bool flag);\r\n\r\n\t/// Does this body have fixed rotation?\r\n\tbool IsFixedRotation() const;\r\n\r\n\t/// Get the list of all fixtures attached to this body.\r\n\tb2Fixture* GetFixtureList();\r\n\tconst b2Fixture* GetFixtureList() const;\r\n\r\n\t/// Get the list of all joints attached to this body.\r\n\tb2JointEdge* GetJointList();\r\n\tconst b2JointEdge* GetJointList() const;\r\n\r\n\t/// Get the list of all contacts attached to this body.\r\n\t/// @warning this list changes during the time step and you may\r\n\t/// miss some collisions if you don't use b2ContactListener.\r\n\tb2ContactEdge* GetContactList();\r\n\tconst b2ContactEdge* GetContactList() const;\r\n\r\n\t/// Get the next body in the world's body list.\r\n\tb2Body* GetNext();\r\n\tconst b2Body* GetNext() const;\r\n\r\n\t/// Get the user data pointer that was provided in the body definition.\r\n\tvoid* GetUserData() const;\r\n\r\n\t/// Set the user data. Use this to store your application specific data.\r\n\tvoid SetUserData(void* data);\r\n\r\n\t/// Get the parent world of this body.\r\n\tb2World* GetWorld();\r\n\tconst b2World* GetWorld() const;\r\n\r\n\t/// Dump this body to a log file\r\n\tvoid Dump();\r\n\r\nprivate:\r\n\r\n\tfriend class b2World;\r\n\tfriend class b2Island;\r\n\tfriend class b2ContactManager;\r\n\tfriend class b2ContactSolver;\r\n\tfriend class b2Contact;\r\n\t\r\n\tfriend class b2DistanceJoint;\r\n\tfriend class b2GearJoint;\r\n\tfriend class b2WheelJoint;\r\n\tfriend class b2MouseJoint;\r\n\tfriend class b2PrismaticJoint;\r\n\tfriend class b2PulleyJoint;\r\n\tfriend class b2RevoluteJoint;\r\n\tfriend class b2WeldJoint;\r\n\tfriend class b2FrictionJoint;\r\n\tfriend class b2RopeJoint;\r\n\r\n\t// m_flags\r\n\tenum\r\n\t{\r\n\t\te_islandFlag\t\t= 0x0001,\r\n\t\te_awakeFlag\t\t\t= 0x0002,\r\n\t\te_autoSleepFlag\t\t= 0x0004,\r\n\t\te_bulletFlag\t\t= 0x0008,\r\n\t\te_fixedRotationFlag\t= 0x0010,\r\n\t\te_activeFlag\t\t= 0x0020,\r\n\t\te_toiFlag\t\t\t= 0x0040\r\n\t};\r\n\r\n\tb2Body(const b2BodyDef* bd, b2World* world);\r\n\t~b2Body();\r\n\r\n\tvoid SynchronizeFixtures();\r\n\tvoid SynchronizeTransform();\r\n\r\n\t// This is used to prevent connected bodies from colliding.\r\n\t// It may lie, depending on the collideConnected flag.\r\n\tbool ShouldCollide(const b2Body* other) const;\r\n\r\n\tvoid Advance(float32 t);\r\n\r\n\tb2BodyType m_type;\r\n\r\n\tuint16 m_flags;\r\n\r\n\tint32 m_islandIndex;\r\n\r\n\tb2Transform m_xf;\t\t// the body origin transform\r\n\tb2Sweep m_sweep;\t\t// the swept motion for CCD\r\n\r\n\tb2Vec2 m_linearVelocity;\r\n\tfloat32 m_angularVelocity;\r\n\r\n\tb2Vec2 m_force;\r\n\tfloat32 m_torque;\r\n\r\n\tb2World* m_world;\r\n\tb2Body* m_prev;\r\n\tb2Body* m_next;\r\n\r\n\tb2Fixture* m_fixtureList;\r\n\tint32 m_fixtureCount;\r\n\r\n\tb2JointEdge* m_jointList;\r\n\tb2ContactEdge* m_contactList;\r\n\r\n\tfloat32 m_mass, m_invMass;\r\n\r\n\t// Rotational inertia about the center of mass.\r\n\tfloat32 m_I, m_invI;\r\n\r\n\tfloat32 m_linearDamping;\r\n\tfloat32 m_angularDamping;\r\n\tfloat32 m_gravityScale;\r\n\r\n\tfloat32 m_sleepTime;\r\n\r\n\tvoid* m_userData;\r\n};\r\n\r\ninline b2BodyType b2Body::GetType() const\r\n{\r\n\treturn m_type;\r\n}\r\n\r\ninline const b2Transform& b2Body::GetTransform() const\r\n{\r\n\treturn m_xf;\r\n}\r\n\r\ninline const b2Vec2& b2Body::GetPosition() const\r\n{\r\n\treturn m_xf.p;\r\n}\r\n\r\ninline float32 b2Body::GetAngle() const\r\n{\r\n\treturn m_sweep.a;\r\n}\r\n\r\ninline const b2Vec2& b2Body::GetWorldCenter() const\r\n{\r\n\treturn m_sweep.c;\r\n}\r\n\r\ninline const b2Vec2& b2Body::GetLocalCenter() const\r\n{\r\n\treturn m_sweep.localCenter;\r\n}\r\n\r\ninline void b2Body::SetLinearVelocity(const b2Vec2& v)\r\n{\r\n\tif (m_type == b2_staticBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (b2Dot(v,v) > 0.0f)\r\n\t{\r\n\t\tSetAwake(true);\r\n\t}\r\n\r\n\tm_linearVelocity = v;\r\n}\r\n\r\ninline b2Vec2 b2Body::GetLinearVelocity() const\r\n{\r\n\treturn m_linearVelocity;\r\n}\r\n\r\ninline void b2Body::SetAngularVelocity(float32 w)\r\n{\r\n\tif (m_type == b2_staticBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (w * w > 0.0f)\r\n\t{\r\n\t\tSetAwake(true);\r\n\t}\r\n\r\n\tm_angularVelocity = w;\r\n}\r\n\r\ninline float32 b2Body::GetAngularVelocity() const\r\n{\r\n\treturn m_angularVelocity;\r\n}\r\n\r\ninline float32 b2Body::GetMass() const\r\n{\r\n\treturn m_mass;\r\n}\r\n\r\ninline float32 b2Body::GetInertia() const\r\n{\r\n\treturn m_I + m_mass * b2Dot(m_sweep.localCenter, m_sweep.localCenter);\r\n}\r\n\r\ninline void b2Body::GetMassData(b2MassData* data) const\r\n{\r\n\tdata->mass = m_mass;\r\n\tdata->I = m_I + m_mass * b2Dot(m_sweep.localCenter, m_sweep.localCenter);\r\n\tdata->center = m_sweep.localCenter;\r\n}\r\n\r\ninline b2Vec2 b2Body::GetWorldPoint(const b2Vec2& localPoint) const\r\n{\r\n\treturn b2Mul(m_xf, localPoint);\r\n}\r\n\r\ninline b2Vec2 b2Body::GetWorldVector(const b2Vec2& localVector) const\r\n{\r\n\treturn b2Mul(m_xf.q, localVector);\r\n}\r\n\r\ninline b2Vec2 b2Body::GetLocalPoint(const b2Vec2& worldPoint) const\r\n{\r\n\treturn b2MulT(m_xf, worldPoint);\r\n}\r\n\r\ninline b2Vec2 b2Body::GetLocalVector(const b2Vec2& worldVector) const\r\n{\r\n\treturn b2MulT(m_xf.q, worldVector);\r\n}\r\n\r\ninline b2Vec2 b2Body::GetLinearVelocityFromWorldPoint(const b2Vec2& worldPoint) const\r\n{\r\n\treturn m_linearVelocity + b2Cross(m_angularVelocity, worldPoint - m_sweep.c);\r\n}\r\n\r\ninline b2Vec2 b2Body::GetLinearVelocityFromLocalPoint(const b2Vec2& localPoint) const\r\n{\r\n\treturn GetLinearVelocityFromWorldPoint(GetWorldPoint(localPoint));\r\n}\r\n\r\ninline float32 b2Body::GetLinearDamping() const\r\n{\r\n\treturn m_linearDamping;\r\n}\r\n\r\ninline void b2Body::SetLinearDamping(float32 linearDamping)\r\n{\r\n\tm_linearDamping = linearDamping;\r\n}\r\n\r\ninline float32 b2Body::GetAngularDamping() const\r\n{\r\n\treturn m_angularDamping;\r\n}\r\n\r\ninline void b2Body::SetAngularDamping(float32 angularDamping)\r\n{\r\n\tm_angularDamping = angularDamping;\r\n}\r\n\r\ninline float32 b2Body::GetGravityScale() const\r\n{\r\n\treturn m_gravityScale;\r\n}\r\n\r\ninline void b2Body::SetGravityScale(float32 scale)\r\n{\r\n\tm_gravityScale = scale;\r\n}\r\n\r\ninline void b2Body::SetBullet(bool flag)\r\n{\r\n\tif (flag)\r\n\t{\r\n\t\tm_flags |= e_bulletFlag;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_flags &= ~e_bulletFlag;\r\n\t}\r\n}\r\n\r\ninline bool b2Body::IsBullet() const\r\n{\r\n\treturn (m_flags & e_bulletFlag) == e_bulletFlag;\r\n}\r\n\r\ninline void b2Body::SetAwake(bool flag)\r\n{\r\n\tif (flag)\r\n\t{\r\n\t\tif ((m_flags & e_awakeFlag) == 0)\r\n\t\t{\r\n\t\t\tm_flags |= e_awakeFlag;\r\n\t\t\tm_sleepTime = 0.0f;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_flags &= ~e_awakeFlag;\r\n\t\tm_sleepTime = 0.0f;\r\n\t\tm_linearVelocity.SetZero();\r\n\t\tm_angularVelocity = 0.0f;\r\n\t\tm_force.SetZero();\r\n\t\tm_torque = 0.0f;\r\n\t}\r\n}\r\n\r\ninline bool b2Body::IsAwake() const\r\n{\r\n\treturn (m_flags & e_awakeFlag) == e_awakeFlag;\r\n}\r\n\r\ninline bool b2Body::IsActive() const\r\n{\r\n\treturn (m_flags & e_activeFlag) == e_activeFlag;\r\n}\r\n\r\ninline void b2Body::SetFixedRotation(bool flag)\r\n{\r\n\tif (flag)\r\n\t{\r\n\t\tm_flags |= e_fixedRotationFlag;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_flags &= ~e_fixedRotationFlag;\r\n\t}\r\n\r\n\tResetMassData();\r\n}\r\n\r\ninline bool b2Body::IsFixedRotation() const\r\n{\r\n\treturn (m_flags & e_fixedRotationFlag) == e_fixedRotationFlag;\r\n}\r\n\r\ninline void b2Body::SetSleepingAllowed(bool flag)\r\n{\r\n\tif (flag)\r\n\t{\r\n\t\tm_flags |= e_autoSleepFlag;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_flags &= ~e_autoSleepFlag;\r\n\t\tSetAwake(true);\r\n\t}\r\n}\r\n\r\ninline bool b2Body::IsSleepingAllowed() const\r\n{\r\n\treturn (m_flags & e_autoSleepFlag) == e_autoSleepFlag;\r\n}\r\n\r\ninline b2Fixture* b2Body::GetFixtureList()\r\n{\r\n\treturn m_fixtureList;\r\n}\r\n\r\ninline const b2Fixture* b2Body::GetFixtureList() const\r\n{\r\n\treturn m_fixtureList;\r\n}\r\n\r\ninline b2JointEdge* b2Body::GetJointList()\r\n{\r\n\treturn m_jointList;\r\n}\r\n\r\ninline const b2JointEdge* b2Body::GetJointList() const\r\n{\r\n\treturn m_jointList;\r\n}\r\n\r\ninline b2ContactEdge* b2Body::GetContactList()\r\n{\r\n\treturn m_contactList;\r\n}\r\n\r\ninline const b2ContactEdge* b2Body::GetContactList() const\r\n{\r\n\treturn m_contactList;\r\n}\r\n\r\ninline b2Body* b2Body::GetNext()\r\n{\r\n\treturn m_next;\r\n}\r\n\r\ninline const b2Body* b2Body::GetNext() const\r\n{\r\n\treturn m_next;\r\n}\r\n\r\ninline void b2Body::SetUserData(void* data)\r\n{\r\n\tm_userData = data;\r\n}\r\n\r\ninline void* b2Body::GetUserData() const\r\n{\r\n\treturn m_userData;\r\n}\r\n\r\ninline void b2Body::ApplyForce(const b2Vec2& force, const b2Vec2& point)\r\n{\r\n\tif (m_type != b2_dynamicBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (IsAwake() == false)\r\n\t{\r\n\t\tSetAwake(true);\r\n\t}\r\n\r\n\tm_force += force;\r\n\tm_torque += b2Cross(point - m_sweep.c, force);\r\n}\r\n\r\ninline void b2Body::ApplyForceToCenter(const b2Vec2& force)\r\n{\r\n\tif (m_type != b2_dynamicBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (IsAwake() == false)\r\n\t{\r\n\t\tSetAwake(true);\r\n\t}\r\n\r\n\tm_force += force;\r\n}\r\n\r\ninline void b2Body::ApplyTorque(float32 torque)\r\n{\r\n\tif (m_type != b2_dynamicBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (IsAwake() == false)\r\n\t{\r\n\t\tSetAwake(true);\r\n\t}\r\n\r\n\tm_torque += torque;\r\n}\r\n\r\ninline void b2Body::ApplyLinearImpulse(const b2Vec2& impulse, const b2Vec2& point)\r\n{\r\n\tif (m_type != b2_dynamicBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (IsAwake() == false)\r\n\t{\r\n\t\tSetAwake(true);\r\n\t}\r\n\tm_linearVelocity += m_invMass * impulse;\r\n\tm_angularVelocity += m_invI * b2Cross(point - m_sweep.c, impulse);\r\n}\r\n\r\ninline void b2Body::ApplyAngularImpulse(float32 impulse)\r\n{\r\n\tif (m_type != b2_dynamicBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (IsAwake() == false)\r\n\t{\r\n\t\tSetAwake(true);\r\n\t}\r\n\tm_angularVelocity += m_invI * impulse;\r\n}\r\n\r\ninline void b2Body::SynchronizeTransform()\r\n{\r\n\tm_xf.q.Set(m_sweep.a);\r\n\tm_xf.p = m_sweep.c - b2Mul(m_xf.q, m_sweep.localCenter);\r\n}\r\n\r\ninline void b2Body::Advance(float32 alpha)\r\n{\r\n\t// Advance to the new safe time. This doesn't sync the broad-phase.\r\n\tm_sweep.Advance(alpha);\r\n\tm_sweep.c = m_sweep.c0;\r\n\tm_sweep.a = m_sweep.a0;\r\n\tm_xf.q.Set(m_sweep.a);\r\n\tm_xf.p = m_sweep.c - b2Mul(m_xf.q, m_sweep.localCenter);\r\n}\r\n\r\ninline b2World* b2Body::GetWorld()\r\n{\r\n\treturn m_world;\r\n}\r\n\r\ninline const b2World* b2Body::GetWorld() const\r\n{\r\n\treturn m_world;\r\n}\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_COLLISION_H\r\n#define B2_COLLISION_H\r\n\r\n#include <Box2D/Common/b2Math.h>\r\n#include <climits>\r\n\r\n/// @file\r\n/// Structures and functions used for computing contact points, distance\r\n/// queries, and TOI queries.\r\n\r\nclass b2Shape;\r\nclass b2CircleShape;\r\nclass b2EdgeShape;\r\nclass b2PolygonShape;\r\n\r\nconst uint8 b2_nullFeature = UCHAR_MAX;\r\n\r\n/// The features that intersect to form the contact point\r\n/// This must be 4 bytes or less.\r\nstruct b2ContactFeature\r\n{\r\n\tenum Type\r\n\t{\r\n\t\te_vertex = 0,\r\n\t\te_face = 1\r\n\t};\r\n\r\n\tuint8 indexA;\t\t///< Feature index on shapeA\r\n\tuint8 indexB;\t\t///< Feature index on shapeB\r\n\tuint8 typeA;\t\t///< The feature type on shapeA\r\n\tuint8 typeB;\t\t///< The feature type on shapeB\r\n};\r\n\r\n/// Contact ids to facilitate warm starting.\r\nunion b2ContactID\r\n{\r\n\tb2ContactFeature cf;\r\n\tuint32 key;\t\t\t\t\t///< Used to quickly compare contact ids.\r\n};\r\n\r\n/// A manifold point is a contact point belonging to a contact\r\n/// manifold. It holds details related to the geometry and dynamics\r\n/// of the contact points.\r\n/// The local point usage depends on the manifold type:\r\n/// -e_circles: the local center of circleB\r\n/// -e_faceA: the local center of cirlceB or the clip point of polygonB\r\n/// -e_faceB: the clip point of polygonA\r\n/// This structure is stored across time steps, so we keep it small.\r\n/// Note: the impulses are used for internal caching and may not\r\n/// provide reliable contact forces, especially for high speed collisions.\r\nstruct b2ManifoldPoint\r\n{\r\n\tb2Vec2 localPoint;\t\t///< usage depends on manifold type\r\n\tfloat32 normalImpulse;\t///< the non-penetration impulse\r\n\tfloat32 tangentImpulse;\t///< the friction impulse\r\n\tb2ContactID id;\t\t\t///< uniquely identifies a contact point between two shapes\r\n};\r\n\r\n/// A manifold for two touching convex shapes.\r\n/// Box2D supports multiple types of contact:\r\n/// - clip point versus plane with radius\r\n/// - point versus point with radius (circles)\r\n/// The local point usage depends on the manifold type:\r\n/// -e_circles: the local center of circleA\r\n/// -e_faceA: the center of faceA\r\n/// -e_faceB: the center of faceB\r\n/// Similarly the local normal usage:\r\n/// -e_circles: not used\r\n/// -e_faceA: the normal on polygonA\r\n/// -e_faceB: the normal on polygonB\r\n/// We store contacts in this way so that position correction can\r\n/// account for movement, which is critical for continuous physics.\r\n/// All contact scenarios must be expressed in one of these types.\r\n/// This structure is stored across time steps, so we keep it small.\r\nstruct b2Manifold\r\n{\r\n\tenum Type\r\n\t{\r\n\t\te_circles,\r\n\t\te_faceA,\r\n\t\te_faceB\r\n\t};\r\n\r\n\tb2ManifoldPoint points[b2_maxManifoldPoints];\t///< the points of contact\r\n\tb2Vec2 localNormal;\t\t\t\t\t\t\t\t///< not use for Type::e_points\r\n\tb2Vec2 localPoint;\t\t\t\t\t\t\t\t///< usage depends on manifold type\r\n\tType type;\r\n\tint32 pointCount;\t\t\t\t\t\t\t\t///< the number of manifold points\r\n};\r\n\r\n/// This is used to compute the current state of a contact manifold.\r\nstruct b2WorldManifold\r\n{\r\n\t/// Evaluate the manifold with supplied transforms. This assumes\r\n\t/// modest motion from the original state. This does not change the\r\n\t/// point count, impulses, etc. The radii must come from the shapes\r\n\t/// that generated the manifold.\r\n\tvoid Initialize(const b2Manifold* manifold,\r\n\t\t\t\t\tconst b2Transform& xfA, float32 radiusA,\r\n\t\t\t\t\tconst b2Transform& xfB, float32 radiusB);\r\n\r\n\tb2Vec2 normal;\t\t\t\t\t\t\t///< world vector pointing from A to B\r\n\tb2Vec2 points[b2_maxManifoldPoints];\t///< world contact point (point of intersection)\r\n};\r\n\r\n/// This is used for determining the state of contact points.\r\nenum b2PointState\r\n{\r\n\tb2_nullState,\t\t///< point does not exist\r\n\tb2_addState,\t\t///< point was added in the update\r\n\tb2_persistState,\t///< point persisted across the update\r\n\tb2_removeState\t\t///< point was removed in the update\r\n};\r\n\r\n/// Compute the point states given two manifolds. The states pertain to the transition from manifold1\r\n/// to manifold2. So state1 is either persist or remove while state2 is either add or persist.\r\nvoid b2GetPointStates(b2PointState state1[b2_maxManifoldPoints], b2PointState state2[b2_maxManifoldPoints],\r\n\t\t\t\t\t  const b2Manifold* manifold1, const b2Manifold* manifold2);\r\n\r\n/// Used for computing contact manifolds.\r\nstruct b2ClipVertex\r\n{\r\n\tb2Vec2 v;\r\n\tb2ContactID id;\r\n};\r\n\r\n/// Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).\r\nstruct b2RayCastInput\r\n{\r\n\tb2Vec2 p1, p2;\r\n\tfloat32 maxFraction;\r\n};\r\n\r\n/// Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2\r\n/// come from b2RayCastInput.\r\nstruct b2RayCastOutput\r\n{\r\n\tb2Vec2 normal;\r\n\tfloat32 fraction;\r\n};\r\n\r\n/// An axis aligned bounding box.\r\nstruct b2AABB\r\n{\r\n\t/// Verify that the bounds are sorted.\r\n\tbool IsValid() const;\r\n\r\n\t/// Get the center of the AABB.\r\n\tb2Vec2 GetCenter() const\r\n\t{\r\n\t\treturn 0.5f * (lowerBound + upperBound);\r\n\t}\r\n\r\n\t/// Get the extents of the AABB (half-widths).\r\n\tb2Vec2 GetExtents() const\r\n\t{\r\n\t\treturn 0.5f * (upperBound - lowerBound);\r\n\t}\r\n\r\n\t/// Get the perimeter length\r\n\tfloat32 GetPerimeter() const\r\n\t{\r\n\t\tfloat32 wx = upperBound.x - lowerBound.x;\r\n\t\tfloat32 wy = upperBound.y - lowerBound.y;\r\n\t\treturn 2.0f * (wx + wy);\r\n\t}\r\n\r\n\t/// Combine an AABB into this one.\r\n\tvoid Combine(const b2AABB& aabb)\r\n\t{\r\n\t\tlowerBound = b2Min(lowerBound, aabb.lowerBound);\r\n\t\tupperBound = b2Max(upperBound, aabb.upperBound);\r\n\t}\r\n\r\n\t/// Combine two AABBs into this one.\r\n\tvoid Combine(const b2AABB& aabb1, const b2AABB& aabb2)\r\n\t{\r\n\t\tlowerBound = b2Min(aabb1.lowerBound, aabb2.lowerBound);\r\n\t\tupperBound = b2Max(aabb1.upperBound, aabb2.upperBound);\r\n\t}\r\n\r\n\t/// Does this aabb contain the provided AABB.\r\n\tbool Contains(const b2AABB& aabb) const\r\n\t{\r\n\t\tbool result = true;\r\n\t\tresult = result && lowerBound.x <= aabb.lowerBound.x;\r\n\t\tresult = result && lowerBound.y <= aabb.lowerBound.y;\r\n\t\tresult = result && aabb.upperBound.x <= upperBound.x;\r\n\t\tresult = result && aabb.upperBound.y <= upperBound.y;\r\n\t\treturn result;\r\n\t}\r\n\r\n\tbool RayCast(b2RayCastOutput* output, const b2RayCastInput& input) const;\r\n\r\n\tb2Vec2 lowerBound;\t///< the lower vertex\r\n\tb2Vec2 upperBound;\t///< the upper vertex\r\n};\r\n\r\n/// Compute the collision manifold between two circles.\r\nvoid b2CollideCircles(b2Manifold* manifold,\r\n\t\t\t\t\t  const b2CircleShape* circleA, const b2Transform& xfA,\r\n\t\t\t\t\t  const b2CircleShape* circleB, const b2Transform& xfB);\r\n\r\n/// Compute the collision manifold between a polygon and a circle.\r\nvoid b2CollidePolygonAndCircle(b2Manifold* manifold,\r\n\t\t\t\t\t\t\t   const b2PolygonShape* polygonA, const b2Transform& xfA,\r\n\t\t\t\t\t\t\t   const b2CircleShape* circleB, const b2Transform& xfB);\r\n\r\n/// Compute the collision manifold between two polygons.\r\nvoid b2CollidePolygons(b2Manifold* manifold,\r\n\t\t\t\t\t   const b2PolygonShape* polygonA, const b2Transform& xfA,\r\n\t\t\t\t\t   const b2PolygonShape* polygonB, const b2Transform& xfB);\r\n\r\n/// Compute the collision manifold between an edge and a circle.\r\nvoid b2CollideEdgeAndCircle(b2Manifold* manifold,\r\n\t\t\t\t\t\t\t   const b2EdgeShape* polygonA, const b2Transform& xfA,\r\n\t\t\t\t\t\t\t   const b2CircleShape* circleB, const b2Transform& xfB);\r\n\r\n/// Compute the collision manifold between an edge and a circle.\r\nvoid b2CollideEdgeAndPolygon(b2Manifold* manifold,\r\n\t\t\t\t\t\t\t   const b2EdgeShape* edgeA, const b2Transform& xfA,\r\n\t\t\t\t\t\t\t   const b2PolygonShape* circleB, const b2Transform& xfB);\r\n\r\n/// Clipping for contact manifolds.\r\nint32 b2ClipSegmentToLine(b2ClipVertex vOut[2], const b2ClipVertex vIn[2],\r\n\t\t\t\t\t\t\tconst b2Vec2& normal, float32 offset, int32 vertexIndexA);\r\n\r\n/// Determine if two generic shapes overlap.\r\nbool b2TestOverlap(\tconst b2Shape* shapeA, int32 indexA,\r\n\t\t\t\t\tconst b2Shape* shapeB, int32 indexB,\r\n\t\t\t\t\tconst b2Transform& xfA, const b2Transform& xfB);\r\n\r\n// ---------------- Inline Functions ------------------------------------------\r\n\r\ninline bool b2AABB::IsValid() const\r\n{\r\n\tb2Vec2 d = upperBound - lowerBound;\r\n\tbool valid = d.x >= 0.0f && d.y >= 0.0f;\r\n\tvalid = valid && lowerBound.IsValid() && upperBound.IsValid();\r\n\treturn valid;\r\n}\r\n\r\ninline bool b2TestOverlap(const b2AABB& a, const b2AABB& b)\r\n{\r\n\tb2Vec2 d1, d2;\r\n\td1 = b.lowerBound - a.upperBound;\r\n\td2 = a.lowerBound - b.upperBound;\r\n\r\n\tif (d1.x > 0.0f || d1.y > 0.0f)\r\n\t\treturn false;\r\n\r\n\tif (d2.x > 0.0f || d2.y > 0.0f)\r\n\t\treturn false;\r\n\r\n\treturn true;\r\n}\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_FRICTION_JOINT_H\r\n#define B2_FRICTION_JOINT_H\r\n\r\n#include <Box2D/Dynamics/Joints/b2Joint.h>\r\n\r\n/// Friction joint definition.\r\nstruct b2FrictionJointDef : public b2JointDef\r\n{\r\n\tb2FrictionJointDef()\r\n\t{\r\n\t\ttype = e_frictionJoint;\r\n\t\tlocalAnchorA.SetZero();\r\n\t\tlocalAnchorB.SetZero();\r\n\t\tmaxForce = 0.0f;\r\n\t\tmaxTorque = 0.0f;\r\n\t}\r\n\r\n\t/// Initialize the bodies, anchors, axis, and reference angle using the world\r\n\t/// anchor and world axis.\r\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor);\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tb2Vec2 localAnchorA;\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tb2Vec2 localAnchorB;\r\n\r\n\t/// The maximum friction force in N.\r\n\tfloat32 maxForce;\r\n\r\n\t/// The maximum friction torque in N-m.\r\n\tfloat32 maxTorque;\r\n};\r\n\r\n/// Friction joint. This is used for top-down friction.\r\n/// It provides 2D translational friction and angular friction.\r\nclass b2FrictionJoint : public b2Joint\r\n{\r\npublic:\r\n\tb2Vec2 GetAnchorA() const;\r\n\tb2Vec2 GetAnchorB() const;\r\n\r\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\r\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tconst b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tconst b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }\r\n\r\n\t/// Set the maximum friction force in N.\r\n\tvoid SetMaxForce(float32 force);\r\n\r\n\t/// Get the maximum friction force in N.\r\n\tfloat32 GetMaxForce() const;\r\n\r\n\t/// Set the maximum friction torque in N*m.\r\n\tvoid SetMaxTorque(float32 torque);\r\n\r\n\t/// Get the maximum friction torque in N*m.\r\n\tfloat32 GetMaxTorque() const;\r\n\r\n\t/// Dump joint to dmLog\r\n\tvoid Dump();\r\n\r\nprotected:\r\n\r\n\tfriend class b2Joint;\r\n\r\n\tb2FrictionJoint(const b2FrictionJointDef* def);\r\n\r\n\tvoid InitVelocityConstraints(const b2SolverData& data);\r\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\r\n\tbool SolvePositionConstraints(const b2SolverData& data);\r\n\r\n\tb2Vec2 m_localAnchorA;\r\n\tb2Vec2 m_localAnchorB;\r\n\r\n\t// Solver shared\r\n\tb2Vec2 m_linearImpulse;\r\n\tfloat32 m_angularImpulse;\r\n\tfloat32 m_maxForce;\r\n\tfloat32 m_maxTorque;\r\n\r\n\t// Solver temp\r\n\tint32 m_indexA;\r\n\tint32 m_indexB;\r\n\tb2Vec2 m_rA;\r\n\tb2Vec2 m_rB;\r\n\tb2Vec2 m_localCenterA;\r\n\tb2Vec2 m_localCenterB;\r\n\tfloat32 m_invMassA;\r\n\tfloat32 m_invMassB;\r\n\tfloat32 m_invIA;\r\n\tfloat32 m_invIB;\r\n\tb2Mat22 m_linearMass;\r\n\tfloat32 m_angularMass;\r\n};\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_PRISMATIC_JOINT_H\r\n#define B2_PRISMATIC_JOINT_H\r\n\r\n#include <Box2D/Dynamics/Joints/b2Joint.h>\r\n\r\n/// Prismatic joint definition. This requires defining a line of\r\n/// motion using an axis and an anchor point. The definition uses local\r\n/// anchor points and a local axis so that the initial configuration\r\n/// can violate the constraint slightly. The joint translation is zero\r\n/// when the local anchor points coincide in world space. Using local\r\n/// anchors and a local axis helps when saving and loading a game.\r\nstruct b2PrismaticJointDef : public b2JointDef\r\n{\r\n\tb2PrismaticJointDef()\r\n\t{\r\n\t\ttype = e_prismaticJoint;\r\n\t\tlocalAnchorA.SetZero();\r\n\t\tlocalAnchorB.SetZero();\r\n\t\tlocalAxisA.Set(1.0f, 0.0f);\r\n\t\treferenceAngle = 0.0f;\r\n\t\tenableLimit = false;\r\n\t\tlowerTranslation = 0.0f;\r\n\t\tupperTranslation = 0.0f;\r\n\t\tenableMotor = false;\r\n\t\tmaxMotorForce = 0.0f;\r\n\t\tmotorSpeed = 0.0f;\r\n\t}\r\n\r\n\t/// Initialize the bodies, anchors, axis, and reference angle using the world\r\n\t/// anchor and unit world axis.\r\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor, const b2Vec2& axis);\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tb2Vec2 localAnchorA;\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tb2Vec2 localAnchorB;\r\n\r\n\t/// The local translation unit axis in bodyA.\r\n\tb2Vec2 localAxisA;\r\n\r\n\t/// The constrained angle between the bodies: bodyB_angle - bodyA_angle.\r\n\tfloat32 referenceAngle;\r\n\r\n\t/// Enable/disable the joint limit.\r\n\tbool enableLimit;\r\n\r\n\t/// The lower translation limit, usually in meters.\r\n\tfloat32 lowerTranslation;\r\n\r\n\t/// The upper translation limit, usually in meters.\r\n\tfloat32 upperTranslation;\r\n\r\n\t/// Enable/disable the joint motor.\r\n\tbool enableMotor;\r\n\r\n\t/// The maximum motor torque, usually in N-m.\r\n\tfloat32 maxMotorForce;\r\n\r\n\t/// The desired motor speed in radians per second.\r\n\tfloat32 motorSpeed;\r\n};\r\n\r\n/// A prismatic joint. This joint provides one degree of freedom: translation\r\n/// along an axis fixed in bodyA. Relative rotation is prevented. You can\r\n/// use a joint limit to restrict the range of motion and a joint motor to\r\n/// drive the motion or to model joint friction.\r\nclass b2PrismaticJoint : public b2Joint\r\n{\r\npublic:\r\n\tb2Vec2 GetAnchorA() const;\r\n\tb2Vec2 GetAnchorB() const;\r\n\r\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\r\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tconst b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tconst b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }\r\n\r\n\t/// The local joint axis relative to bodyA.\r\n\tconst b2Vec2& GetLocalAxisA() const { return m_localXAxisA; }\r\n\r\n\t/// Get the reference angle.\r\n\tfloat32 GetReferenceAngle() const { return m_referenceAngle; }\r\n\r\n\t/// Get the current joint translation, usually in meters.\r\n\tfloat32 GetJointTranslation() const;\r\n\r\n\t/// Get the current joint translation speed, usually in meters per second.\r\n\tfloat32 GetJointSpeed() const;\r\n\r\n\t/// Is the joint limit enabled?\r\n\tbool IsLimitEnabled() const;\r\n\r\n\t/// Enable/disable the joint limit.\r\n\tvoid EnableLimit(bool flag);\r\n\r\n\t/// Get the lower joint limit, usually in meters.\r\n\tfloat32 GetLowerLimit() const;\r\n\r\n\t/// Get the upper joint limit, usually in meters.\r\n\tfloat32 GetUpperLimit() const;\r\n\r\n\t/// Set the joint limits, usually in meters.\r\n\tvoid SetLimits(float32 lower, float32 upper);\r\n\r\n\t/// Is the joint motor enabled?\r\n\tbool IsMotorEnabled() const;\r\n\r\n\t/// Enable/disable the joint motor.\r\n\tvoid EnableMotor(bool flag);\r\n\r\n\t/// Set the motor speed, usually in meters per second.\r\n\tvoid SetMotorSpeed(float32 speed);\r\n\r\n\t/// Get the motor speed, usually in meters per second.\r\n\tfloat32 GetMotorSpeed() const;\r\n\r\n\t/// Set the maximum motor force, usually in N.\r\n\tvoid SetMaxMotorForce(float32 force);\r\n\tfloat32 GetMaxMotorForce() const { return m_maxMotorForce; }\r\n\r\n\t/// Get the current motor force given the inverse time step, usually in N.\r\n\tfloat32 GetMotorForce(float32 inv_dt) const;\r\n\r\n\t/// Dump to b2Log\r\n\tvoid Dump();\r\n\r\nprotected:\r\n\tfriend class b2Joint;\r\n\tfriend class b2GearJoint;\r\n\tb2PrismaticJoint(const b2PrismaticJointDef* def);\r\n\r\n\tvoid InitVelocityConstraints(const b2SolverData& data);\r\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\r\n\tbool SolvePositionConstraints(const b2SolverData& data);\r\n\r\n\t// Solver shared\r\n\tb2Vec2 m_localAnchorA;\r\n\tb2Vec2 m_localAnchorB;\r\n\tb2Vec2 m_localXAxisA;\r\n\tb2Vec2 m_localYAxisA;\r\n\tfloat32 m_referenceAngle;\r\n\tb2Vec3 m_impulse;\r\n\tfloat32 m_motorImpulse;\r\n\tfloat32 m_lowerTranslation;\r\n\tfloat32 m_upperTranslation;\r\n\tfloat32 m_maxMotorForce;\r\n\tfloat32 m_motorSpeed;\r\n\tbool m_enableLimit;\r\n\tbool m_enableMotor;\r\n\tb2LimitState m_limitState;\r\n\r\n\t// Solver temp\r\n\tint32 m_indexA;\r\n\tint32 m_indexB;\r\n\tb2Vec2 m_localCenterA;\r\n\tb2Vec2 m_localCenterB;\r\n\tfloat32 m_invMassA;\r\n\tfloat32 m_invMassB;\r\n\tfloat32 m_invIA;\r\n\tfloat32 m_invIB;\r\n\tb2Vec2 m_axis, m_perp;\r\n\tfloat32 m_s1, m_s2;\r\n\tfloat32 m_a1, m_a2;\r\n\tb2Mat33 m_K;\r\n\tfloat32 m_motorMass;\r\n};\r\n\r\ninline float32 b2PrismaticJoint::GetMotorSpeed() const\r\n{\r\n\treturn m_motorSpeed;\r\n}\r\n\r\n#endif\r\n","/*\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_WORLD_H\n#define B2_WORLD_H\n\n#include <Box2D/Common/b2Math.h>\n#include <Box2D/Common/b2BlockAllocator.h>\n#include <Box2D/Common/b2StackAllocator.h>\n#include <Box2D/Dynamics/b2ContactManager.h>\n#include <Box2D/Dynamics/b2WorldCallbacks.h>\n#include <Box2D/Dynamics/b2TimeStep.h>\n\nstruct b2AABB;\nstruct b2BodyDef;\nstruct b2Color;\nstruct b2JointDef;\nclass b2Body;\nclass b2Draw;\nclass b2Fixture;\nclass b2Joint;\n\n/// The world class manages all physics entities, dynamic simulation,\n/// and asynchronous queries. The world also contains efficient memory\n/// management facilities.\nclass b2World\n{\npublic:\n\t/// Construct a world object.\n\t/// @param gravity the world gravity vector.\n\tb2World(const b2Vec2& gravity);\n\n\t/// Destruct the world. All physics entities are destroyed and all heap memory is released.\n\t~b2World();\n\n\t/// Register a destruction listener. The listener is owned by you and must\n\t/// remain in scope.\n\tvoid SetDestructionListener(b2DestructionListener* listener);\n\n\t/// Register a contact filter to provide specific control over collision.\n\t/// Otherwise the default filter is used (b2_defaultFilter). The listener is\n\t/// owned by you and must remain in scope. \n\tvoid SetContactFilter(b2ContactFilter* filter);\n\n\t/// Register a contact event listener. The listener is owned by you and must\n\t/// remain in scope.\n\tvoid SetContactListener(b2ContactListener* listener);\n\n\t/// Register a routine for debug drawing. The debug draw functions are called\n\t/// inside with b2World::DrawDebugData method. The debug draw object is owned\n\t/// by you and must remain in scope.\n\tvoid SetDebugDraw(b2Draw* debugDraw);\n\n\t/// Create a rigid body given a definition. No reference to the definition\n\t/// is retained.\n\t/// @warning This function is locked during callbacks.\n\tb2Body* CreateBody(const b2BodyDef* def);\n\n\t/// Destroy a rigid body given a definition. No reference to the definition\n\t/// is retained. This function is locked during callbacks.\n\t/// @warning This automatically deletes all associated shapes and joints.\n\t/// @warning This function is locked during callbacks.\n\tvoid DestroyBody(b2Body* body);\n\n\t/// Create a joint to constrain bodies together. No reference to the definition\n\t/// is retained. This may cause the connected bodies to cease colliding.\n\t/// @warning This function is locked during callbacks.\n\tb2Joint* CreateJoint(const b2JointDef* def);\n\n\t/// Destroy a joint. This may cause the connected bodies to begin colliding.\n\t/// @warning This function is locked during callbacks.\n\tvoid DestroyJoint(b2Joint* joint);\n\n\t/// Take a time step. This performs collision detection, integration,\n\t/// and constraint solution.\n\t/// @param timeStep the amount of time to simulate, this should not vary.\n\t/// @param velocityIterations for the velocity constraint solver.\n\t/// @param positionIterations for the position constraint solver.\n\tvoid Step(\tfloat32 timeStep,\n\t\t\t\tint32 velocityIterations,\n\t\t\t\tint32 positionIterations);\n\n\t/// Manually clear the force buffer on all bodies. By default, forces are cleared automatically\n\t/// after each call to Step. The default behavior is modified by calling SetAutoClearForces.\n\t/// The purpose of this function is to support sub-stepping. Sub-stepping is often used to maintain\n\t/// a fixed sized time step under a variable frame-rate.\n\t/// When you perform sub-stepping you will disable auto clearing of forces and instead call\n\t/// ClearForces after all sub-steps are complete in one pass of your game loop.\n\t/// @see SetAutoClearForces\n\tvoid ClearForces();\n\n\t/// Call this to draw shapes and other debug draw data.\n\tvoid DrawDebugData();\n\n\t/// Query the world for all fixtures that potentially overlap the\n\t/// provided AABB.\n\t/// @param callback a user implemented callback class.\n\t/// @param aabb the query box.\n\tvoid QueryAABB(b2QueryCallback* callback, const b2AABB& aabb) const;\n\n\t/// Ray-cast the world for all fixtures in the path of the ray. Your callback\n\t/// controls whether you get the closest point, any point, or n-points.\n\t/// The ray-cast ignores shapes that contain the starting point.\n\t/// @param callback a user implemented callback class.\n\t/// @param point1 the ray starting point\n\t/// @param point2 the ray ending point\n\tvoid RayCast(b2RayCastCallback* callback, const b2Vec2& point1, const b2Vec2& point2) const;\n\n\t/// Get the world body list. With the returned body, use b2Body::GetNext to get\n\t/// the next body in the world list. A NULL body indicates the end of the list.\n\t/// @return the head of the world body list.\n\tb2Body* GetBodyList();\n\tconst b2Body* GetBodyList() const;\n\n\t/// Get the world joint list. With the returned joint, use b2Joint::GetNext to get\n\t/// the next joint in the world list. A NULL joint indicates the end of the list.\n\t/// @return the head of the world joint list.\n\tb2Joint* GetJointList();\n\tconst b2Joint* GetJointList() const;\n\n\t/// Get the world contact list. With the returned contact, use b2Contact::GetNext to get\n\t/// the next contact in the world list. A NULL contact indicates the end of the list.\n\t/// @return the head of the world contact list.\n\t/// @warning contacts are created and destroyed in the middle of a time step.\n\t/// Use b2ContactListener to avoid missing contacts.\n\tb2Contact* GetContactList();\n\tconst b2Contact* GetContactList() const;\n\n\t/// Enable/disable sleep.\n\tvoid SetAllowSleeping(bool flag);\n\tbool GetAllowSleeping() const { return m_allowSleep; }\n\n\t/// Enable/disable warm starting. For testing.\n\tvoid SetWarmStarting(bool flag) { m_warmStarting = flag; }\n\tbool GetWarmStarting() const { return m_warmStarting; }\n\n\t/// Enable/disable continuous physics. For testing.\n\tvoid SetContinuousPhysics(bool flag) { m_continuousPhysics = flag; }\n\tbool GetContinuousPhysics() const { return m_continuousPhysics; }\n\n\t/// Enable/disable single stepped continuous physics. For testing.\n\tvoid SetSubStepping(bool flag) { m_subStepping = flag; }\n\tbool GetSubStepping() const { return m_subStepping; }\n\n\t/// Get the number of broad-phase proxies.\n\tint32 GetProxyCount() const;\n\n\t/// Get the number of bodies.\n\tint32 GetBodyCount() const;\n\n\t/// Get the number of joints.\n\tint32 GetJointCount() const;\n\n\t/// Get the number of contacts (each may have 0 or more contact points).\n\tint32 GetContactCount() const;\n\n\t/// Get the height of the dynamic tree.\n\tint32 GetTreeHeight() const;\n\n\t/// Get the balance of the dynamic tree.\n\tint32 GetTreeBalance() const;\n\n\t/// Get the quality metric of the dynamic tree. The smaller the better.\n\t/// The minimum is 1.\n\tfloat32 GetTreeQuality() const;\n\n\t/// Change the global gravity vector.\n\tvoid SetGravity(const b2Vec2& gravity);\n\t\n\t/// Get the global gravity vector.\n\tb2Vec2 GetGravity() const;\n\n\t/// Is the world locked (in the middle of a time step).\n\tbool IsLocked() const;\n\n\t/// Set flag to control automatic clearing of forces after each time step.\n\tvoid SetAutoClearForces(bool flag);\n\n\t/// Get the flag that controls automatic clearing of forces after each time step.\n\tbool GetAutoClearForces() const;\n\n\t/// Get the contact manager for testing.\n\tconst b2ContactManager& GetContactManager() const;\n\n\t/// Get the current profile.\n\tconst b2Profile& GetProfile() const;\n\n\t/// Dump the world into the log file.\n\t/// @warning this should be called outside of a time step.\n\tvoid Dump();\n\nprivate:\n\n\t// m_flags\n\tenum\n\t{\n\t\te_newFixture\t= 0x0001,\n\t\te_locked\t\t= 0x0002,\n\t\te_clearForces\t= 0x0004\n\t};\n\n\tfriend class b2Body;\n\tfriend class b2Fixture;\n\tfriend class b2ContactManager;\n\tfriend class b2Controller;\n\n\tvoid Solve(const b2TimeStep& step);\n\tvoid SolveTOI(const b2TimeStep& step);\n\n\tvoid DrawJoint(b2Joint* joint);\n\tvoid DrawShape(b2Fixture* shape, const b2Transform& xf, const b2Color& color);\n\n\tb2BlockAllocator m_blockAllocator;\n\tb2StackAllocator m_stackAllocator;\n\n\tint32 m_flags;\n\n\tb2ContactManager m_contactManager;\n\n\tb2Body* m_bodyList;\n\tb2Joint* m_jointList;\n\n\tint32 m_bodyCount;\n\tint32 m_jointCount;\n\n\tb2Vec2 m_gravity;\n\tbool m_allowSleep;\n\n\tb2DestructionListener* m_destructionListener;\n\tb2Draw* m_debugDraw;\n\n\t// This is used to compute the time step ratio to\n\t// support a variable time step.\n\tfloat32 m_inv_dt0;\n\n\t// These are for debugging the solver.\n\tbool m_warmStarting;\n\tbool m_continuousPhysics;\n\tbool m_subStepping;\n\n\tbool m_stepComplete;\n\n\tb2Profile m_profile;\n};\n\ninline b2Body* b2World::GetBodyList()\n{\n\treturn m_bodyList;\n}\n\ninline const b2Body* b2World::GetBodyList() const\n{\n\treturn m_bodyList;\n}\n\ninline b2Joint* b2World::GetJointList()\n{\n\treturn m_jointList;\n}\n\ninline const b2Joint* b2World::GetJointList() const\n{\n\treturn m_jointList;\n}\n\ninline b2Contact* b2World::GetContactList()\n{\n\treturn m_contactManager.m_contactList;\n}\n\ninline const b2Contact* b2World::GetContactList() const\n{\n\treturn m_contactManager.m_contactList;\n}\n\ninline int32 b2World::GetBodyCount() const\n{\n\treturn m_bodyCount;\n}\n\ninline int32 b2World::GetJointCount() const\n{\n\treturn m_jointCount;\n}\n\ninline int32 b2World::GetContactCount() const\n{\n\treturn m_contactManager.m_contactCount;\n}\n\ninline void b2World::SetGravity(const b2Vec2& gravity)\n{\n\tm_gravity = gravity;\n}\n\ninline b2Vec2 b2World::GetGravity() const\n{\n\treturn m_gravity;\n}\n\ninline bool b2World::IsLocked() const\n{\n\treturn (m_flags & e_locked) == e_locked;\n}\n\ninline void b2World::SetAutoClearForces(bool flag)\n{\n\tif (flag)\n\t{\n\t\tm_flags |= e_clearForces;\n\t}\n\telse\n\t{\n\t\tm_flags &= ~e_clearForces;\n\t}\n}\n\n/// Get the flag that controls automatic clearing of forces after each time step.\ninline bool b2World::GetAutoClearForces() const\n{\n\treturn (m_flags & e_clearForces) == e_clearForces;\n}\n\ninline const b2ContactManager& b2World::GetContactManager() const\n{\n\treturn m_contactManager;\n}\n\ninline const b2Profile& b2World::GetProfile() const\n{\n\treturn m_profile;\n}\n\n#endif\n","/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_WHEEL_JOINT_H\r\n#define B2_WHEEL_JOINT_H\r\n\r\n#include <Box2D/Dynamics/Joints/b2Joint.h>\r\n\r\n/// Wheel joint definition. This requires defining a line of\r\n/// motion using an axis and an anchor point. The definition uses local\r\n/// anchor points and a local axis so that the initial configuration\r\n/// can violate the constraint slightly. The joint translation is zero\r\n/// when the local anchor points coincide in world space. Using local\r\n/// anchors and a local axis helps when saving and loading a game.\r\nstruct b2WheelJointDef : public b2JointDef\r\n{\r\n\tb2WheelJointDef()\r\n\t{\r\n\t\ttype = e_wheelJoint;\r\n\t\tlocalAnchorA.SetZero();\r\n\t\tlocalAnchorB.SetZero();\r\n\t\tlocalAxisA.Set(1.0f, 0.0f);\r\n\t\tenableMotor = false;\r\n\t\tmaxMotorTorque = 0.0f;\r\n\t\tmotorSpeed = 0.0f;\r\n\t\tfrequencyHz = 2.0f;\r\n\t\tdampingRatio = 0.7f;\r\n\t}\r\n\r\n\t/// Initialize the bodies, anchors, axis, and reference angle using the world\r\n\t/// anchor and world axis.\r\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor, const b2Vec2& axis);\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tb2Vec2 localAnchorA;\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tb2Vec2 localAnchorB;\r\n\r\n\t/// The local translation axis in bodyA.\r\n\tb2Vec2 localAxisA;\r\n\r\n\t/// Enable/disable the joint motor.\r\n\tbool enableMotor;\r\n\r\n\t/// The maximum motor torque, usually in N-m.\r\n\tfloat32 maxMotorTorque;\r\n\r\n\t/// The desired motor speed in radians per second.\r\n\tfloat32 motorSpeed;\r\n\r\n\t/// Suspension frequency, zero indicates no suspension\r\n\tfloat32 frequencyHz;\r\n\r\n\t/// Suspension damping ratio, one indicates critical damping\r\n\tfloat32 dampingRatio;\r\n};\r\n\r\n/// A wheel joint. This joint provides two degrees of freedom: translation\r\n/// along an axis fixed in bodyA and rotation in the plane. You can use a\r\n/// joint limit to restrict the range of motion and a joint motor to drive\r\n/// the rotation or to model rotational friction.\r\n/// This joint is designed for vehicle suspensions.\r\nclass b2WheelJoint : public b2Joint\r\n{\r\npublic:\r\n\tvoid GetDefinition(b2WheelJointDef* def) const;\r\n\r\n\tb2Vec2 GetAnchorA() const;\r\n\tb2Vec2 GetAnchorB() const;\r\n\r\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\r\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tconst b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tconst b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }\r\n\r\n\t/// The local joint axis relative to bodyA.\r\n\tconst b2Vec2& GetLocalAxisA() const { return m_localXAxisA; }\r\n\r\n\t/// Get the current joint translation, usually in meters.\r\n\tfloat32 GetJointTranslation() const;\r\n\r\n\t/// Get the current joint translation speed, usually in meters per second.\r\n\tfloat32 GetJointSpeed() const;\r\n\r\n\t/// Is the joint motor enabled?\r\n\tbool IsMotorEnabled() const;\r\n\r\n\t/// Enable/disable the joint motor.\r\n\tvoid EnableMotor(bool flag);\r\n\r\n\t/// Set the motor speed, usually in radians per second.\r\n\tvoid SetMotorSpeed(float32 speed);\r\n\r\n\t/// Get the motor speed, usually in radians per second.\r\n\tfloat32 GetMotorSpeed() const;\r\n\r\n\t/// Set/Get the maximum motor force, usually in N-m.\r\n\tvoid SetMaxMotorTorque(float32 torque);\r\n\tfloat32 GetMaxMotorTorque() const;\r\n\r\n\t/// Get the current motor torque given the inverse time step, usually in N-m.\r\n\tfloat32 GetMotorTorque(float32 inv_dt) const;\r\n\r\n\t/// Set/Get the spring frequency in hertz. Setting the frequency to zero disables the spring.\r\n\tvoid SetSpringFrequencyHz(float32 hz);\r\n\tfloat32 GetSpringFrequencyHz() const;\r\n\r\n\t/// Set/Get the spring damping ratio\r\n\tvoid SetSpringDampingRatio(float32 ratio);\r\n\tfloat32 GetSpringDampingRatio() const;\r\n\r\n\t/// Dump to b2Log\r\n\tvoid Dump();\r\n\r\nprotected:\r\n\r\n\tfriend class b2Joint;\r\n\tb2WheelJoint(const b2WheelJointDef* def);\r\n\r\n\tvoid InitVelocityConstraints(const b2SolverData& data);\r\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\r\n\tbool SolvePositionConstraints(const b2SolverData& data);\r\n\r\n\tfloat32 m_frequencyHz;\r\n\tfloat32 m_dampingRatio;\r\n\r\n\t// Solver shared\r\n\tb2Vec2 m_localAnchorA;\r\n\tb2Vec2 m_localAnchorB;\r\n\tb2Vec2 m_localXAxisA;\r\n\tb2Vec2 m_localYAxisA;\r\n\r\n\tfloat32 m_impulse;\r\n\tfloat32 m_motorImpulse;\r\n\tfloat32 m_springImpulse;\r\n\r\n\tfloat32 m_maxMotorTorque;\r\n\tfloat32 m_motorSpeed;\r\n\tbool m_enableMotor;\r\n\r\n\t// Solver temp\r\n\tint32 m_indexA;\r\n\tint32 m_indexB;\r\n\tb2Vec2 m_localCenterA;\r\n\tb2Vec2 m_localCenterB;\r\n\tfloat32 m_invMassA;\r\n\tfloat32 m_invMassB;\r\n\tfloat32 m_invIA;\r\n\tfloat32 m_invIB;\r\n\r\n\tb2Vec2 m_ax, m_ay;\r\n\tfloat32 m_sAx, m_sBx;\r\n\tfloat32 m_sAy, m_sBy;\r\n\r\n\tfloat32 m_mass;\r\n\tfloat32 m_motorMass;\r\n\tfloat32 m_springMass;\r\n\r\n\tfloat32 m_bias;\r\n\tfloat32 m_gamma;\r\n};\r\n\r\ninline float32 b2WheelJoint::GetMotorSpeed() const\r\n{\r\n\treturn m_motorSpeed;\r\n}\r\n\r\ninline float32 b2WheelJoint::GetMaxMotorTorque() const\r\n{\r\n\treturn m_maxMotorTorque;\r\n}\r\n\r\ninline void b2WheelJoint::SetSpringFrequencyHz(float32 hz)\r\n{\r\n\tm_frequencyHz = hz;\r\n}\r\n\r\ninline float32 b2WheelJoint::GetSpringFrequencyHz() const\r\n{\r\n\treturn m_frequencyHz;\r\n}\r\n\r\ninline void b2WheelJoint::SetSpringDampingRatio(float32 ratio)\r\n{\r\n\tm_dampingRatio = ratio;\r\n}\r\n\r\ninline float32 b2WheelJoint::GetSpringDampingRatio() const\r\n{\r\n\treturn m_dampingRatio;\r\n}\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_CIRCLE_SHAPE_H\r\n#define B2_CIRCLE_SHAPE_H\r\n\r\n#include <Box2D/Collision/Shapes/b2Shape.h>\r\n\r\n/// A circle shape.\r\nclass b2CircleShape : public b2Shape\r\n{\r\npublic:\r\n\tb2CircleShape();\r\n\r\n\t/// Implement b2Shape.\r\n\tb2Shape* Clone(b2BlockAllocator* allocator) const;\r\n\r\n\t/// @see b2Shape::GetChildCount\r\n\tint32 GetChildCount() const;\r\n\r\n\t/// Implement b2Shape.\r\n\tbool TestPoint(const b2Transform& transform, const b2Vec2& p) const;\r\n\r\n\t/// Implement b2Shape.\r\n\tbool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,\r\n\t\t\t\tconst b2Transform& transform, int32 childIndex) const;\r\n\r\n\t/// @see b2Shape::ComputeAABB\r\n\tvoid ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;\r\n\r\n\t/// @see b2Shape::ComputeMass\r\n\tvoid ComputeMass(b2MassData* massData, float32 density) const;\r\n\r\n\t/// Get the supporting vertex index in the given direction.\r\n\tint32 GetSupport(const b2Vec2& d) const;\r\n\r\n\t/// Get the supporting vertex in the given direction.\r\n\tconst b2Vec2& GetSupportVertex(const b2Vec2& d) const;\r\n\r\n\t/// Get the vertex count.\r\n\tint32 GetVertexCount() const { return 1; }\r\n\r\n\t/// Get a vertex by index. Used by b2Distance.\r\n\tconst b2Vec2& GetVertex(int32 index) const;\r\n\r\n\t/// Position\r\n\tb2Vec2 m_p;\r\n};\r\n\r\ninline b2CircleShape::b2CircleShape()\r\n{\r\n\tm_type = e_circle;\r\n\tm_radius = 0.0f;\r\n\tm_p.SetZero();\r\n}\r\n\r\ninline int32 b2CircleShape::GetSupport(const b2Vec2 &d) const\r\n{\r\n\tB2_NOT_USED(d);\r\n\treturn 0;\r\n}\r\n\r\ninline const b2Vec2& b2CircleShape::GetSupportVertex(const b2Vec2 &d) const\r\n{\r\n\tB2_NOT_USED(d);\r\n\treturn m_p;\r\n}\r\n\r\ninline const b2Vec2& b2CircleShape::GetVertex(int32 index) const\r\n{\r\n\tB2_NOT_USED(index);\r\n\tb2Assert(index == 0);\r\n\treturn m_p;\r\n}\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_SHAPE_H\r\n#define B2_SHAPE_H\r\n\r\n#include <Box2D/Common/b2BlockAllocator.h>\r\n#include <Box2D/Common/b2Math.h>\r\n#include <Box2D/Collision/b2Collision.h>\r\n\r\n/// This holds the mass data computed for a shape.\r\nstruct b2MassData\r\n{\r\n\t/// The mass of the shape, usually in kilograms.\r\n\tfloat32 mass;\r\n\r\n\t/// The position of the shape's centroid relative to the shape's origin.\r\n\tb2Vec2 center;\r\n\r\n\t/// The rotational inertia of the shape about the local origin.\r\n\tfloat32 I;\r\n};\r\n\r\n/// A shape is used for collision detection. You can create a shape however you like.\r\n/// Shapes used for simulation in b2World are created automatically when a b2Fixture\r\n/// is created. Shapes may encapsulate a one or more child shapes.\r\nclass b2Shape\r\n{\r\npublic:\r\n\t\r\n\tenum Type\r\n\t{\r\n\t\te_circle = 0,\r\n\t\te_edge = 1,\r\n\t\te_polygon = 2,\r\n\t\te_chain = 3,\r\n\t\te_typeCount = 4\r\n\t};\r\n\r\n\tvirtual ~b2Shape() {}\r\n\r\n\t/// Clone the concrete shape using the provided allocator.\r\n\tvirtual b2Shape* Clone(b2BlockAllocator* allocator) const = 0;\r\n\r\n\t/// Get the type of this shape. You can use this to down cast to the concrete shape.\r\n\t/// @return the shape type.\r\n\tType GetType() const;\r\n\r\n\t/// Get the number of child primitives.\r\n\tvirtual int32 GetChildCount() const = 0;\r\n\r\n\t/// Test a point for containment in this shape. This only works for convex shapes.\r\n\t/// @param xf the shape world transform.\r\n\t/// @param p a point in world coordinates.\r\n\tvirtual bool TestPoint(const b2Transform& xf, const b2Vec2& p) const = 0;\r\n\r\n\t/// Cast a ray against a child shape.\r\n\t/// @param output the ray-cast results.\r\n\t/// @param input the ray-cast input parameters.\r\n\t/// @param transform the transform to be applied to the shape.\r\n\t/// @param childIndex the child shape index\r\n\tvirtual bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,\r\n\t\t\t\t\t\tconst b2Transform& transform, int32 childIndex) const = 0;\r\n\r\n\t/// Given a transform, compute the associated axis aligned bounding box for a child shape.\r\n\t/// @param aabb returns the axis aligned box.\r\n\t/// @param xf the world transform of the shape.\r\n\t/// @param childIndex the child shape\r\n\tvirtual void ComputeAABB(b2AABB* aabb, const b2Transform& xf, int32 childIndex) const = 0;\r\n\r\n\t/// Compute the mass properties of this shape using its dimensions and density.\r\n\t/// The inertia tensor is computed about the local origin.\r\n\t/// @param massData returns the mass data for this shape.\r\n\t/// @param density the density in kilograms per meter squared.\r\n\tvirtual void ComputeMass(b2MassData* massData, float32 density) const = 0;\r\n\r\n\tType m_type;\r\n\tfloat32 m_radius;\r\n};\r\n\r\ninline b2Shape::Type b2Shape::GetType() const\r\n{\r\n\treturn m_type;\r\n}\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_WELD_JOINT_H\r\n#define B2_WELD_JOINT_H\r\n\r\n#include <Box2D/Dynamics/Joints/b2Joint.h>\r\n\r\n/// Weld joint definition. You need to specify local anchor points\r\n/// where they are attached and the relative body angle. The position\r\n/// of the anchor points is important for computing the reaction torque.\r\nstruct b2WeldJointDef : public b2JointDef\r\n{\r\n\tb2WeldJointDef()\r\n\t{\r\n\t\ttype = e_weldJoint;\r\n\t\tlocalAnchorA.Set(0.0f, 0.0f);\r\n\t\tlocalAnchorB.Set(0.0f, 0.0f);\r\n\t\treferenceAngle = 0.0f;\r\n\t\tfrequencyHz = 0.0f;\r\n\t\tdampingRatio = 0.0f;\r\n\t}\r\n\r\n\t/// Initialize the bodies, anchors, and reference angle using a world\r\n\t/// anchor point.\r\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor);\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tb2Vec2 localAnchorA;\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tb2Vec2 localAnchorB;\r\n\r\n\t/// The bodyB angle minus bodyA angle in the reference state (radians).\r\n\tfloat32 referenceAngle;\r\n\t\r\n\t/// The mass-spring-damper frequency in Hertz. Rotation only.\r\n\t/// Disable softness with a value of 0.\r\n\tfloat32 frequencyHz;\r\n\r\n\t/// The damping ratio. 0 = no damping, 1 = critical damping.\r\n\tfloat32 dampingRatio;\r\n};\r\n\r\n/// A weld joint essentially glues two bodies together. A weld joint may\r\n/// distort somewhat because the island constraint solver is approximate.\r\nclass b2WeldJoint : public b2Joint\r\n{\r\npublic:\r\n\tb2Vec2 GetAnchorA() const;\r\n\tb2Vec2 GetAnchorB() const;\r\n\r\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\r\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tconst b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tconst b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }\r\n\r\n\t/// Get the reference angle.\r\n\tfloat32 GetReferenceAngle() const { return m_referenceAngle; }\r\n\r\n\t/// Set/get frequency in Hz.\r\n\tvoid SetFrequency(float32 hz) { m_frequencyHz = hz; }\r\n\tfloat32 GetFrequency() const { return m_frequencyHz; }\r\n\r\n\t/// Set/get damping ratio.\r\n\tvoid SetDampingRatio(float32 ratio) { m_dampingRatio = ratio; }\r\n\tfloat32 GetDampingRatio() const { return m_dampingRatio; }\r\n\r\n\t/// Dump to b2Log\r\n\tvoid Dump();\r\n\r\nprotected:\r\n\r\n\tfriend class b2Joint;\r\n\r\n\tb2WeldJoint(const b2WeldJointDef* def);\r\n\r\n\tvoid InitVelocityConstraints(const b2SolverData& data);\r\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\r\n\tbool SolvePositionConstraints(const b2SolverData& data);\r\n\r\n\tfloat32 m_frequencyHz;\r\n\tfloat32 m_dampingRatio;\r\n\tfloat32 m_bias;\r\n\r\n\t// Solver shared\r\n\tb2Vec2 m_localAnchorA;\r\n\tb2Vec2 m_localAnchorB;\r\n\tfloat32 m_referenceAngle;\r\n\tfloat32 m_gamma;\r\n\tb2Vec3 m_impulse;\r\n\r\n\t// Solver temp\r\n\tint32 m_indexA;\r\n\tint32 m_indexB;\r\n\tb2Vec2 m_rA;\r\n\tb2Vec2 m_rB;\r\n\tb2Vec2 m_localCenterA;\r\n\tb2Vec2 m_localCenterB;\r\n\tfloat32 m_invMassA;\r\n\tfloat32 m_invMassB;\r\n\tfloat32 m_invIA;\r\n\tfloat32 m_invIB;\r\n\tb2Mat33 m_mass;\r\n};\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_GEAR_JOINT_H\r\n#define B2_GEAR_JOINT_H\r\n\r\n#include <Box2D/Dynamics/Joints/b2Joint.h>\r\n\r\n/// Gear joint definition. This definition requires two existing\r\n/// revolute or prismatic joints (any combination will work).\r\nstruct b2GearJointDef : public b2JointDef\r\n{\r\n\tb2GearJointDef()\r\n\t{\r\n\t\ttype = e_gearJoint;\r\n\t\tjoint1 = NULL;\r\n\t\tjoint2 = NULL;\r\n\t\tratio = 1.0f;\r\n\t}\r\n\r\n\t/// The first revolute/prismatic joint attached to the gear joint.\r\n\tb2Joint* joint1;\r\n\r\n\t/// The second revolute/prismatic joint attached to the gear joint.\r\n\tb2Joint* joint2;\r\n\r\n\t/// The gear ratio.\r\n\t/// @see b2GearJoint for explanation.\r\n\tfloat32 ratio;\r\n};\r\n\r\n/// A gear joint is used to connect two joints together. Either joint\r\n/// can be a revolute or prismatic joint. You specify a gear ratio\r\n/// to bind the motions together:\r\n/// coordinate1 + ratio * coordinate2 = constant\r\n/// The ratio can be negative or positive. If one joint is a revolute joint\r\n/// and the other joint is a prismatic joint, then the ratio will have units\r\n/// of length or units of 1/length.\r\n/// @warning You have to manually destroy the gear joint if joint1 or joint2\r\n/// is destroyed.\r\nclass b2GearJoint : public b2Joint\r\n{\r\npublic:\r\n\tb2Vec2 GetAnchorA() const;\r\n\tb2Vec2 GetAnchorB() const;\r\n\r\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\r\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\r\n\r\n\t/// Get the first joint.\r\n\tb2Joint* GetJoint1() { return m_joint1; }\r\n\r\n\t/// Get the second joint.\r\n\tb2Joint* GetJoint2() { return m_joint2; }\r\n\r\n\t/// Set/Get the gear ratio.\r\n\tvoid SetRatio(float32 ratio);\r\n\tfloat32 GetRatio() const;\r\n\r\n\t/// Dump joint to dmLog\r\n\tvoid Dump();\r\n\r\nprotected:\r\n\r\n\tfriend class b2Joint;\r\n\tb2GearJoint(const b2GearJointDef* data);\r\n\r\n\tvoid InitVelocityConstraints(const b2SolverData& data);\r\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\r\n\tbool SolvePositionConstraints(const b2SolverData& data);\r\n\r\n\tb2Joint* m_joint1;\r\n\tb2Joint* m_joint2;\r\n\r\n\tb2JointType m_typeA;\r\n\tb2JointType m_typeB;\r\n\r\n\t// Body A is connected to body C\r\n\t// Body B is connected to body D\r\n\tb2Body* m_bodyC;\r\n\tb2Body* m_bodyD;\r\n\r\n\t// Solver shared\r\n\tb2Vec2 m_localAnchorA;\r\n\tb2Vec2 m_localAnchorB;\r\n\tb2Vec2 m_localAnchorC;\r\n\tb2Vec2 m_localAnchorD;\r\n\r\n\tb2Vec2 m_localAxisC;\r\n\tb2Vec2 m_localAxisD;\r\n\r\n\tfloat32 m_referenceAngleA;\r\n\tfloat32 m_referenceAngleB;\r\n\r\n\tfloat32 m_constant;\r\n\tfloat32 m_ratio;\r\n\r\n\tfloat32 m_impulse;\r\n\r\n\t// Solver temp\r\n\tint32 m_indexA, m_indexB, m_indexC, m_indexD;\r\n\tb2Vec2 m_lcA, m_lcB, m_lcC, m_lcD;\r\n\tfloat32 m_mA, m_mB, m_mC, m_mD;\r\n\tfloat32 m_iA, m_iB, m_iC, m_iD;\r\n\tb2Vec2 m_JvAC, m_JvBD;\r\n\tfloat32 m_JwA, m_JwB, m_JwC, m_JwD;\r\n\tfloat32 m_mass;\r\n};\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_PULLEY_JOINT_H\r\n#define B2_PULLEY_JOINT_H\r\n\r\n#include <Box2D/Dynamics/Joints/b2Joint.h>\r\n\r\nconst float32 b2_minPulleyLength = 2.0f;\r\n\r\n/// Pulley joint definition. This requires two ground anchors,\r\n/// two dynamic body anchor points, and a pulley ratio.\r\nstruct b2PulleyJointDef : public b2JointDef\r\n{\r\n\tb2PulleyJointDef()\r\n\t{\r\n\t\ttype = e_pulleyJoint;\r\n\t\tgroundAnchorA.Set(-1.0f, 1.0f);\r\n\t\tgroundAnchorB.Set(1.0f, 1.0f);\r\n\t\tlocalAnchorA.Set(-1.0f, 0.0f);\r\n\t\tlocalAnchorB.Set(1.0f, 0.0f);\r\n\t\tlengthA = 0.0f;\r\n\t\tlengthB = 0.0f;\r\n\t\tratio = 1.0f;\r\n\t\tcollideConnected = true;\r\n\t}\r\n\r\n\t/// Initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.\r\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB,\r\n\t\t\t\t\tconst b2Vec2& groundAnchorA, const b2Vec2& groundAnchorB,\r\n\t\t\t\t\tconst b2Vec2& anchorA, const b2Vec2& anchorB,\r\n\t\t\t\t\tfloat32 ratio);\r\n\r\n\t/// The first ground anchor in world coordinates. This point never moves.\r\n\tb2Vec2 groundAnchorA;\r\n\r\n\t/// The second ground anchor in world coordinates. This point never moves.\r\n\tb2Vec2 groundAnchorB;\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tb2Vec2 localAnchorA;\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tb2Vec2 localAnchorB;\r\n\r\n\t/// The a reference length for the segment attached to bodyA.\r\n\tfloat32 lengthA;\r\n\r\n\t/// The a reference length for the segment attached to bodyB.\r\n\tfloat32 lengthB;\r\n\r\n\t/// The pulley ratio, used to simulate a block-and-tackle.\r\n\tfloat32 ratio;\r\n};\r\n\r\n/// The pulley joint is connected to two bodies and two fixed ground points.\r\n/// The pulley supports a ratio such that:\r\n/// length1 + ratio * length2 <= constant\r\n/// Yes, the force transmitted is scaled by the ratio.\r\n/// Warning: the pulley joint can get a bit squirrelly by itself. They often\r\n/// work better when combined with prismatic joints. You should also cover the\r\n/// the anchor points with static shapes to prevent one side from going to\r\n/// zero length.\r\nclass b2PulleyJoint : public b2Joint\r\n{\r\npublic:\r\n\tb2Vec2 GetAnchorA() const;\r\n\tb2Vec2 GetAnchorB() const;\r\n\r\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\r\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\r\n\r\n\t/// Get the first ground anchor.\r\n\tb2Vec2 GetGroundAnchorA() const;\r\n\r\n\t/// Get the second ground anchor.\r\n\tb2Vec2 GetGroundAnchorB() const;\r\n\r\n\t/// Get the current length of the segment attached to bodyA.\r\n\tfloat32 GetLengthA() const;\r\n\r\n\t/// Get the current length of the segment attached to bodyB.\r\n\tfloat32 GetLengthB() const;\r\n\r\n\t/// Get the pulley ratio.\r\n\tfloat32 GetRatio() const;\r\n\r\n\t/// Dump joint to dmLog\r\n\tvoid Dump();\r\n\r\nprotected:\r\n\r\n\tfriend class b2Joint;\r\n\tb2PulleyJoint(const b2PulleyJointDef* data);\r\n\r\n\tvoid InitVelocityConstraints(const b2SolverData& data);\r\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\r\n\tbool SolvePositionConstraints(const b2SolverData& data);\r\n\r\n\tb2Vec2 m_groundAnchorA;\r\n\tb2Vec2 m_groundAnchorB;\r\n\tfloat32 m_lengthA;\r\n\tfloat32 m_lengthB;\r\n\t\r\n\t// Solver shared\r\n\tb2Vec2 m_localAnchorA;\r\n\tb2Vec2 m_localAnchorB;\r\n\tfloat32 m_constant;\r\n\tfloat32 m_ratio;\r\n\tfloat32 m_impulse;\r\n\r\n\t// Solver temp\r\n\tint32 m_indexA;\r\n\tint32 m_indexB;\r\n\tb2Vec2 m_uA;\r\n\tb2Vec2 m_uB;\r\n\tb2Vec2 m_rA;\r\n\tb2Vec2 m_rB;\r\n\tb2Vec2 m_localCenterA;\r\n\tb2Vec2 m_localCenterB;\r\n\tfloat32 m_invMassA;\r\n\tfloat32 m_invMassB;\r\n\tfloat32 m_invIA;\r\n\tfloat32 m_invIB;\r\n\tfloat32 m_mass;\r\n};\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2010 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_CHAIN_SHAPE_H\r\n#define B2_CHAIN_SHAPE_H\r\n\r\n#include <Box2D/Collision/Shapes/b2Shape.h>\r\n\r\nclass b2EdgeShape;\r\n\r\n/// A chain shape is a free form sequence of line segments.\r\n/// The chain has two-sided collision, so you can use inside and outside collision.\r\n/// Therefore, you may use any winding order.\r\n/// Since there may be many vertices, they are allocated using b2Alloc.\r\n/// Connectivity information is used to create smooth collisions.\r\n/// WARNING: The chain will not collide properly if there are self-intersections.\r\nclass b2ChainShape : public b2Shape\r\n{\r\npublic:\r\n\tb2ChainShape();\r\n\r\n\t/// The destructor frees the vertices using b2Free.\r\n\t~b2ChainShape();\r\n\r\n\t/// Create a loop. This automatically adjusts connectivity.\r\n\t/// @param vertices an array of vertices, these are copied\r\n\t/// @param count the vertex count\r\n\tvoid CreateLoop(const b2Vec2* vertices, int32 count);\r\n\r\n\t/// Create a chain with isolated end vertices.\r\n\t/// @param vertices an array of vertices, these are copied\r\n\t/// @param count the vertex count\r\n\tvoid CreateChain(const b2Vec2* vertices, int32 count);\r\n\r\n\t/// Establish connectivity to a vertex that precedes the first vertex.\r\n\t/// Don't call this for loops.\r\n\tvoid SetPrevVertex(const b2Vec2& prevVertex);\r\n\r\n\t/// Establish connectivity to a vertex that follows the last vertex.\r\n\t/// Don't call this for loops.\r\n\tvoid SetNextVertex(const b2Vec2& nextVertex);\r\n\r\n\t/// Implement b2Shape. Vertices are cloned using b2Alloc.\r\n\tb2Shape* Clone(b2BlockAllocator* allocator) const;\r\n\r\n\t/// @see b2Shape::GetChildCount\r\n\tint32 GetChildCount() const;\r\n\r\n\t/// Get a child edge.\r\n\tvoid GetChildEdge(b2EdgeShape* edge, int32 index) const;\r\n\r\n\t/// This always return false.\r\n\t/// @see b2Shape::TestPoint\r\n\tbool TestPoint(const b2Transform& transform, const b2Vec2& p) const;\r\n\r\n\t/// Implement b2Shape.\r\n\tbool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,\r\n\t\t\t\t\tconst b2Transform& transform, int32 childIndex) const;\r\n\r\n\t/// @see b2Shape::ComputeAABB\r\n\tvoid ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;\r\n\r\n\t/// Chains have zero mass.\r\n\t/// @see b2Shape::ComputeMass\r\n\tvoid ComputeMass(b2MassData* massData, float32 density) const;\r\n\r\n\t/// The vertices. Owned by this class.\r\n\tb2Vec2* m_vertices;\r\n\r\n\t/// The vertex count.\r\n\tint32 m_count;\r\n\r\n\tb2Vec2 m_prevVertex, m_nextVertex;\r\n\tbool m_hasPrevVertex, m_hasNextVertex;\r\n};\r\n\r\ninline b2ChainShape::b2ChainShape()\r\n{\r\n\tm_type = e_chain;\r\n\tm_radius = b2_polygonRadius;\r\n\tm_vertices = NULL;\r\n\tm_count = 0;\r\n\tm_hasPrevVertex = NULL;\r\n\tm_hasNextVertex = NULL;\r\n}\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2011 Erin Catto http://box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#include <Box2D/Common/b2Math.h>\r\n\r\n/// Color for debug drawing. Each value has the range [0,1].\r\nstruct b2Color\r\n{\r\n\tb2Color() {}\r\n\tb2Color(float32 r, float32 g, float32 b) : r(r), g(g), b(b) {}\r\n\tvoid Set(float32 ri, float32 gi, float32 bi) { r = ri; g = gi; b = bi; }\r\n\tfloat32 r, g, b;\r\n};\r\n\r\n/// Implement and register this class with a b2World to provide debug drawing of physics\r\n/// entities in your game.\r\nclass b2Draw\r\n{\r\npublic:\r\n\tb2Draw();\r\n\r\n\tvirtual ~b2Draw() {}\r\n\r\n\tenum\r\n\t{\r\n\t\te_shapeBit\t\t\t\t= 0x0001,\t///< draw shapes\r\n\t\te_jointBit\t\t\t\t= 0x0002,\t///< draw joint connections\r\n\t\te_aabbBit\t\t\t\t= 0x0004,\t///< draw axis aligned bounding boxes\r\n\t\te_pairBit\t\t\t\t= 0x0008,\t///< draw broad-phase pairs\r\n\t\te_centerOfMassBit\t\t= 0x0010\t///< draw center of mass frame\r\n\t};\r\n\r\n\t/// Set the drawing flags.\r\n\tvoid SetFlags(uint32 flags);\r\n\r\n\t/// Get the drawing flags.\r\n\tuint32 GetFlags() const;\r\n\t\r\n\t/// Append flags to the current flags.\r\n\tvoid AppendFlags(uint32 flags);\r\n\r\n\t/// Clear flags from the current flags.\r\n\tvoid ClearFlags(uint32 flags);\r\n\r\n\t/// Draw a closed polygon provided in CCW order.\r\n\tvirtual void DrawPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color) = 0;\r\n\r\n\t/// Draw a solid closed polygon provided in CCW order.\r\n\tvirtual void DrawSolidPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color) = 0;\r\n\r\n\t/// Draw a circle.\r\n\tvirtual void DrawCircle(const b2Vec2& center, float32 radius, const b2Color& color) = 0;\r\n\t\r\n\t/// Draw a solid circle.\r\n\tvirtual void DrawSolidCircle(const b2Vec2& center, float32 radius, const b2Vec2& axis, const b2Color& color) = 0;\r\n\t\r\n\t/// Draw a line segment.\r\n\tvirtual void DrawSegment(const b2Vec2& p1, const b2Vec2& p2, const b2Color& color) = 0;\r\n\r\n\t/// Draw a transform. Choose your own length scale.\r\n\t/// @param xf a transform.\r\n\tvirtual void DrawTransform(const b2Transform& xf) = 0;\r\n\r\nprotected:\r\n\tuint32 m_drawFlags;\r\n};\r\n","/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_ROPE_JOINT_H\r\n#define B2_ROPE_JOINT_H\r\n\r\n#include <Box2D/Dynamics/Joints/b2Joint.h>\r\n\r\n/// Rope joint definition. This requires two body anchor points and\r\n/// a maximum lengths.\r\n/// Note: by default the connected objects will not collide.\r\n/// see collideConnected in b2JointDef.\r\nstruct b2RopeJointDef : public b2JointDef\r\n{\r\n\tb2RopeJointDef()\r\n\t{\r\n\t\ttype = e_ropeJoint;\r\n\t\tlocalAnchorA.Set(-1.0f, 0.0f);\r\n\t\tlocalAnchorB.Set(1.0f, 0.0f);\r\n\t\tmaxLength = 0.0f;\r\n\t}\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tb2Vec2 localAnchorA;\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tb2Vec2 localAnchorB;\r\n\r\n\t/// The maximum length of the rope.\r\n\t/// Warning: this must be larger than b2_linearSlop or\r\n\t/// the joint will have no effect.\r\n\tfloat32 maxLength;\r\n};\r\n\r\n/// A rope joint enforces a maximum distance between two points\r\n/// on two bodies. It has no other effect.\r\n/// Warning: if you attempt to change the maximum length during\r\n/// the simulation you will get some non-physical behavior.\r\n/// A model that would allow you to dynamically modify the length\r\n/// would have some sponginess, so I chose not to implement it\r\n/// that way. See b2DistanceJoint if you want to dynamically\r\n/// control length.\r\nclass b2RopeJoint : public b2Joint\r\n{\r\npublic:\r\n\tb2Vec2 GetAnchorA() const;\r\n\tb2Vec2 GetAnchorB() const;\r\n\r\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\r\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tconst b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tconst b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }\r\n\r\n\t/// Set/Get the maximum length of the rope.\r\n\tvoid SetMaxLength(float32 length) { m_maxLength = length; }\r\n\tfloat32 GetMaxLength() const;\r\n\r\n\tb2LimitState GetLimitState() const;\r\n\r\n\t/// Dump joint to dmLog\r\n\tvoid Dump();\r\n\r\nprotected:\r\n\r\n\tfriend class b2Joint;\r\n\tb2RopeJoint(const b2RopeJointDef* data);\r\n\r\n\tvoid InitVelocityConstraints(const b2SolverData& data);\r\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\r\n\tbool SolvePositionConstraints(const b2SolverData& data);\r\n\r\n\t// Solver shared\r\n\tb2Vec2 m_localAnchorA;\r\n\tb2Vec2 m_localAnchorB;\r\n\tfloat32 m_maxLength;\r\n\tfloat32 m_length;\r\n\tfloat32 m_impulse;\r\n\r\n\t// Solver temp\r\n\tint32 m_indexA;\r\n\tint32 m_indexB;\r\n\tb2Vec2 m_u;\r\n\tb2Vec2 m_rA;\r\n\tb2Vec2 m_rB;\r\n\tb2Vec2 m_localCenterA;\r\n\tb2Vec2 m_localCenterB;\r\n\tfloat32 m_invMassA;\r\n\tfloat32 m_invMassB;\r\n\tfloat32 m_invIA;\r\n\tfloat32 m_invIB;\r\n\tfloat32 m_mass;\r\n\tb2LimitState m_state;\r\n};\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_POLYGON_SHAPE_H\r\n#define B2_POLYGON_SHAPE_H\r\n\r\n#include <Box2D/Collision/Shapes/b2Shape.h>\r\n\r\n/// A convex polygon. It is assumed that the interior of the polygon is to\r\n/// the left of each edge.\r\n/// Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.\r\n/// In most cases you should not need many vertices for a convex polygon.\r\nclass b2PolygonShape : public b2Shape\r\n{\r\npublic:\r\n\tb2PolygonShape();\r\n\r\n\t/// Implement b2Shape.\r\n\tb2Shape* Clone(b2BlockAllocator* allocator) const;\r\n\r\n\t/// @see b2Shape::GetChildCount\r\n\tint32 GetChildCount() const;\r\n\r\n\t/// Copy vertices. This assumes the vertices define a convex polygon.\r\n\t/// It is assumed that the exterior is the the right of each edge.\r\n\t/// The count must be in the range [3, b2_maxPolygonVertices].\r\n\tvoid Set(const b2Vec2* vertices, int32 vertexCount);\r\n\r\n\t/// Build vertices to represent an axis-aligned box.\r\n\t/// @param hx the half-width.\r\n\t/// @param hy the half-height.\r\n\tvoid SetAsBox(float32 hx, float32 hy);\r\n\r\n\t/// Build vertices to represent an oriented box.\r\n\t/// @param hx the half-width.\r\n\t/// @param hy the half-height.\r\n\t/// @param center the center of the box in local coordinates.\r\n\t/// @param angle the rotation of the box in local coordinates.\r\n\tvoid SetAsBox(float32 hx, float32 hy, const b2Vec2& center, float32 angle);\r\n\r\n\t/// @see b2Shape::TestPoint\r\n\tbool TestPoint(const b2Transform& transform, const b2Vec2& p) const;\r\n\r\n\t/// Implement b2Shape.\r\n\tbool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,\r\n\t\t\t\t\tconst b2Transform& transform, int32 childIndex) const;\r\n\r\n\t/// @see b2Shape::ComputeAABB\r\n\tvoid ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;\r\n\r\n\t/// @see b2Shape::ComputeMass\r\n\tvoid ComputeMass(b2MassData* massData, float32 density) const;\r\n\r\n\t/// Get the vertex count.\r\n\tint32 GetVertexCount() const { return m_vertexCount; }\r\n\r\n\t/// Get a vertex by index.\r\n\tconst b2Vec2& GetVertex(int32 index) const;\r\n\r\n\tb2Vec2 m_centroid;\r\n\tb2Vec2 m_vertices[b2_maxPolygonVertices];\r\n\tb2Vec2 m_normals[b2_maxPolygonVertices];\r\n\tint32 m_vertexCount;\r\n};\r\n\r\ninline b2PolygonShape::b2PolygonShape()\r\n{\r\n\tm_type = e_polygon;\r\n\tm_radius = b2_polygonRadius;\r\n\tm_vertexCount = 0;\r\n\tm_centroid.SetZero();\r\n}\r\n\r\ninline const b2Vec2& b2PolygonShape::GetVertex(int32 index) const\r\n{\r\n\tb2Assert(0 <= index && index < m_vertexCount);\r\n\treturn m_vertices[index];\r\n}\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2010 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_EDGE_SHAPE_H\r\n#define B2_EDGE_SHAPE_H\r\n\r\n#include <Box2D/Collision/Shapes/b2Shape.h>\r\n\r\n/// A line segment (edge) shape. These can be connected in chains or loops\r\n/// to other edge shapes. The connectivity information is used to ensure\r\n/// correct contact normals.\r\nclass b2EdgeShape : public b2Shape\r\n{\r\npublic:\r\n\tb2EdgeShape();\r\n\r\n\t/// Set this as an isolated edge.\r\n\tvoid Set(const b2Vec2& v1, const b2Vec2& v2);\r\n\r\n\t/// Implement b2Shape.\r\n\tb2Shape* Clone(b2BlockAllocator* allocator) const;\r\n\r\n\t/// @see b2Shape::GetChildCount\r\n\tint32 GetChildCount() const;\r\n\r\n\t/// @see b2Shape::TestPoint\r\n\tbool TestPoint(const b2Transform& transform, const b2Vec2& p) const;\r\n\r\n\t/// Implement b2Shape.\r\n\tbool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,\r\n\t\t\t\tconst b2Transform& transform, int32 childIndex) const;\r\n\r\n\t/// @see b2Shape::ComputeAABB\r\n\tvoid ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;\r\n\r\n\t/// @see b2Shape::ComputeMass\r\n\tvoid ComputeMass(b2MassData* massData, float32 density) const;\r\n\t\r\n\t/// These are the edge vertices\r\n\tb2Vec2 m_vertex1, m_vertex2;\r\n\r\n\t/// Optional adjacent vertices. These are used for smooth collision.\r\n\tb2Vec2 m_vertex0, m_vertex3;\r\n\tbool m_hasVertex0, m_hasVertex3;\r\n};\r\n\r\ninline b2EdgeShape::b2EdgeShape()\r\n{\r\n\tm_type = e_edge;\r\n\tm_radius = b2_polygonRadius;\r\n\tm_vertex0.x = 0.0f;\r\n\tm_vertex0.y = 0.0f;\r\n\tm_vertex3.x = 0.0f;\r\n\tm_vertex3.y = 0.0f;\r\n\tm_hasVertex0 = false;\r\n\tm_hasVertex3 = false;\r\n}\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_REVOLUTE_JOINT_H\r\n#define B2_REVOLUTE_JOINT_H\r\n\r\n#include <Box2D/Dynamics/Joints/b2Joint.h>\r\n\r\n/// Revolute joint definition. This requires defining an\r\n/// anchor point where the bodies are joined. The definition\r\n/// uses local anchor points so that the initial configuration\r\n/// can violate the constraint slightly. You also need to\r\n/// specify the initial relative angle for joint limits. This\r\n/// helps when saving and loading a game.\r\n/// The local anchor points are measured from the body's origin\r\n/// rather than the center of mass because:\r\n/// 1. you might not know where the center of mass will be.\r\n/// 2. if you add/remove shapes from a body and recompute the mass,\r\n///    the joints will be broken.\r\nstruct b2RevoluteJointDef : public b2JointDef\r\n{\r\n\tb2RevoluteJointDef()\r\n\t{\r\n\t\ttype = e_revoluteJoint;\r\n\t\tlocalAnchorA.Set(0.0f, 0.0f);\r\n\t\tlocalAnchorB.Set(0.0f, 0.0f);\r\n\t\treferenceAngle = 0.0f;\r\n\t\tlowerAngle = 0.0f;\r\n\t\tupperAngle = 0.0f;\r\n\t\tmaxMotorTorque = 0.0f;\r\n\t\tmotorSpeed = 0.0f;\r\n\t\tenableLimit = false;\r\n\t\tenableMotor = false;\r\n\t}\r\n\r\n\t/// Initialize the bodies, anchors, and reference angle using a world\r\n\t/// anchor point.\r\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor);\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tb2Vec2 localAnchorA;\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tb2Vec2 localAnchorB;\r\n\r\n\t/// The bodyB angle minus bodyA angle in the reference state (radians).\r\n\tfloat32 referenceAngle;\r\n\r\n\t/// A flag to enable joint limits.\r\n\tbool enableLimit;\r\n\r\n\t/// The lower angle for the joint limit (radians).\r\n\tfloat32 lowerAngle;\r\n\r\n\t/// The upper angle for the joint limit (radians).\r\n\tfloat32 upperAngle;\r\n\r\n\t/// A flag to enable the joint motor.\r\n\tbool enableMotor;\r\n\r\n\t/// The desired motor speed. Usually in radians per second.\r\n\tfloat32 motorSpeed;\r\n\r\n\t/// The maximum motor torque used to achieve the desired motor speed.\r\n\t/// Usually in N-m.\r\n\tfloat32 maxMotorTorque;\r\n};\r\n\r\n/// A revolute joint constrains two bodies to share a common point while they\r\n/// are free to rotate about the point. The relative rotation about the shared\r\n/// point is the joint angle. You can limit the relative rotation with\r\n/// a joint limit that specifies a lower and upper angle. You can use a motor\r\n/// to drive the relative rotation about the shared point. A maximum motor torque\r\n/// is provided so that infinite forces are not generated.\r\nclass b2RevoluteJoint : public b2Joint\r\n{\r\npublic:\r\n\tb2Vec2 GetAnchorA() const;\r\n\tb2Vec2 GetAnchorB() const;\r\n\r\n\t/// The local anchor point relative to bodyA's origin.\r\n\tconst b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }\r\n\r\n\t/// The local anchor point relative to bodyB's origin.\r\n\tconst b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }\r\n\r\n\t/// Get the reference angle.\r\n\tfloat32 GetReferenceAngle() const { return m_referenceAngle; }\r\n\r\n\t/// Get the current joint angle in radians.\r\n\tfloat32 GetJointAngle() const;\r\n\r\n\t/// Get the current joint angle speed in radians per second.\r\n\tfloat32 GetJointSpeed() const;\r\n\r\n\t/// Is the joint limit enabled?\r\n\tbool IsLimitEnabled() const;\r\n\r\n\t/// Enable/disable the joint limit.\r\n\tvoid EnableLimit(bool flag);\r\n\r\n\t/// Get the lower joint limit in radians.\r\n\tfloat32 GetLowerLimit() const;\r\n\r\n\t/// Get the upper joint limit in radians.\r\n\tfloat32 GetUpperLimit() const;\r\n\r\n\t/// Set the joint limits in radians.\r\n\tvoid SetLimits(float32 lower, float32 upper);\r\n\r\n\t/// Is the joint motor enabled?\r\n\tbool IsMotorEnabled() const;\r\n\r\n\t/// Enable/disable the joint motor.\r\n\tvoid EnableMotor(bool flag);\r\n\r\n\t/// Set the motor speed in radians per second.\r\n\tvoid SetMotorSpeed(float32 speed);\r\n\r\n\t/// Get the motor speed in radians per second.\r\n\tfloat32 GetMotorSpeed() const;\r\n\r\n\t/// Set the maximum motor torque, usually in N-m.\r\n\tvoid SetMaxMotorTorque(float32 torque);\r\n\tfloat32 GetMaxMotorTorque() const { return m_maxMotorTorque; }\r\n\r\n\t/// Get the reaction force given the inverse time step.\r\n\t/// Unit is N.\r\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\r\n\r\n\t/// Get the reaction torque due to the joint limit given the inverse time step.\r\n\t/// Unit is N*m.\r\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\r\n\r\n\t/// Get the current motor torque given the inverse time step.\r\n\t/// Unit is N*m.\r\n\tfloat32 GetMotorTorque(float32 inv_dt) const;\r\n\r\n\t/// Dump to b2Log.\r\n\tvoid Dump();\r\n\r\nprotected:\r\n\t\r\n\tfriend class b2Joint;\r\n\tfriend class b2GearJoint;\r\n\r\n\tb2RevoluteJoint(const b2RevoluteJointDef* def);\r\n\r\n\tvoid InitVelocityConstraints(const b2SolverData& data);\r\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\r\n\tbool SolvePositionConstraints(const b2SolverData& data);\r\n\r\n\t// Solver shared\r\n\tb2Vec2 m_localAnchorA;\r\n\tb2Vec2 m_localAnchorB;\r\n\tb2Vec3 m_impulse;\r\n\tfloat32 m_motorImpulse;\r\n\r\n\tbool m_enableMotor;\r\n\tfloat32 m_maxMotorTorque;\r\n\tfloat32 m_motorSpeed;\r\n\r\n\tbool m_enableLimit;\r\n\tfloat32 m_referenceAngle;\r\n\tfloat32 m_lowerAngle;\r\n\tfloat32 m_upperAngle;\r\n\r\n\t// Solver temp\r\n\tint32 m_indexA;\r\n\tint32 m_indexB;\r\n\tb2Vec2 m_rA;\r\n\tb2Vec2 m_rB;\r\n\tb2Vec2 m_localCenterA;\r\n\tb2Vec2 m_localCenterB;\r\n\tfloat32 m_invMassA;\r\n\tfloat32 m_invMassB;\r\n\tfloat32 m_invIA;\r\n\tfloat32 m_invIB;\r\n\tb2Mat33 m_mass;\t\t\t// effective mass for point-to-point constraint.\r\n\tfloat32 m_motorMass;\t// effective mass for motor/limit angular constraint.\r\n\tb2LimitState m_limitState;\r\n};\r\n\r\ninline float32 b2RevoluteJoint::GetMotorSpeed() const\r\n{\r\n\treturn m_motorSpeed;\r\n}\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_MOUSE_JOINT_H\r\n#define B2_MOUSE_JOINT_H\r\n\r\n#include <Box2D/Dynamics/Joints/b2Joint.h>\r\n\r\n/// Mouse joint definition. This requires a world target point,\r\n/// tuning parameters, and the time step.\r\nstruct b2MouseJointDef : public b2JointDef\r\n{\r\n\tb2MouseJointDef()\r\n\t{\r\n\t\ttype = e_mouseJoint;\r\n\t\ttarget.Set(0.0f, 0.0f);\r\n\t\tmaxForce = 0.0f;\r\n\t\tfrequencyHz = 5.0f;\r\n\t\tdampingRatio = 0.7f;\r\n\t}\r\n\r\n\t/// The initial world target point. This is assumed\r\n\t/// to coincide with the body anchor initially.\r\n\tb2Vec2 target;\r\n\r\n\t/// The maximum constraint force that can be exerted\r\n\t/// to move the candidate body. Usually you will express\r\n\t/// as some multiple of the weight (multiplier * mass * gravity).\r\n\tfloat32 maxForce;\r\n\r\n\t/// The response speed.\r\n\tfloat32 frequencyHz;\r\n\r\n\t/// The damping ratio. 0 = no damping, 1 = critical damping.\r\n\tfloat32 dampingRatio;\r\n};\r\n\r\n/// A mouse joint is used to make a point on a body track a\r\n/// specified world point. This a soft constraint with a maximum\r\n/// force. This allows the constraint to stretch and without\r\n/// applying huge forces.\r\n/// NOTE: this joint is not documented in the manual because it was\r\n/// developed to be used in the testbed. If you want to learn how to\r\n/// use the mouse joint, look at the testbed.\r\nclass b2MouseJoint : public b2Joint\r\n{\r\npublic:\r\n\r\n\t/// Implements b2Joint.\r\n\tb2Vec2 GetAnchorA() const;\r\n\r\n\t/// Implements b2Joint.\r\n\tb2Vec2 GetAnchorB() const;\r\n\r\n\t/// Implements b2Joint.\r\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\r\n\r\n\t/// Implements b2Joint.\r\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\r\n\r\n\t/// Use this to update the target point.\r\n\tvoid SetTarget(const b2Vec2& target);\r\n\tconst b2Vec2& GetTarget() const;\r\n\r\n\t/// Set/get the maximum force in Newtons.\r\n\tvoid SetMaxForce(float32 force);\r\n\tfloat32 GetMaxForce() const;\r\n\r\n\t/// Set/get the frequency in Hertz.\r\n\tvoid SetFrequency(float32 hz);\r\n\tfloat32 GetFrequency() const;\r\n\r\n\t/// Set/get the damping ratio (dimensionless).\r\n\tvoid SetDampingRatio(float32 ratio);\r\n\tfloat32 GetDampingRatio() const;\r\n\r\n\t/// The mouse joint does not support dumping.\r\n\tvoid Dump() { b2Log(\"Mouse joint dumping is not supported.\\n\"); }\r\n\r\nprotected:\r\n\tfriend class b2Joint;\r\n\r\n\tb2MouseJoint(const b2MouseJointDef* def);\r\n\r\n\tvoid InitVelocityConstraints(const b2SolverData& data);\r\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\r\n\tbool SolvePositionConstraints(const b2SolverData& data);\r\n\r\n\tb2Vec2 m_localAnchorB;\r\n\tb2Vec2 m_targetA;\r\n\tfloat32 m_frequencyHz;\r\n\tfloat32 m_dampingRatio;\r\n\tfloat32 m_beta;\r\n\t\r\n\t// Solver shared\r\n\tb2Vec2 m_impulse;\r\n\tfloat32 m_maxForce;\r\n\tfloat32 m_gamma;\r\n\r\n\t// Solver temp\r\n\tint32 m_indexA;\r\n\tint32 m_indexB;\r\n\tb2Vec2 m_rB;\r\n\tb2Vec2 m_localCenterB;\r\n\tfloat32 m_invMassB;\r\n\tfloat32 m_invIB;\r\n\tb2Mat22 m_mass;\r\n\tb2Vec2 m_C;\r\n};\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_CONTACT_H\r\n#define B2_CONTACT_H\r\n\r\n#include <Box2D/Common/b2Math.h>\r\n#include <Box2D/Collision/b2Collision.h>\r\n#include <Box2D/Collision/Shapes/b2Shape.h>\r\n#include <Box2D/Dynamics/b2Fixture.h>\r\n\r\nclass b2Body;\r\nclass b2Contact;\r\nclass b2Fixture;\r\nclass b2World;\r\nclass b2BlockAllocator;\r\nclass b2StackAllocator;\r\nclass b2ContactListener;\r\n\r\n/// Friction mixing law. The idea is to allow either fixture to drive the restitution to zero.\r\n/// For example, anything slides on ice.\r\ninline float32 b2MixFriction(float32 friction1, float32 friction2)\r\n{\r\n\treturn std::sqrt(friction1 * friction2);\r\n}\r\n\r\n/// Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface.\r\n/// For example, a superball bounces on anything.\r\ninline float32 b2MixRestitution(float32 restitution1, float32 restitution2)\r\n{\r\n\treturn restitution1 > restitution2 ? restitution1 : restitution2;\r\n}\r\n\r\ntypedef b2Contact* b2ContactCreateFcn(\tb2Fixture* fixtureA, int32 indexA,\r\n\t\t\t\t\t\t\t\t\t\tb2Fixture* fixtureB, int32 indexB,\r\n\t\t\t\t\t\t\t\t\t\tb2BlockAllocator* allocator);\r\ntypedef void b2ContactDestroyFcn(b2Contact* contact, b2BlockAllocator* allocator);\r\n\r\nstruct b2ContactRegister\r\n{\r\n\tb2ContactCreateFcn* createFcn;\r\n\tb2ContactDestroyFcn* destroyFcn;\r\n\tbool primary;\r\n};\r\n\r\n/// A contact edge is used to connect bodies and contacts together\r\n/// in a contact graph where each body is a node and each contact\r\n/// is an edge. A contact edge belongs to a doubly linked list\r\n/// maintained in each attached body. Each contact has two contact\r\n/// nodes, one for each attached body.\r\nstruct b2ContactEdge\r\n{\r\n\tb2Body* other;\t\t\t///< provides quick access to the other body attached.\r\n\tb2Contact* contact;\t\t///< the contact\r\n\tb2ContactEdge* prev;\t///< the previous contact edge in the body's contact list\r\n\tb2ContactEdge* next;\t///< the next contact edge in the body's contact list\r\n};\r\n\r\n/// The class manages contact between two shapes. A contact exists for each overlapping\r\n/// AABB in the broad-phase (except if filtered). Therefore a contact object may exist\r\n/// that has no contact points.\r\nclass b2Contact\r\n{\r\npublic:\r\n\r\n\t/// Get the contact manifold. Do not modify the manifold unless you understand the\r\n\t/// internals of Box2D.\r\n\tb2Manifold* GetManifold();\r\n\tconst b2Manifold* GetManifold() const;\r\n\r\n\t/// Get the world manifold.\r\n\tvoid GetWorldManifold(b2WorldManifold* worldManifold) const;\r\n\r\n\t/// Is this contact touching?\r\n\tbool IsTouching() const;\r\n\r\n\t/// Enable/disable this contact. This can be used inside the pre-solve\r\n\t/// contact listener. The contact is only disabled for the current\r\n\t/// time step (or sub-step in continuous collisions).\r\n\tvoid SetEnabled(bool flag);\r\n\r\n\t/// Has this contact been disabled?\r\n\tbool IsEnabled() const;\r\n\r\n\t/// Get the next contact in the world's contact list.\r\n\tb2Contact* GetNext();\r\n\tconst b2Contact* GetNext() const;\r\n\r\n\t/// Get fixture A in this contact.\r\n\tb2Fixture* GetFixtureA();\r\n\tconst b2Fixture* GetFixtureA() const;\r\n\r\n\t/// Get the child primitive index for fixture A.\r\n\tint32 GetChildIndexA() const;\r\n\r\n\t/// Get fixture B in this contact.\r\n\tb2Fixture* GetFixtureB();\r\n\tconst b2Fixture* GetFixtureB() const;\r\n\r\n\t/// Get the child primitive index for fixture B.\r\n\tint32 GetChildIndexB() const;\r\n\r\n\t/// Override the default friction mixture. You can call this in b2ContactListener::PreSolve.\r\n\t/// This value persists until set or reset.\r\n\tvoid SetFriction(float32 friction);\r\n\r\n\t/// Get the friction.\r\n\tfloat32 GetFriction() const;\r\n\r\n\t/// Reset the friction mixture to the default value.\r\n\tvoid ResetFriction();\r\n\r\n\t/// Override the default restitution mixture. You can call this in b2ContactListener::PreSolve.\r\n\t/// The value persists until you set or reset.\r\n\tvoid SetRestitution(float32 restitution);\r\n\r\n\t/// Get the restitution.\r\n\tfloat32 GetRestitution() const;\r\n\r\n\t/// Reset the restitution to the default value.\r\n\tvoid ResetRestitution();\r\n\r\n\t/// Evaluate this contact with your own manifold and transforms.\r\n\tvirtual void Evaluate(b2Manifold* manifold, const b2Transform& xfA, const b2Transform& xfB) = 0;\r\n\r\nprotected:\r\n\tfriend class b2ContactManager;\r\n\tfriend class b2World;\r\n\tfriend class b2ContactSolver;\r\n\tfriend class b2Body;\r\n\tfriend class b2Fixture;\r\n\r\n\t// Flags stored in m_flags\r\n\tenum\r\n\t{\r\n\t\t// Used when crawling contact graph when forming islands.\r\n\t\te_islandFlag\t\t= 0x0001,\r\n\r\n        // Set when the shapes are touching.\r\n\t\te_touchingFlag\t\t= 0x0002,\r\n\r\n\t\t// This contact can be disabled (by user)\r\n\t\te_enabledFlag\t\t= 0x0004,\r\n\r\n\t\t// This contact needs filtering because a fixture filter was changed.\r\n\t\te_filterFlag\t\t= 0x0008,\r\n\r\n\t\t// This bullet contact had a TOI event\r\n\t\te_bulletHitFlag\t\t= 0x0010,\r\n\r\n\t\t// This contact has a valid TOI in m_toi\r\n\t\te_toiFlag\t\t\t= 0x0020\r\n\t};\r\n\r\n\t/// Flag this contact for filtering. Filtering will occur the next time step.\r\n\tvoid FlagForFiltering();\r\n\r\n\tstatic void AddType(b2ContactCreateFcn* createFcn, b2ContactDestroyFcn* destroyFcn,\r\n\t\t\t\t\t\tb2Shape::Type typeA, b2Shape::Type typeB);\r\n\tstatic void InitializeRegisters();\r\n\tstatic b2Contact* Create(b2Fixture* fixtureA, int32 indexA, b2Fixture* fixtureB, int32 indexB, b2BlockAllocator* allocator);\r\n\tstatic void Destroy(b2Contact* contact, b2Shape::Type typeA, b2Shape::Type typeB, b2BlockAllocator* allocator);\r\n\tstatic void Destroy(b2Contact* contact, b2BlockAllocator* allocator);\r\n\r\n\tb2Contact() : m_fixtureA(NULL), m_fixtureB(NULL) {}\r\n\tb2Contact(b2Fixture* fixtureA, int32 indexA, b2Fixture* fixtureB, int32 indexB);\r\n\tvirtual ~b2Contact() {}\r\n\r\n\tvoid Update(b2ContactListener* listener);\r\n\r\n\tstatic b2ContactRegister s_registers[b2Shape::e_typeCount][b2Shape::e_typeCount];\r\n\tstatic bool s_initialized;\r\n\r\n\tuint32 m_flags;\r\n\r\n\t// World pool and list pointers.\r\n\tb2Contact* m_prev;\r\n\tb2Contact* m_next;\r\n\r\n\t// Nodes for connecting bodies.\r\n\tb2ContactEdge m_nodeA;\r\n\tb2ContactEdge m_nodeB;\r\n\r\n\tb2Fixture* m_fixtureA;\r\n\tb2Fixture* m_fixtureB;\r\n\r\n\tint32 m_indexA;\r\n\tint32 m_indexB;\r\n\r\n\tb2Manifold m_manifold;\r\n\r\n\tint32 m_toiCount;\r\n\tfloat32 m_toi;\r\n\r\n\tfloat32 m_friction;\r\n\tfloat32 m_restitution;\r\n};\r\n\r\ninline b2Manifold* b2Contact::GetManifold()\r\n{\r\n\treturn &m_manifold;\r\n}\r\n\r\ninline const b2Manifold* b2Contact::GetManifold() const\r\n{\r\n\treturn &m_manifold;\r\n}\r\n\r\ninline void b2Contact::GetWorldManifold(b2WorldManifold* worldManifold) const\r\n{\r\n\tconst b2Body* bodyA = m_fixtureA->GetBody();\r\n\tconst b2Body* bodyB = m_fixtureB->GetBody();\r\n\tconst b2Shape* shapeA = m_fixtureA->GetShape();\r\n\tconst b2Shape* shapeB = m_fixtureB->GetShape();\r\n\r\n\tworldManifold->Initialize(&m_manifold, bodyA->GetTransform(), shapeA->m_radius, bodyB->GetTransform(), shapeB->m_radius);\r\n}\r\n\r\ninline void b2Contact::SetEnabled(bool flag)\r\n{\r\n\tif (flag)\r\n\t{\r\n\t\tm_flags |= e_enabledFlag;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_flags &= ~e_enabledFlag;\r\n\t}\r\n}\r\n\r\ninline bool b2Contact::IsEnabled() const\r\n{\r\n\treturn (m_flags & e_enabledFlag) == e_enabledFlag;\r\n}\r\n\r\ninline bool b2Contact::IsTouching() const\r\n{\r\n\treturn (m_flags & e_touchingFlag) == e_touchingFlag;\r\n}\r\n\r\ninline b2Contact* b2Contact::GetNext()\r\n{\r\n\treturn m_next;\r\n}\r\n\r\ninline const b2Contact* b2Contact::GetNext() const\r\n{\r\n\treturn m_next;\r\n}\r\n\r\ninline b2Fixture* b2Contact::GetFixtureA()\r\n{\r\n\treturn m_fixtureA;\r\n}\r\n\r\ninline const b2Fixture* b2Contact::GetFixtureA() const\r\n{\r\n\treturn m_fixtureA;\r\n}\r\n\r\ninline b2Fixture* b2Contact::GetFixtureB()\r\n{\r\n\treturn m_fixtureB;\r\n}\r\n\r\ninline int32 b2Contact::GetChildIndexA() const\r\n{\r\n\treturn m_indexA;\r\n}\r\n\r\ninline const b2Fixture* b2Contact::GetFixtureB() const\r\n{\r\n\treturn m_fixtureB;\r\n}\r\n\r\ninline int32 b2Contact::GetChildIndexB() const\r\n{\r\n\treturn m_indexB;\r\n}\r\n\r\ninline void b2Contact::FlagForFiltering()\r\n{\r\n\tm_flags |= e_filterFlag;\r\n}\r\n\r\ninline void b2Contact::SetFriction(float32 friction)\r\n{\r\n\tm_friction = friction;\r\n}\r\n\r\ninline float32 b2Contact::GetFriction() const\r\n{\r\n\treturn m_friction;\r\n}\r\n\r\ninline void b2Contact::ResetFriction()\r\n{\r\n\tm_friction = b2MixFriction(m_fixtureA->m_friction, m_fixtureB->m_friction);\r\n}\r\n\r\ninline void b2Contact::SetRestitution(float32 restitution)\r\n{\r\n\tm_restitution = restitution;\r\n}\r\n\r\ninline float32 b2Contact::GetRestitution() const\r\n{\r\n\treturn m_restitution;\r\n}\r\n\r\ninline void b2Contact::ResetRestitution()\r\n{\r\n\tm_restitution = b2MixRestitution(m_fixtureA->m_restitution, m_fixtureB->m_restitution);\r\n}\r\n\r\n#endif\r\n","/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n#ifndef B2_WORLD_CALLBACKS_H\r\n#define B2_WORLD_CALLBACKS_H\r\n\r\n#include <Box2D/Common/b2Settings.h>\r\n\r\nstruct b2Vec2;\r\nstruct b2Transform;\r\nclass b2Fixture;\r\nclass b2Body;\r\nclass b2Joint;\r\nclass b2Contact;\r\nstruct b2ContactResult;\r\nstruct b2Manifold;\r\n\r\n/// Joints and fixtures are destroyed when their associated\r\n/// body is destroyed. Implement this listener so that you\r\n/// may nullify references to these joints and shapes.\r\nclass b2DestructionListener\r\n{\r\npublic:\r\n\tvirtual ~b2DestructionListener() {}\r\n\r\n\t/// Called when any joint is about to be destroyed due\r\n\t/// to the destruction of one of its attached bodies.\r\n\tvirtual void SayGoodbye(b2Joint* joint) = 0;\r\n\r\n\t/// Called when any fixture is about to be destroyed due\r\n\t/// to the destruction of its parent body.\r\n\tvirtual void SayGoodbye(b2Fixture* fixture) = 0;\r\n};\r\n\r\n/// Implement this class to provide collision filtering. In other words, you can implement\r\n/// this class if you want finer control over contact creation.\r\nclass b2ContactFilter\r\n{\r\npublic:\r\n\tvirtual ~b2ContactFilter() {}\r\n\r\n\t/// Return true if contact calculations should be performed between these two shapes.\r\n\t/// @warning for performance reasons this is only called when the AABBs begin to overlap.\r\n\tvirtual bool ShouldCollide(b2Fixture* fixtureA, b2Fixture* fixtureB);\r\n};\r\n\r\n/// Contact impulses for reporting. Impulses are used instead of forces because\r\n/// sub-step forces may approach infinity for rigid body collisions. These\r\n/// match up one-to-one with the contact points in b2Manifold.\r\nstruct b2ContactImpulse\r\n{\r\n\tfloat32 normalImpulses[b2_maxManifoldPoints];\r\n\tfloat32 tangentImpulses[b2_maxManifoldPoints];\r\n\tint32 count;\r\n};\r\n\r\n/// Implement this class to get contact information. You can use these results for\r\n/// things like sounds and game logic. You can also get contact results by\r\n/// traversing the contact lists after the time step. However, you might miss\r\n/// some contacts because continuous physics leads to sub-stepping.\r\n/// Additionally you may receive multiple callbacks for the same contact in a\r\n/// single time step.\r\n/// You should strive to make your callbacks efficient because there may be\r\n/// many callbacks per time step.\r\n/// @warning You cannot create/destroy Box2D entities inside these callbacks.\r\nclass b2ContactListener\r\n{\r\npublic:\r\n\tvirtual ~b2ContactListener() {}\r\n\r\n\t/// Called when two fixtures begin to touch.\r\n\tvirtual void BeginContact(b2Contact* contact) { B2_NOT_USED(contact); }\r\n\r\n\t/// Called when two fixtures cease to touch.\r\n\tvirtual void EndContact(b2Contact* contact) { B2_NOT_USED(contact); }\r\n\r\n\t/// This is called after a contact is updated. This allows you to inspect a\r\n\t/// contact before it goes to the solver. If you are careful, you can modify the\r\n\t/// contact manifold (e.g. disable contact).\r\n\t/// A copy of the old manifold is provided so that you can detect changes.\r\n\t/// Note: this is called only for awake bodies.\r\n\t/// Note: this is called even when the number of contact points is zero.\r\n\t/// Note: this is not called for sensors.\r\n\t/// Note: if you set the number of contact points to zero, you will not\r\n\t/// get an EndContact callback. However, you may get a BeginContact callback\r\n\t/// the next step.\r\n\tvirtual void PreSolve(b2Contact* contact, const b2Manifold* oldManifold)\r\n\t{\r\n\t\tB2_NOT_USED(contact);\r\n\t\tB2_NOT_USED(oldManifold);\r\n\t}\r\n\r\n\t/// This lets you inspect a contact after the solver is finished. This is useful\r\n\t/// for inspecting impulses.\r\n\t/// Note: the contact manifold does not include time of impact impulses, which can be\r\n\t/// arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly\r\n\t/// in a separate data structure.\r\n\t/// Note: this is only called for contacts that are touching, solid, and awake.\r\n\tvirtual void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse)\r\n\t{\r\n\t\tB2_NOT_USED(contact);\r\n\t\tB2_NOT_USED(impulse);\r\n\t}\r\n};\r\n\r\n/// Callback class for AABB queries.\r\n/// See b2World::Query\r\nclass b2QueryCallback\r\n{\r\npublic:\r\n\tvirtual ~b2QueryCallback() {}\r\n\r\n\t/// Called for each fixture found in the query AABB.\r\n\t/// @return false to terminate the query.\r\n\tvirtual bool ReportFixture(b2Fixture* fixture) = 0;\r\n};\r\n\r\n/// Callback class for ray casts.\r\n/// See b2World::RayCast\r\nclass b2RayCastCallback\r\n{\r\npublic:\r\n\tvirtual ~b2RayCastCallback() {}\r\n\r\n\t/// Called for each fixture found in the query. You control how the ray cast\r\n\t/// proceeds by returning a float:\r\n\t/// return -1: ignore this fixture and continue\r\n\t/// return 0: terminate the ray cast\r\n\t/// return fraction: clip the ray to this point\r\n\t/// return 1: don't clip the ray and continue\r\n\t/// @param fixture the fixture hit by the ray\r\n\t/// @param point the point of initial intersection\r\n\t/// @param normal the normal vector at the point of intersection\r\n\t/// @return -1 to filter, 0 to terminate, fraction to clip the ray for\r\n\t/// closest hit, 1 to continue\r\n\tvirtual float32 ReportFixture(\tb2Fixture* fixture, const b2Vec2& point,\r\n\t\t\t\t\t\t\t\t\tconst b2Vec2& normal, float32 fraction) = 0;\r\n};\r\n\r\n#endif\r\n","\n#include <Box2D/Box2D.h>\n\ntypedef b2Shape::Type b2ShapeType;\ntypedef b2ContactFeature::Type b2ContactFeatureType;\ntypedef b2Manifold::Type b2ManifoldType;\ntypedef uint32 b2DrawFlag;\n\n// Map SayGoodbye({b2Joint,b2Fixture}*) to SayGoodbye{Joint,Fixture}(..),\n// so that the JS implementation can listen for both callbacks.\nclass b2DestructionListenerWrapper : b2DestructionListener {\npublic:\n  virtual ~b2DestructionListenerWrapper() {}\n\n  virtual void SayGoodbyeJoint(b2Joint* joint) = 0;\n  virtual void SayGoodbyeFixture(b2Fixture* fixture) = 0;\n\n  void SayGoodbye(b2Joint* joint) {\n    SayGoodbyeJoint(joint);\n  }\n\n  void SayGoodbye(b2Fixture* fixture) {\n    SayGoodbyeFixture(fixture);\n  }\n};\n\n#include \"box2d_glue.cpp\"\n"]}